// This file is autogenerated.
package client

import (
	"fmt"
	"github.com/keybase/cli"
	"github.com/keybase/client/go/libcmdline"
	"github.com/keybase/client/go/libkb"
	keybase1 "github.com/keybase/client/protocol/go"
	"github.com/maxtaco/go-framed-msgpack-rpc/rpc2"
)

type CmdBTC struct {
	sessionID int
	address   string
	force     bool
}

func (c *CmdBTC) ParseArgv(ctx *cli.Context) error {
	if len(ctx.Args()) != 1 {
		return fmt.Errorf("Invalid arguments.")
	}
	c.address = ctx.Args()[0]
	c.force = ctx.Bool("force")
	return nil
}

func NewCmdBTC(cmd libcmdline.Command, cl *libcmdline.CommandLine) cli.Command {
	return cli.Command{
		Name:        "btc",
		Usage:       "keybase btc [--force] <address>",
		Description: "Claim a bitcoin address.",
		Flags: []cli.Flag{
			cli.BoolFlag{Name: "force", Usage: ""},
		},
		Action: func(c *cli.Context) {
			cl.ChooseCommand(cmd, "btc", c)
		},
	}
}

func (c *CmdBTC) Run() (err error) {
	c.sessionID, err = libkb.RandInt()
	if err != nil {
		return err
	}
	cli, err := GetBTCClient()
	if err != nil {
		return err
	}

	protocols := []rpc2.Protocol{
		NewLogUIProtocol(),
		NewSecretUIProtocol(),
		NewLocksmithUIProtocol(),
	}
	if err = RegisterProtocols(protocols); err != nil {
		return
	}

	err = cli.RegisterBTC(keybase1.RegisterBTCArg{Address: c.address,
		Force: c.force})
	return
}

func (c *CmdBTC) GetUsage() libkb.Usage {
	return libkb.Usage{
		Config:     true,
		GpgKeyring: true,
		KbKeyring:  true,
		API:        true,
	}
}

type CmdDeviceList struct {
	sessionID int
	all       bool
}

func (c *CmdDeviceList) ParseArgv(ctx *cli.Context) error {
	if len(ctx.Args()) != 0 {
		return fmt.Errorf("Invalid arguments.")
	}
	c.all = ctx.Bool("all")
	return nil
}

func NewCmdDeviceList(cmd libcmdline.Command, cl *libcmdline.CommandLine) cli.Command {
	return cli.Command{
		Name:        "list",
		Usage:       "keybase device list [--all]",
		Description: "List devices for the user",
		Flags: []cli.Flag{
			cli.BoolFlag{Name: "all", Usage: ""},
		},
		Action: func(c *cli.Context) {
			cl.ChooseCommand(cmd, "list", c)
		},
	}
}

func (c *CmdDeviceList) Run() (err error) {
	c.sessionID, err = libkb.RandInt()
	if err != nil {
		return err
	}
	cli, err := GetDeviceClient()
	if err != nil {
		return err
	}

	protocols := []rpc2.Protocol{
		NewLogUIProtocol(),
		NewSecretUIProtocol(),
		NewLocksmithUIProtocol(),
	}
	if err = RegisterProtocols(protocols); err != nil {
		return
	}

	_, err = cli.DeviceList(keybase1.DeviceListArg{All: c.all})
	return
}

func (c *CmdDeviceList) GetUsage() libkb.Usage {
	return libkb.Usage{
		Config:     true,
		GpgKeyring: true,
		KbKeyring:  true,
		API:        true,
	}
}

type CmdDeviceAdd struct {
	sessionID    int
	secretPhrase string
}

func (c *CmdDeviceAdd) ParseArgv(ctx *cli.Context) error {
	if len(ctx.Args()) != 1 {
		return fmt.Errorf("Invalid arguments.")
	}
	c.secretPhrase = ctx.Args()[0]
	return nil
}

func NewCmdDeviceAdd(cmd libcmdline.Command, cl *libcmdline.CommandLine) cli.Command {
	return cli.Command{
		Name:        "add",
		Usage:       "keybase device add <secretPhrase>",
		Description: "Add a new device using a phrase from an existing device.",
		Flags:       []cli.Flag{},
		Action: func(c *cli.Context) {
			cl.ChooseCommand(cmd, "add", c)
		},
	}
}

func (c *CmdDeviceAdd) Run() (err error) {
	c.sessionID, err = libkb.RandInt()
	if err != nil {
		return err
	}
	cli, err := GetDeviceClient()
	if err != nil {
		return err
	}

	protocols := []rpc2.Protocol{
		NewLogUIProtocol(),
		NewSecretUIProtocol(),
		NewLocksmithUIProtocol(),
	}
	if err = RegisterProtocols(protocols); err != nil {
		return
	}

	err = cli.DeviceAdd(keybase1.DeviceAddArg{SecretPhrase: c.secretPhrase})
	return
}

func (c *CmdDeviceAdd) GetUsage() libkb.Usage {
	return libkb.Usage{
		Config:     true,
		GpgKeyring: true,
		KbKeyring:  true,
		API:        true,
	}
}

type CmdDoctor struct {
	sessionID int
}

func (c *CmdDoctor) ParseArgv(ctx *cli.Context) error {
	if len(ctx.Args()) != 0 {
		return fmt.Errorf("Invalid arguments.")
	}

	return nil
}

func NewCmdDoctor(cmd libcmdline.Command, cl *libcmdline.CommandLine) cli.Command {
	return cli.Command{
		Name:        "doctor",
		Usage:       "keybase doctor",
		Description: "Checks account status and offers to fix any issues.",
		Flags:       []cli.Flag{},
		Action: func(c *cli.Context) {
			cl.ChooseCommand(cmd, "doctor", c)
		},
	}
}

func (c *CmdDoctor) Run() (err error) {
	c.sessionID, err = libkb.RandInt()
	if err != nil {
		return err
	}
	cli, err := GetDoctorClient()
	if err != nil {
		return err
	}

	protocols := []rpc2.Protocol{
		NewLogUIProtocol(),
		NewSecretUIProtocol(),
		NewLocksmithUIProtocol(),
	}
	if err = RegisterProtocols(protocols); err != nil {
		return
	}

	err = cli.Doctor(c.sessionID)
	return
}

func (c *CmdDoctor) GetUsage() libkb.Usage {
	return libkb.Usage{
		Config:     true,
		GpgKeyring: true,
		KbKeyring:  true,
		API:        true,
	}
}

type CmdFavoriteAdd struct {
	sessionID int
	name      string
}

func (c *CmdFavoriteAdd) ParseArgv(ctx *cli.Context) error {
	if len(ctx.Args()) != 1 {
		return fmt.Errorf("Invalid arguments.")
	}
	c.name = ctx.Args()[0]
	return nil
}

func NewCmdFavoriteAdd(cmd libcmdline.Command, cl *libcmdline.CommandLine) cli.Command {
	return cli.Command{
		Name:        "add",
		Usage:       "keybase favorite add <name>",
		Description: "Add favorite top-level folder by name.",
		Flags:       []cli.Flag{},
		Action: func(c *cli.Context) {
			cl.ChooseCommand(cmd, "add", c)
		},
	}
}

func (c *CmdFavoriteAdd) Run() (err error) {
	c.sessionID, err = libkb.RandInt()
	if err != nil {
		return err
	}
	cli, err := GetFavoriteClient()
	if err != nil {
		return err
	}

	protocols := []rpc2.Protocol{
		NewLogUIProtocol(),
		NewSecretUIProtocol(),
		NewLocksmithUIProtocol(),
	}
	if err = RegisterProtocols(protocols); err != nil {
		return
	}

	err = cli.FavoriteAddTLF(keybase1.FavoriteAddTLFArg{Name: c.name})
	return
}

func (c *CmdFavoriteAdd) GetUsage() libkb.Usage {
	return libkb.Usage{
		Config:     true,
		GpgKeyring: true,
		KbKeyring:  true,
		API:        true,
	}
}

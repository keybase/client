// Auto-generated by avdl-compiler v1.3.1 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/rekey.avdl

package keybase1

import (
	rpc "github.com/keybase/go-framed-msgpack-rpc"
	context "golang.org/x/net/context"
)

type TLFID string
type TLF struct {
	Tlfid     TLFID    `codec:"tlfid" json:"tlfid"`
	Name      string   `codec:"name" json:"name"`
	Writers   []string `codec:"writers" json:"writers"`
	Readers   []string `codec:"readers" json:"readers"`
	IsPrivate bool     `codec:"isPrivate" json:"isPrivate"`
}

type ProblemUser struct {
	User           User     `codec:"user" json:"user"`
	ProblemDevices []Device `codec:"problemDevices" json:"problemDevices"`
}

type RekeyTLF struct {
	Tlf          TLF           `codec:"tlf" json:"tlf"`
	ProblemUsers []ProblemUser `codec:"problemUsers" json:"problemUsers"`
	Score        int           `codec:"score" json:"score"`
	Solutions    []DeviceID    `codec:"solutions" json:"solutions"`
}

type Outcome int

const (
	Outcome_NONE    Outcome = 0
	Outcome_FIXED   Outcome = 1
	Outcome_IGNORED Outcome = 2
)

type ShowPendingRekeyStatusArg struct {
	SessionID int `codec:"sessionID" json:"sessionID"`
}

type ShowRekeyStatusArg struct {
	SessionID int     `codec:"sessionID" json:"sessionID"`
	Tlfs      []TLFID `codec:"tlfs" json:"tlfs"`
	User      *UID    `codec:"user,omitempty" json:"user,omitempty"`
	Kid       *KID    `codec:"kid,omitempty" json:"kid,omitempty"`
}

type GetRekeyTLFsArg struct {
	SessionID int `codec:"sessionID" json:"sessionID"`
}

type RekeyStatusFinishArg struct {
	SessionID int `codec:"sessionID" json:"sessionID"`
}

type RekeyInterface interface {
	// ShowPendingRekeyStatus shows either pending gregor-initiated rekey harassments
	// * or nothing if none were pending.
	ShowPendingRekeyStatus(context.Context, int) error
	// ShowRekeyStatus is used by the CLI to kick off a "ShowRekeyStatus" window for the given user based on
	// * the passed-in parameters. These are the parameters that are typically delivered via direct
	// * gregor injection. Will be used primarily in debugging or in advanced command-line usage.
	ShowRekeyStatus(context.Context, ShowRekeyStatusArg) error
	// getRekeyTLFs is called by the UI to render which TLFs need to be fixed.
	// * The UI will repeatedly poll this RPC when it gets a `rekeyChanged` notice
	// * below
	GetRekeyTLFs(context.Context, int) ([]RekeyTLF, error)
	// finish is called when work is completed on a given RekeyStatus window. The Outcome
	// * can be Fixed or Ignored.
	RekeyStatusFinish(context.Context, int) (Outcome, error)
}

func RekeyProtocol(i RekeyInterface) rpc.Protocol {
	return rpc.Protocol{
		Name: "keybase.1.rekey",
		Methods: map[string]rpc.ServeHandlerDescription{
			"showPendingRekeyStatus": {
				MakeArg: func() interface{} {
					ret := make([]ShowPendingRekeyStatusArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]ShowPendingRekeyStatusArg)
					if !ok {
						err = rpc.NewTypeError((*[]ShowPendingRekeyStatusArg)(nil), args)
						return
					}
					err = i.ShowPendingRekeyStatus(ctx, (*typedArgs)[0].SessionID)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"showRekeyStatus": {
				MakeArg: func() interface{} {
					ret := make([]ShowRekeyStatusArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]ShowRekeyStatusArg)
					if !ok {
						err = rpc.NewTypeError((*[]ShowRekeyStatusArg)(nil), args)
						return
					}
					err = i.ShowRekeyStatus(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"getRekeyTLFs": {
				MakeArg: func() interface{} {
					ret := make([]GetRekeyTLFsArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]GetRekeyTLFsArg)
					if !ok {
						err = rpc.NewTypeError((*[]GetRekeyTLFsArg)(nil), args)
						return
					}
					ret, err = i.GetRekeyTLFs(ctx, (*typedArgs)[0].SessionID)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"rekeyStatusFinish": {
				MakeArg: func() interface{} {
					ret := make([]RekeyStatusFinishArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]RekeyStatusFinishArg)
					if !ok {
						err = rpc.NewTypeError((*[]RekeyStatusFinishArg)(nil), args)
						return
					}
					ret, err = i.RekeyStatusFinish(ctx, (*typedArgs)[0].SessionID)
					return
				},
				MethodType: rpc.MethodCall,
			},
		},
	}
}

type RekeyClient struct {
	Cli rpc.GenericClient
}

// ShowPendingRekeyStatus shows either pending gregor-initiated rekey harassments
// * or nothing if none were pending.
func (c RekeyClient) ShowPendingRekeyStatus(ctx context.Context, sessionID int) (err error) {
	__arg := ShowPendingRekeyStatusArg{SessionID: sessionID}
	err = c.Cli.Call(ctx, "keybase.1.rekey.showPendingRekeyStatus", []interface{}{__arg}, nil)
	return
}

// ShowRekeyStatus is used by the CLI to kick off a "ShowRekeyStatus" window for the given user based on
// * the passed-in parameters. These are the parameters that are typically delivered via direct
// * gregor injection. Will be used primarily in debugging or in advanced command-line usage.
func (c RekeyClient) ShowRekeyStatus(ctx context.Context, __arg ShowRekeyStatusArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.rekey.showRekeyStatus", []interface{}{__arg}, nil)
	return
}

// getRekeyTLFs is called by the UI to render which TLFs need to be fixed.
// * The UI will repeatedly poll this RPC when it gets a `rekeyChanged` notice
// * below
func (c RekeyClient) GetRekeyTLFs(ctx context.Context, sessionID int) (res []RekeyTLF, err error) {
	__arg := GetRekeyTLFsArg{SessionID: sessionID}
	err = c.Cli.Call(ctx, "keybase.1.rekey.getRekeyTLFs", []interface{}{__arg}, &res)
	return
}

// finish is called when work is completed on a given RekeyStatus window. The Outcome
// * can be Fixed or Ignored.
func (c RekeyClient) RekeyStatusFinish(ctx context.Context, sessionID int) (res Outcome, err error) {
	__arg := RekeyStatusFinishArg{SessionID: sessionID}
	err = c.Cli.Call(ctx, "keybase.1.rekey.rekeyStatusFinish", []interface{}{__arg}, &res)
	return
}

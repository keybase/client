// Auto-generated by avdl-compiler v1.3.29 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/chat1/commands.avdl

package chat1

import (
	"errors"
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
)

type ConversationCommand struct {
	Name        string `codec:"name" json:"name"`
	Usage       string `codec:"usage" json:"usage"`
	Description string `codec:"description" json:"description"`
}

func (o ConversationCommand) DeepCopy() ConversationCommand {
	return ConversationCommand{
		Name:        o.Name,
		Usage:       o.Usage,
		Description: o.Description,
	}
}

type ConversationCommandGroup struct {
	Heading  string                `codec:"heading" json:"heading"`
	Username *string               `codec:"username,omitempty" json:"username,omitempty"`
	Commands []ConversationCommand `codec:"commands" json:"commands"`
}

func (o ConversationCommandGroup) DeepCopy() ConversationCommandGroup {
	return ConversationCommandGroup{
		Heading: o.Heading,
		Username: (func(x *string) *string {
			if x == nil {
				return nil
			}
			tmp := (*x)
			return &tmp
		})(o.Username),
		Commands: (func(x []ConversationCommand) []ConversationCommand {
			if x == nil {
				return nil
			}
			ret := make([]ConversationCommand, len(x))
			for i, v := range x {
				vCopy := v.DeepCopy()
				ret[i] = vCopy
			}
			return ret
		})(o.Commands),
	}
}

type ConversationCommandGroupsTyp int

const (
	ConversationCommandGroupsTyp_BUILTIN  ConversationCommandGroupsTyp = 0
	ConversationCommandGroupsTyp_EXTENDED ConversationCommandGroupsTyp = 1
)

func (o ConversationCommandGroupsTyp) DeepCopy() ConversationCommandGroupsTyp { return o }

var ConversationCommandGroupsTypMap = map[string]ConversationCommandGroupsTyp{
	"BUILTIN":  0,
	"EXTENDED": 1,
}

var ConversationCommandGroupsTypRevMap = map[ConversationCommandGroupsTyp]string{
	0: "BUILTIN",
	1: "EXTENDED",
}

func (e ConversationCommandGroupsTyp) String() string {
	if v, ok := ConversationCommandGroupsTypRevMap[e]; ok {
		return v
	}
	return ""
}

type ConversationCommandGroupsExtended struct {
	Groups []ConversationCommandGroup `codec:"groups" json:"groups"`
}

func (o ConversationCommandGroupsExtended) DeepCopy() ConversationCommandGroupsExtended {
	return ConversationCommandGroupsExtended{
		Groups: (func(x []ConversationCommandGroup) []ConversationCommandGroup {
			if x == nil {
				return nil
			}
			ret := make([]ConversationCommandGroup, len(x))
			for i, v := range x {
				vCopy := v.DeepCopy()
				ret[i] = vCopy
			}
			return ret
		})(o.Groups),
	}
}

type ConversationCommandGroups struct {
	Typ__      ConversationCommandGroupsTyp       `codec:"typ" json:"typ"`
	Extended__ *ConversationCommandGroupsExtended `codec:"extended,omitempty" json:"extended,omitempty"`
}

func (o *ConversationCommandGroups) Typ() (ret ConversationCommandGroupsTyp, err error) {
	switch o.Typ__ {
	case ConversationCommandGroupsTyp_EXTENDED:
		if o.Extended__ == nil {
			err = errors.New("unexpected nil value for Extended__")
			return ret, err
		}
	}
	return o.Typ__, nil
}

func (o ConversationCommandGroups) Extended() (res ConversationCommandGroupsExtended) {
	if o.Typ__ != ConversationCommandGroupsTyp_EXTENDED {
		panic("wrong case accessed")
	}
	if o.Extended__ == nil {
		return
	}
	return *o.Extended__
}

func NewConversationCommandGroupsWithBuiltin() ConversationCommandGroups {
	return ConversationCommandGroups{
		Typ__: ConversationCommandGroupsTyp_BUILTIN,
	}
}

func NewConversationCommandGroupsWithExtended(v ConversationCommandGroupsExtended) ConversationCommandGroups {
	return ConversationCommandGroups{
		Typ__:      ConversationCommandGroupsTyp_EXTENDED,
		Extended__: &v,
	}
}

func (o ConversationCommandGroups) DeepCopy() ConversationCommandGroups {
	return ConversationCommandGroups{
		Typ__: o.Typ__.DeepCopy(),
		Extended__: (func(x *ConversationCommandGroupsExtended) *ConversationCommandGroupsExtended {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Extended__),
	}
}

type CommandsInterface interface {
}

func CommandsProtocol(i CommandsInterface) rpc.Protocol {
	return rpc.Protocol{
		Name:    "chat.1.commands",
		Methods: map[string]rpc.ServeHandlerDescription{},
	}
}

type CommandsClient struct {
	Cli rpc.GenericClient
}

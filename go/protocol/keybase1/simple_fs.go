// Auto-generated by avdl-compiler v1.3.11 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/keybase1/simple_fs.avdl

package keybase1

import (
	"errors"
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
	context "golang.org/x/net/context"
)

type OpID [16]byte
type PathType int

const (
	PathType_LOCAL PathType = 0
	PathType_KBFS  PathType = 1
)

var PathTypeMap = map[string]PathType{
	"LOCAL": 0,
	"KBFS":  1,
}

var PathTypeRevMap = map[PathType]string{
	0: "LOCAL",
	1: "KBFS",
}

func (e PathType) String() string {
	if v, ok := PathTypeRevMap[e]; ok {
		return v
	}
	return ""
}

type Path struct {
	PathType__ PathType `codec:"PathType" json:"PathType"`
	Local__    *string  `codec:"local,omitempty" json:"local,omitempty"`
	Kbfs__     *string  `codec:"kbfs,omitempty" json:"kbfs,omitempty"`
}

func (o *Path) PathType() (ret PathType, err error) {
	switch o.PathType__ {
	case PathType_LOCAL:
		if o.Local__ == nil {
			err = errors.New("unexpected nil value for Local__")
			return ret, err
		}
	case PathType_KBFS:
		if o.Kbfs__ == nil {
			err = errors.New("unexpected nil value for Kbfs__")
			return ret, err
		}
	}
	return o.PathType__, nil
}

func (o Path) Local() string {
	if o.PathType__ != PathType_LOCAL {
		panic("wrong case accessed")
	}
	if o.Local__ == nil {
		return ""
	}
	return *o.Local__
}

func (o Path) Kbfs() string {
	if o.PathType__ != PathType_KBFS {
		panic("wrong case accessed")
	}
	if o.Kbfs__ == nil {
		return ""
	}
	return *o.Kbfs__
}

func NewPathWithLocal(v string) Path {
	return Path{
		PathType__: PathType_LOCAL,
		Local__:    &v,
	}
}

func NewPathWithKbfs(v string) Path {
	return Path{
		PathType__: PathType_KBFS,
		Kbfs__:     &v,
	}
}

type DirentType int

const (
	DirentType_FILE DirentType = 0
	DirentType_DIR  DirentType = 1
	DirentType_SYM  DirentType = 2
	DirentType_EXEC DirentType = 3
)

var DirentTypeMap = map[string]DirentType{
	"FILE": 0,
	"DIR":  1,
	"SYM":  2,
	"EXEC": 3,
}

var DirentTypeRevMap = map[DirentType]string{
	0: "FILE",
	1: "DIR",
	2: "SYM",
	3: "EXEC",
}

func (e DirentType) String() string {
	if v, ok := DirentTypeRevMap[e]; ok {
		return v
	}
	return ""
}

type Dirent struct {
	Time       Time       `codec:"time" json:"time"`
	Size       int        `codec:"size" json:"size"`
	DirentType DirentType `codec:"direntType" json:"direntType"`
}

type ErrorNum int
type OpenFlags int

const (
	OpenFlags_READ       OpenFlags = 0
	OpenFlags_REPLACE    OpenFlags = 1
	OpenFlags_EXISTING   OpenFlags = 2
	OpenFlags_WRITE      OpenFlags = 4
	OpenFlags_EXECUTABLE OpenFlags = 8
	OpenFlags_DIRECTORY  OpenFlags = 16
)

var OpenFlagsMap = map[string]OpenFlags{
	"READ":       0,
	"REPLACE":    1,
	"EXISTING":   2,
	"WRITE":      4,
	"EXECUTABLE": 8,
	"DIRECTORY":  16,
}

var OpenFlagsRevMap = map[OpenFlags]string{
	0:  "READ",
	1:  "REPLACE",
	2:  "EXISTING",
	4:  "WRITE",
	8:  "EXECUTABLE",
	16: "DIRECTORY",
}

func (e OpenFlags) String() string {
	if v, ok := OpenFlagsRevMap[e]; ok {
		return v
	}
	return ""
}

type Progress int
type SfListResult struct {
	Paths    []Path   `codec:"paths" json:"paths"`
	Progress Progress `codec:"progress" json:"progress"`
}

type FileContent struct {
	Data     []byte   `codec:"data" json:"data"`
	Progress Progress `codec:"progress" json:"progress"`
}

type AsyncOps int

const (
	AsyncOps_LIST           AsyncOps = 0
	AsyncOps_LIST_RECURSIVE AsyncOps = 1
	AsyncOps_READ           AsyncOps = 2
	AsyncOps_WRITE          AsyncOps = 3
	AsyncOps_COPY           AsyncOps = 4
	AsyncOps_MOVE           AsyncOps = 5
	AsyncOps_REMOVE         AsyncOps = 6
)

var AsyncOpsMap = map[string]AsyncOps{
	"LIST":           0,
	"LIST_RECURSIVE": 1,
	"READ":           2,
	"WRITE":          3,
	"COPY":           4,
	"MOVE":           5,
	"REMOVE":         6,
}

var AsyncOpsRevMap = map[AsyncOps]string{
	0: "LIST",
	1: "LIST_RECURSIVE",
	2: "READ",
	3: "WRITE",
	4: "COPY",
	5: "MOVE",
	6: "REMOVE",
}

func (e AsyncOps) String() string {
	if v, ok := AsyncOpsRevMap[e]; ok {
		return v
	}
	return ""
}

type ListRemoveArgs struct {
	OpID OpID `codec:"opID" json:"opID"`
	Path Path `codec:"path" json:"path"`
}

type ReadWriteArgs struct {
	OpID   OpID `codec:"opID" json:"opID"`
	Path   Path `codec:"path" json:"path"`
	Offset int  `codec:"offset" json:"offset"`
}

type CopyMoveArgs struct {
	OpID OpID `codec:"opID" json:"opID"`
	Src  Path `codec:"src" json:"src"`
	Dest Path `codec:"dest" json:"dest"`
}

type OpDescription struct {
	AsyncOp__       AsyncOps        `codec:"asyncOp" json:"asyncOp"`
	List__          *ListRemoveArgs `codec:"list,omitempty" json:"list,omitempty"`
	ListRecursive__ *ListRemoveArgs `codec:"listRecursive,omitempty" json:"listRecursive,omitempty"`
	Read__          *ReadWriteArgs  `codec:"read,omitempty" json:"read,omitempty"`
	Write__         *ReadWriteArgs  `codec:"write,omitempty" json:"write,omitempty"`
	Copy__          *CopyMoveArgs   `codec:"copy,omitempty" json:"copy,omitempty"`
	Move__          *CopyMoveArgs   `codec:"move,omitempty" json:"move,omitempty"`
	Remove__        *ListRemoveArgs `codec:"remove,omitempty" json:"remove,omitempty"`
}

func (o *OpDescription) AsyncOp() (ret AsyncOps, err error) {
	switch o.AsyncOp__ {
	case AsyncOps_LIST:
		if o.List__ == nil {
			err = errors.New("unexpected nil value for List__")
			return ret, err
		}
	case AsyncOps_LIST_RECURSIVE:
		if o.ListRecursive__ == nil {
			err = errors.New("unexpected nil value for ListRecursive__")
			return ret, err
		}
	case AsyncOps_READ:
		if o.Read__ == nil {
			err = errors.New("unexpected nil value for Read__")
			return ret, err
		}
	case AsyncOps_WRITE:
		if o.Write__ == nil {
			err = errors.New("unexpected nil value for Write__")
			return ret, err
		}
	case AsyncOps_COPY:
		if o.Copy__ == nil {
			err = errors.New("unexpected nil value for Copy__")
			return ret, err
		}
	case AsyncOps_MOVE:
		if o.Move__ == nil {
			err = errors.New("unexpected nil value for Move__")
			return ret, err
		}
	case AsyncOps_REMOVE:
		if o.Remove__ == nil {
			err = errors.New("unexpected nil value for Remove__")
			return ret, err
		}
	}
	return o.AsyncOp__, nil
}

func (o OpDescription) List() ListRemoveArgs {
	if o.AsyncOp__ != AsyncOps_LIST {
		panic("wrong case accessed")
	}
	if o.List__ == nil {
		return ListRemoveArgs{}
	}
	return *o.List__
}

func (o OpDescription) ListRecursive() ListRemoveArgs {
	if o.AsyncOp__ != AsyncOps_LIST_RECURSIVE {
		panic("wrong case accessed")
	}
	if o.ListRecursive__ == nil {
		return ListRemoveArgs{}
	}
	return *o.ListRecursive__
}

func (o OpDescription) Read() ReadWriteArgs {
	if o.AsyncOp__ != AsyncOps_READ {
		panic("wrong case accessed")
	}
	if o.Read__ == nil {
		return ReadWriteArgs{}
	}
	return *o.Read__
}

func (o OpDescription) Write() ReadWriteArgs {
	if o.AsyncOp__ != AsyncOps_WRITE {
		panic("wrong case accessed")
	}
	if o.Write__ == nil {
		return ReadWriteArgs{}
	}
	return *o.Write__
}

func (o OpDescription) Copy() CopyMoveArgs {
	if o.AsyncOp__ != AsyncOps_COPY {
		panic("wrong case accessed")
	}
	if o.Copy__ == nil {
		return CopyMoveArgs{}
	}
	return *o.Copy__
}

func (o OpDescription) Move() CopyMoveArgs {
	if o.AsyncOp__ != AsyncOps_MOVE {
		panic("wrong case accessed")
	}
	if o.Move__ == nil {
		return CopyMoveArgs{}
	}
	return *o.Move__
}

func (o OpDescription) Remove() ListRemoveArgs {
	if o.AsyncOp__ != AsyncOps_REMOVE {
		panic("wrong case accessed")
	}
	if o.Remove__ == nil {
		return ListRemoveArgs{}
	}
	return *o.Remove__
}

func NewOpDescriptionWithList(v ListRemoveArgs) OpDescription {
	return OpDescription{
		AsyncOp__: AsyncOps_LIST,
		List__:    &v,
	}
}

func NewOpDescriptionWithListRecursive(v ListRemoveArgs) OpDescription {
	return OpDescription{
		AsyncOp__:       AsyncOps_LIST_RECURSIVE,
		ListRecursive__: &v,
	}
}

func NewOpDescriptionWithRead(v ReadWriteArgs) OpDescription {
	return OpDescription{
		AsyncOp__: AsyncOps_READ,
		Read__:    &v,
	}
}

func NewOpDescriptionWithWrite(v ReadWriteArgs) OpDescription {
	return OpDescription{
		AsyncOp__: AsyncOps_WRITE,
		Write__:   &v,
	}
}

func NewOpDescriptionWithCopy(v CopyMoveArgs) OpDescription {
	return OpDescription{
		AsyncOp__: AsyncOps_COPY,
		Copy__:    &v,
	}
}

func NewOpDescriptionWithMove(v CopyMoveArgs) OpDescription {
	return OpDescription{
		AsyncOp__: AsyncOps_MOVE,
		Move__:    &v,
	}
}

func NewOpDescriptionWithRemove(v ListRemoveArgs) OpDescription {
	return OpDescription{
		AsyncOp__: AsyncOps_REMOVE,
		Remove__:  &v,
	}
}

type SfListArg struct {
	OpID OpID `codec:"opID" json:"opID"`
	Path Path `codec:"path" json:"path"`
}

type SfListRecursiveArg struct {
	OpID OpID `codec:"opID" json:"opID"`
	Path Path `codec:"path" json:"path"`
}

type SfReadListArg struct {
	OpID OpID `codec:"opID" json:"opID"`
}

type SfCopyArg struct {
	OpID OpID `codec:"opID" json:"opID"`
	Src  Path `codec:"src" json:"src"`
	Dest Path `codec:"dest" json:"dest"`
}

type SfCopyRecursiveArg struct {
	OpID OpID `codec:"opID" json:"opID"`
	Src  Path `codec:"src" json:"src"`
	Dest Path `codec:"dest" json:"dest"`
}

type SfMoveArg struct {
	OpID OpID `codec:"opID" json:"opID"`
	Src  Path `codec:"src" json:"src"`
	Dest Path `codec:"dest" json:"dest"`
}

type SfRenameArg struct {
	Src  Path `codec:"src" json:"src"`
	Dest Path `codec:"dest" json:"dest"`
}

type SfOpenArg struct {
	OpID  OpID      `codec:"opID" json:"opID"`
	Dest  Path      `codec:"dest" json:"dest"`
	Flags OpenFlags `codec:"flags" json:"flags"`
}

type SfReadArg struct {
	OpID   OpID `codec:"opID" json:"opID"`
	Offset int  `codec:"offset" json:"offset"`
	Size   int  `codec:"size" json:"size"`
}

type SfWriteArg struct {
	OpID    OpID   `codec:"opID" json:"opID"`
	Offset  int    `codec:"offset" json:"offset"`
	Content []byte `codec:"content" json:"content"`
}

type SfRemoveArg struct {
	OpID OpID `codec:"opID" json:"opID"`
	Path Path `codec:"path" json:"path"`
}

type SfStatArg struct {
	Path Path `codec:"path" json:"path"`
}

type SfMakeOpidArg struct {
}

type SfCloseArg struct {
	OpID OpID `codec:"opID" json:"opID"`
}

type SfCheckArg struct {
	OpID OpID `codec:"opID" json:"opID"`
}

type SfGetOpsArg struct {
}

type SfWaitArg struct {
	OpID OpID `codec:"opID" json:"opID"`
}

type SimpleFSInterface interface {
	// Begin list of items in directory at path
	// Retrieve results with readList()
	// Can be a single file to get flags/status
	SfList(context.Context, SfListArg) error
	// Begin recursive list of items in directory at path
	SfListRecursive(context.Context, SfListRecursiveArg) error
	// Get list of Paths in progress. Can indicate status of pending
	// to get more entries.
	SfReadList(context.Context, OpID) (SfListResult, error)
	// Begin copy of file or directory
	SfCopy(context.Context, SfCopyArg) error
	// Begin recursive copy of directory
	SfCopyRecursive(context.Context, SfCopyRecursiveArg) error
	// Begin move of file or directory, from/to KBFS only
	SfMove(context.Context, SfMoveArg) error
	// Rename file or directory, KBFS side only
	SfRename(context.Context, SfRenameArg) error
	// Create/open a file and leave it open
	// or create a directory
	// or set the executable bit on an existing file.
	// Files must be closed afterwards.
	SfOpen(context.Context, SfOpenArg) error
	// Read (possibly partial) contents of open file,
	// up to the amount specified by size.
	// Repeat until zero bytes are returned or error.
	// If size is zero, read an arbitrary amount.
	SfRead(context.Context, SfReadArg) (FileContent, error)
	// Append content to opened file.
	// May be repeated until OpID is closed.
	SfWrite(context.Context, SfWriteArg) error
	// Remove file or directory from filesystem
	SfRemove(context.Context, SfRemoveArg) error
	// Get info about file
	SfStat(context.Context, Path) (Dirent, error)
	// Convenience helper for generating new random value
	SfMakeOpid(context.Context) (OpID, error)
	// Close OpID, cancels any pending operation.
	// Must be called after list/copy/remove
	SfClose(context.Context, OpID) error
	// Check progress of pending operation
	SfCheck(context.Context, OpID) (Progress, error)
	// Get all the outstanding operations
	SfGetOps(context.Context) ([]OpDescription, error)
	// Blocking wait for the pending operation to finish
	SfWait(context.Context, OpID) error
}

func SimpleFSProtocol(i SimpleFSInterface) rpc.Protocol {
	return rpc.Protocol{
		Name: "keybase.1.SimpleFS",
		Methods: map[string]rpc.ServeHandlerDescription{
			"sfList": {
				MakeArg: func() interface{} {
					ret := make([]SfListArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfListArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfListArg)(nil), args)
						return
					}
					err = i.SfList(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfListRecursive": {
				MakeArg: func() interface{} {
					ret := make([]SfListRecursiveArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfListRecursiveArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfListRecursiveArg)(nil), args)
						return
					}
					err = i.SfListRecursive(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfReadList": {
				MakeArg: func() interface{} {
					ret := make([]SfReadListArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfReadListArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfReadListArg)(nil), args)
						return
					}
					ret, err = i.SfReadList(ctx, (*typedArgs)[0].OpID)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfCopy": {
				MakeArg: func() interface{} {
					ret := make([]SfCopyArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfCopyArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfCopyArg)(nil), args)
						return
					}
					err = i.SfCopy(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfCopyRecursive": {
				MakeArg: func() interface{} {
					ret := make([]SfCopyRecursiveArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfCopyRecursiveArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfCopyRecursiveArg)(nil), args)
						return
					}
					err = i.SfCopyRecursive(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfMove": {
				MakeArg: func() interface{} {
					ret := make([]SfMoveArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfMoveArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfMoveArg)(nil), args)
						return
					}
					err = i.SfMove(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfRename": {
				MakeArg: func() interface{} {
					ret := make([]SfRenameArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfRenameArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfRenameArg)(nil), args)
						return
					}
					err = i.SfRename(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfOpen": {
				MakeArg: func() interface{} {
					ret := make([]SfOpenArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfOpenArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfOpenArg)(nil), args)
						return
					}
					err = i.SfOpen(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfRead": {
				MakeArg: func() interface{} {
					ret := make([]SfReadArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfReadArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfReadArg)(nil), args)
						return
					}
					ret, err = i.SfRead(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfWrite": {
				MakeArg: func() interface{} {
					ret := make([]SfWriteArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfWriteArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfWriteArg)(nil), args)
						return
					}
					err = i.SfWrite(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfRemove": {
				MakeArg: func() interface{} {
					ret := make([]SfRemoveArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfRemoveArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfRemoveArg)(nil), args)
						return
					}
					err = i.SfRemove(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfStat": {
				MakeArg: func() interface{} {
					ret := make([]SfStatArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfStatArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfStatArg)(nil), args)
						return
					}
					ret, err = i.SfStat(ctx, (*typedArgs)[0].Path)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfMakeOpid": {
				MakeArg: func() interface{} {
					ret := make([]SfMakeOpidArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					ret, err = i.SfMakeOpid(ctx)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfClose": {
				MakeArg: func() interface{} {
					ret := make([]SfCloseArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfCloseArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfCloseArg)(nil), args)
						return
					}
					err = i.SfClose(ctx, (*typedArgs)[0].OpID)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfCheck": {
				MakeArg: func() interface{} {
					ret := make([]SfCheckArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfCheckArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfCheckArg)(nil), args)
						return
					}
					ret, err = i.SfCheck(ctx, (*typedArgs)[0].OpID)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfGetOps": {
				MakeArg: func() interface{} {
					ret := make([]SfGetOpsArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					ret, err = i.SfGetOps(ctx)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"sfWait": {
				MakeArg: func() interface{} {
					ret := make([]SfWaitArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]SfWaitArg)
					if !ok {
						err = rpc.NewTypeError((*[]SfWaitArg)(nil), args)
						return
					}
					err = i.SfWait(ctx, (*typedArgs)[0].OpID)
					return
				},
				MethodType: rpc.MethodCall,
			},
		},
	}
}

type SimpleFSClient struct {
	Cli rpc.GenericClient
}

// Begin list of items in directory at path
// Retrieve results with readList()
// Can be a single file to get flags/status
func (c SimpleFSClient) SfList(ctx context.Context, __arg SfListArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfList", []interface{}{__arg}, nil)
	return
}

// Begin recursive list of items in directory at path
func (c SimpleFSClient) SfListRecursive(ctx context.Context, __arg SfListRecursiveArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfListRecursive", []interface{}{__arg}, nil)
	return
}

// Get list of Paths in progress. Can indicate status of pending
// to get more entries.
func (c SimpleFSClient) SfReadList(ctx context.Context, opID OpID) (res SfListResult, err error) {
	__arg := SfReadListArg{OpID: opID}
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfReadList", []interface{}{__arg}, &res)
	return
}

// Begin copy of file or directory
func (c SimpleFSClient) SfCopy(ctx context.Context, __arg SfCopyArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfCopy", []interface{}{__arg}, nil)
	return
}

// Begin recursive copy of directory
func (c SimpleFSClient) SfCopyRecursive(ctx context.Context, __arg SfCopyRecursiveArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfCopyRecursive", []interface{}{__arg}, nil)
	return
}

// Begin move of file or directory, from/to KBFS only
func (c SimpleFSClient) SfMove(ctx context.Context, __arg SfMoveArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfMove", []interface{}{__arg}, nil)
	return
}

// Rename file or directory, KBFS side only
func (c SimpleFSClient) SfRename(ctx context.Context, __arg SfRenameArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfRename", []interface{}{__arg}, nil)
	return
}

// Create/open a file and leave it open
// or create a directory
// or set the executable bit on an existing file.
// Files must be closed afterwards.
func (c SimpleFSClient) SfOpen(ctx context.Context, __arg SfOpenArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfOpen", []interface{}{__arg}, nil)
	return
}

// Read (possibly partial) contents of open file,
// up to the amount specified by size.
// Repeat until zero bytes are returned or error.
// If size is zero, read an arbitrary amount.
func (c SimpleFSClient) SfRead(ctx context.Context, __arg SfReadArg) (res FileContent, err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfRead", []interface{}{__arg}, &res)
	return
}

// Append content to opened file.
// May be repeated until OpID is closed.
func (c SimpleFSClient) SfWrite(ctx context.Context, __arg SfWriteArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfWrite", []interface{}{__arg}, nil)
	return
}

// Remove file or directory from filesystem
func (c SimpleFSClient) SfRemove(ctx context.Context, __arg SfRemoveArg) (err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfRemove", []interface{}{__arg}, nil)
	return
}

// Get info about file
func (c SimpleFSClient) SfStat(ctx context.Context, path Path) (res Dirent, err error) {
	__arg := SfStatArg{Path: path}
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfStat", []interface{}{__arg}, &res)
	return
}

// Convenience helper for generating new random value
func (c SimpleFSClient) SfMakeOpid(ctx context.Context) (res OpID, err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfMakeOpid", []interface{}{SfMakeOpidArg{}}, &res)
	return
}

// Close OpID, cancels any pending operation.
// Must be called after list/copy/remove
func (c SimpleFSClient) SfClose(ctx context.Context, opID OpID) (err error) {
	__arg := SfCloseArg{OpID: opID}
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfClose", []interface{}{__arg}, nil)
	return
}

// Check progress of pending operation
func (c SimpleFSClient) SfCheck(ctx context.Context, opID OpID) (res Progress, err error) {
	__arg := SfCheckArg{OpID: opID}
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfCheck", []interface{}{__arg}, &res)
	return
}

// Get all the outstanding operations
func (c SimpleFSClient) SfGetOps(ctx context.Context) (res []OpDescription, err error) {
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfGetOps", []interface{}{SfGetOpsArg{}}, &res)
	return
}

// Blocking wait for the pending operation to finish
func (c SimpleFSClient) SfWait(ctx context.Context, opID OpID) (err error) {
	__arg := SfWaitArg{OpID: opID}
	err = c.Cli.Call(ctx, "keybase.1.SimpleFS.sfWait", []interface{}{__arg}, nil)
	return
}

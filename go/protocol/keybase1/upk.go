// Auto-generated by avdl-compiler v1.3.16 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/keybase1/upk.avdl

package keybase1

import (
	"errors"
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
)

type KeyType int

const (
	KeyType_NONE KeyType = 0
	KeyType_NACL KeyType = 1
	KeyType_PGP  KeyType = 2
)

func (o KeyType) DeepCopy() KeyType { return o }

var KeyTypeMap = map[string]KeyType{
	"NONE": 0,
	"NACL": 1,
	"PGP":  2,
}

var KeyTypeRevMap = map[KeyType]string{
	0: "NONE",
	1: "NACL",
	2: "PGP",
}

func (e KeyType) String() string {
	if v, ok := KeyTypeRevMap[e]; ok {
		return v
	}
	return ""
}

type MerkleRootV2 struct {
	Seqno    Seqno  `codec:"seqno" json:"seqno"`
	HashMeta []byte `codec:"hashMeta" json:"hashMeta"`
}

func (o MerkleRootV2) DeepCopy() MerkleRootV2 {
	return MerkleRootV2{
		Seqno:    o.Seqno.DeepCopy(),
		HashMeta: append([]byte(nil), o.HashMeta...),
	}
}

type SignatureTime struct {
	MerkleRootAtSig MerkleRootV2  `codec:"merkleRootAtSig" json:"merkleRootAtSig"`
	FirstAppearedIn *MerkleRootV2 `codec:"firstAppearedIn,omitempty" json:"firstAppearedIn,omitempty"`
	Time            Time          `codec:"time" json:"time"`
}

func (o SignatureTime) DeepCopy() SignatureTime {
	return SignatureTime{
		MerkleRootAtSig: o.MerkleRootAtSig.DeepCopy(),
		FirstAppearedIn: (func(x *MerkleRootV2) *MerkleRootV2 {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.FirstAppearedIn),
		Time: o.Time.DeepCopy(),
	}
}

type PublicKeyV2Base struct {
	Kid          KID            `codec:"kid" json:"kid"`
	IsSibkey     bool           `codec:"isSibkey" json:"isSibkey"`
	IsEldest     bool           `codec:"isEldest" json:"isEldest"`
	CTime        Time           `codec:"cTime" json:"cTime"`
	ETime        Time           `codec:"eTime" json:"eTime"`
	Provisioning SignatureTime  `codec:"provisioning" json:"provisioning"`
	Revocation   *SignatureTime `codec:"revocation,omitempty" json:"revocation,omitempty"`
}

func (o PublicKeyV2Base) DeepCopy() PublicKeyV2Base {
	return PublicKeyV2Base{
		Kid:          o.Kid.DeepCopy(),
		IsSibkey:     o.IsSibkey,
		IsEldest:     o.IsEldest,
		CTime:        o.CTime.DeepCopy(),
		ETime:        o.ETime.DeepCopy(),
		Provisioning: o.Provisioning.DeepCopy(),
		Revocation: (func(x *SignatureTime) *SignatureTime {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Revocation),
	}
}

type PublicKeyV2NaCl struct {
	Base              PublicKeyV2Base `codec:"base" json:"base"`
	Parent            *KID            `codec:"parent,omitempty" json:"parent,omitempty"`
	DeviceID          DeviceID        `codec:"deviceID" json:"deviceID"`
	DeviceDescription string          `codec:"deviceDescription" json:"deviceDescription"`
	DeviceType        string          `codec:"deviceType" json:"deviceType"`
}

func (o PublicKeyV2NaCl) DeepCopy() PublicKeyV2NaCl {
	return PublicKeyV2NaCl{
		Base: o.Base.DeepCopy(),
		Parent: (func(x *KID) *KID {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Parent),
		DeviceID:          o.DeviceID.DeepCopy(),
		DeviceDescription: o.DeviceDescription,
		DeviceType:        o.DeviceType,
	}
}

type PGPFingerprint [20]byte

func (o PGPFingerprint) DeepCopy() PGPFingerprint {
	var ret PGPFingerprint
	copy(ret[:], o[:])
	return ret
}

type PublicKeyV2PGPSummary struct {
	Base        PublicKeyV2Base `codec:"base" json:"base"`
	Fingerprint PGPFingerprint  `codec:"fingerprint" json:"fingerprint"`
	Identities  []PGPIdentity   `codec:"identities" json:"identities"`
}

func (o PublicKeyV2PGPSummary) DeepCopy() PublicKeyV2PGPSummary {
	return PublicKeyV2PGPSummary{
		Base:        o.Base.DeepCopy(),
		Fingerprint: o.Fingerprint.DeepCopy(),
		Identities: (func(x []PGPIdentity) []PGPIdentity {
			var ret []PGPIdentity
			for _, v := range x {
				vCopy := v.DeepCopy()
				ret = append(ret, vCopy)
			}
			return ret
		})(o.Identities),
	}
}

type PublicKeyV2 struct {
	KeyType__ KeyType                `codec:"keyType" json:"keyType"`
	Nacl__    *PublicKeyV2NaCl       `codec:"nacl,omitempty" json:"nacl,omitempty"`
	PGP__     *PublicKeyV2PGPSummary `codec:"pgp,omitempty" json:"pgp,omitempty"`
}

func (o *PublicKeyV2) KeyType() (ret KeyType, err error) {
	switch o.KeyType__ {
	case KeyType_NACL:
		if o.Nacl__ == nil {
			err = errors.New("unexpected nil value for Nacl__")
			return ret, err
		}
	case KeyType_PGP:
		if o.PGP__ == nil {
			err = errors.New("unexpected nil value for PGP__")
			return ret, err
		}
	}
	return o.KeyType__, nil
}

func (o PublicKeyV2) Nacl() (res PublicKeyV2NaCl) {
	if o.KeyType__ != KeyType_NACL {
		panic("wrong case accessed")
	}
	if o.Nacl__ == nil {
		return
	}
	return *o.Nacl__
}

func (o PublicKeyV2) Pgp() (res PublicKeyV2PGPSummary) {
	if o.KeyType__ != KeyType_PGP {
		panic("wrong case accessed")
	}
	if o.PGP__ == nil {
		return
	}
	return *o.PGP__
}

func NewPublicKeyV2WithNacl(v PublicKeyV2NaCl) PublicKeyV2 {
	return PublicKeyV2{
		KeyType__: KeyType_NACL,
		Nacl__:    &v,
	}
}

func NewPublicKeyV2WithPgp(v PublicKeyV2PGPSummary) PublicKeyV2 {
	return PublicKeyV2{
		KeyType__: KeyType_PGP,
		PGP__:     &v,
	}
}

func NewPublicKeyV2Default(keyType KeyType) PublicKeyV2 {
	return PublicKeyV2{
		KeyType__: keyType,
	}
}

func (o PublicKeyV2) DeepCopy() PublicKeyV2 {
	return PublicKeyV2{
		KeyType__: o.KeyType__.DeepCopy(),
		Nacl__: (func(x *PublicKeyV2NaCl) *PublicKeyV2NaCl {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Nacl__),
		PGP__: (func(x *PublicKeyV2PGPSummary) *PublicKeyV2PGPSummary {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.PGP__),
	}
}

type UserPlusKeysV2 struct {
	Uid          UID                     `codec:"uid" json:"uid"`
	Username     string                  `codec:"username" json:"username"`
	EldestSeqno  Seqno                   `codec:"eldestSeqno" json:"eldestSeqno"`
	Uvv          UserVersionVector       `codec:"uvv" json:"uvv"`
	PerUserKeys  []PerUserKey            `codec:"perUserKeys" json:"perUserKeys"`
	DeviceKeys   []PublicKeyV2NaCl       `codec:"deviceKeys" json:"deviceKeys"`
	PGPKeys      []PublicKeyV2PGPSummary `codec:"pgpKeys" json:"pgpKeys"`
	RemoteTracks []RemoteTrack           `codec:"remoteTracks" json:"remoteTracks"`
}

func (o UserPlusKeysV2) DeepCopy() UserPlusKeysV2 {
	return UserPlusKeysV2{
		Uid:         o.Uid.DeepCopy(),
		Username:    o.Username,
		EldestSeqno: o.EldestSeqno.DeepCopy(),
		Uvv:         o.Uvv.DeepCopy(),
		PerUserKeys: (func(x []PerUserKey) []PerUserKey {
			var ret []PerUserKey
			for _, v := range x {
				vCopy := v.DeepCopy()
				ret = append(ret, vCopy)
			}
			return ret
		})(o.PerUserKeys),
		DeviceKeys: (func(x []PublicKeyV2NaCl) []PublicKeyV2NaCl {
			var ret []PublicKeyV2NaCl
			for _, v := range x {
				vCopy := v.DeepCopy()
				ret = append(ret, vCopy)
			}
			return ret
		})(o.DeviceKeys),
		PGPKeys: (func(x []PublicKeyV2PGPSummary) []PublicKeyV2PGPSummary {
			var ret []PublicKeyV2PGPSummary
			for _, v := range x {
				vCopy := v.DeepCopy()
				ret = append(ret, vCopy)
			}
			return ret
		})(o.PGPKeys),
		RemoteTracks: (func(x []RemoteTrack) []RemoteTrack {
			var ret []RemoteTrack
			for _, v := range x {
				vCopy := v.DeepCopy()
				ret = append(ret, vCopy)
			}
			return ret
		})(o.RemoteTracks),
	}
}

type UserPlusKeysV2AllIncarnations struct {
	Incarnations []UserPlusKeysV2 `codec:"incarnations" json:"incarnations"`
}

func (o UserPlusKeysV2AllIncarnations) DeepCopy() UserPlusKeysV2AllIncarnations {
	return UserPlusKeysV2AllIncarnations{
		Incarnations: (func(x []UserPlusKeysV2) []UserPlusKeysV2 {
			var ret []UserPlusKeysV2
			for _, v := range x {
				vCopy := v.DeepCopy()
				ret = append(ret, vCopy)
			}
			return ret
		})(o.Incarnations),
	}
}

type UPKInterface interface {
}

func UPKProtocol(i UPKInterface) rpc.Protocol {
	return rpc.Protocol{
		Name:    "keybase.1.UPK",
		Methods: map[string]rpc.ServeHandlerDescription{},
	}
}

type UPKClient struct {
	Cli rpc.GenericClient
}

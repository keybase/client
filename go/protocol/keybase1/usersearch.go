// Auto-generated by avdl-compiler v1.3.29 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/keybase1/usersearch.avdl

package keybase1

import (
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
	context "golang.org/x/net/context"
)

type RemoteResult struct {
	Username string `codec:"username" json:"username"`
	Service  string `codec:"service" json:"service"`
}

func (o RemoteResult) DeepCopy() RemoteResult {
	return RemoteResult{
		Username: o.Username,
		Service:  o.Service,
	}
}

type KeybaseUserResult struct {
	Username string `codec:"username" json:"username"`
	Uid      UID    `codec:"uid" json:"uid"`
	FullName string `codec:"fullName" json:"fullName"`
}

func (o KeybaseUserResult) DeepCopy() KeybaseUserResult {
	return KeybaseUserResult{
		Username: o.Username,
		Uid:      o.Uid.DeepCopy(),
		FullName: o.FullName,
	}
}

type UserSearchResult struct {
	Score       int                `codec:"score" json:"score"`
	KeybaseUser *KeybaseUserResult `codec:"keybaseUser,omitempty" json:"keybaseUser,omitempty"`
	RemoteUser  *RemoteResult      `codec:"remoteUser,omitempty" json:"remoteUser,omitempty"`
	Contact     *ProcessedContact  `codec:"contact,omitempty" json:"contact,omitempty"`
}

func (o UserSearchResult) DeepCopy() UserSearchResult {
	return UserSearchResult{
		Score: o.Score,
		KeybaseUser: (func(x *KeybaseUserResult) *KeybaseUserResult {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.KeybaseUser),
		RemoteUser: (func(x *RemoteResult) *RemoteResult {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.RemoteUser),
		Contact: (func(x *ProcessedContact) *ProcessedContact {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Contact),
	}
}

type SearchArg struct {
	Query      string `codec:"query" json:"query"`
	Service    string `codec:"service" json:"service"`
	MaxResults int    `codec:"maxResults" json:"maxResults"`
}

type UserSearchInterface interface {
	Search(context.Context, SearchArg) ([]UserSearchResult, error)
}

func UserSearchProtocol(i UserSearchInterface) rpc.Protocol {
	return rpc.Protocol{
		Name: "keybase.1.userSearch",
		Methods: map[string]rpc.ServeHandlerDescription{
			"search": {
				MakeArg: func() interface{} {
					var ret [1]SearchArg
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[1]SearchArg)
					if !ok {
						err = rpc.NewTypeError((*[1]SearchArg)(nil), args)
						return
					}
					ret, err = i.Search(ctx, typedArgs[0])
					return
				},
			},
		},
	}
}

type UserSearchClient struct {
	Cli rpc.GenericClient
}

func (c UserSearchClient) Search(ctx context.Context, __arg SearchArg) (res []UserSearchResult, err error) {
	err = c.Cli.Call(ctx, "keybase.1.userSearch.search", []interface{}{__arg}, &res)
	return
}

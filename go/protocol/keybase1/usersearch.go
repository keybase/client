// Auto-generated by avdl-compiler v1.4.0 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/keybase1/usersearch.avdl

package keybase1

import (
	"errors"
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
	context "golang.org/x/net/context"
)

type APIUserKeybaseResult struct {
	Username   string  `codec:"username" json:"username"`
	Uid        UID     `codec:"uid" json:"uid"`
	PictureUrl *string `codec:"pictureUrl,omitempty" json:"picture_url,omitempty"`
	FullName   *string `codec:"fullName,omitempty" json:"full_name,omitempty"`
	RawScore   float64 `codec:"rawScore" json:"raw_score"`
	Stellar    *string `codec:"stellar,omitempty" json:"stellar,omitempty"`
	IsFollowee bool    `codec:"isFollowee" json:"is_followee"`
}

func (o APIUserKeybaseResult) DeepCopy() APIUserKeybaseResult {
	return APIUserKeybaseResult{
		Username: o.Username,
		Uid:      o.Uid.DeepCopy(),
		PictureUrl: (func(x *string) *string {
			if x == nil {
				return nil
			}
			tmp := (*x)
			return &tmp
		})(o.PictureUrl),
		FullName: (func(x *string) *string {
			if x == nil {
				return nil
			}
			tmp := (*x)
			return &tmp
		})(o.FullName),
		RawScore: o.RawScore,
		Stellar: (func(x *string) *string {
			if x == nil {
				return nil
			}
			tmp := (*x)
			return &tmp
		})(o.Stellar),
		IsFollowee: o.IsFollowee,
	}
}

type APIUserServiceResult struct {
	ServiceName string `codec:"serviceName" json:"service_name"`
	Username    string `codec:"username" json:"username"`
	PictureUrl  string `codec:"pictureUrl" json:"picture_url"`
	Bio         string `codec:"bio" json:"bio"`
	Location    string `codec:"location" json:"location"`
	FullName    string `codec:"fullName" json:"full_name"`
	Confirmed   *bool  `codec:"confirmed,omitempty" json:"confirmed,omitempty"`
}

func (o APIUserServiceResult) DeepCopy() APIUserServiceResult {
	return APIUserServiceResult{
		ServiceName: o.ServiceName,
		Username:    o.Username,
		PictureUrl:  o.PictureUrl,
		Bio:         o.Bio,
		Location:    o.Location,
		FullName:    o.FullName,
		Confirmed: (func(x *bool) *bool {
			if x == nil {
				return nil
			}
			tmp := (*x)
			return &tmp
		})(o.Confirmed),
	}
}

type APIUserServiceSummary struct {
	ServiceName string `codec:"serviceName" json:"service_name"`
	Username    string `codec:"username" json:"username"`
}

func (o APIUserServiceSummary) DeepCopy() APIUserServiceSummary {
	return APIUserServiceSummary{
		ServiceName: o.ServiceName,
		Username:    o.Username,
	}
}

type ImpTofuSearchResult struct {
	Assertion       string `codec:"assertion" json:"assertion"`
	Label           string `codec:"label" json:"label"`
	PrettyName      string `codec:"prettyName" json:"prettyName"`
	KeybaseUsername string `codec:"keybaseUsername" json:"keybaseUsername"`
}

func (o ImpTofuSearchResult) DeepCopy() ImpTofuSearchResult {
	return ImpTofuSearchResult{
		Assertion:       o.Assertion,
		Label:           o.Label,
		PrettyName:      o.PrettyName,
		KeybaseUsername: o.KeybaseUsername,
	}
}

type APIUserSearchResult struct {
	Score           float64                          `codec:"score" json:"score"`
	Keybase         *APIUserKeybaseResult            `codec:"keybase,omitempty" json:"keybase,omitempty"`
	Service         *APIUserServiceResult            `codec:"service,omitempty" json:"service,omitempty"`
	Contact         *ProcessedContact                `codec:"contact,omitempty" json:"contact,omitempty"`
	Imptofu         *ImpTofuSearchResult             `codec:"imptofu,omitempty" json:"imptofu,omitempty"`
	ServicesSummary map[string]APIUserServiceSummary `codec:"servicesSummary" json:"services_summary"`
	RawScore        float64                          `codec:"rawScore" json:"rawScore"`
}

func (o APIUserSearchResult) DeepCopy() APIUserSearchResult {
	return APIUserSearchResult{
		Score: o.Score,
		Keybase: (func(x *APIUserKeybaseResult) *APIUserKeybaseResult {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Keybase),
		Service: (func(x *APIUserServiceResult) *APIUserServiceResult {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Service),
		Contact: (func(x *ProcessedContact) *ProcessedContact {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Contact),
		Imptofu: (func(x *ImpTofuSearchResult) *ImpTofuSearchResult {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Imptofu),
		ServicesSummary: (func(x map[string]APIUserServiceSummary) map[string]APIUserServiceSummary {
			if x == nil {
				return nil
			}
			ret := make(map[string]APIUserServiceSummary, len(x))
			for k, v := range x {
				kCopy := k
				vCopy := v.DeepCopy()
				ret[kCopy] = vCopy
			}
			return ret
		})(o.ServicesSummary),
		RawScore: o.RawScore,
	}
}

type NonUserDetails struct {
	IsNonUser      bool                  `codec:"isNonUser" json:"isNonUser"`
	AssertionValue string                `codec:"assertionValue" json:"assertionValue"`
	AssertionKey   string                `codec:"assertionKey" json:"assertionKey"`
	Description    string                `codec:"description" json:"description"`
	Contact        *ProcessedContact     `codec:"contact,omitempty" json:"contact,omitempty"`
	Service        *APIUserServiceResult `codec:"service,omitempty" json:"service,omitempty"`
	SiteIcon       []SizedImage          `codec:"siteIcon" json:"siteIcon"`
	SiteIconFull   []SizedImage          `codec:"siteIconFull" json:"siteIconFull"`
}

func (o NonUserDetails) DeepCopy() NonUserDetails {
	return NonUserDetails{
		IsNonUser:      o.IsNonUser,
		AssertionValue: o.AssertionValue,
		AssertionKey:   o.AssertionKey,
		Description:    o.Description,
		Contact: (func(x *ProcessedContact) *ProcessedContact {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Contact),
		Service: (func(x *APIUserServiceResult) *APIUserServiceResult {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Service),
		SiteIcon: (func(x []SizedImage) []SizedImage {
			if x == nil {
				return nil
			}
			ret := make([]SizedImage, len(x))
			for i, v := range x {
				vCopy := v.DeepCopy()
				ret[i] = vCopy
			}
			return ret
		})(o.SiteIcon),
		SiteIconFull: (func(x []SizedImage) []SizedImage {
			if x == nil {
				return nil
			}
			ret := make([]SizedImage, len(x))
			for i, v := range x {
				vCopy := v.DeepCopy()
				ret[i] = vCopy
			}
			return ret
		})(o.SiteIconFull),
	}
}

type ImpTofuSearchType int

const (
	ImpTofuSearchType_PHONE ImpTofuSearchType = 0
	ImpTofuSearchType_EMAIL ImpTofuSearchType = 1
)

func (o ImpTofuSearchType) DeepCopy() ImpTofuSearchType { return o }

var ImpTofuSearchTypeMap = map[string]ImpTofuSearchType{
	"PHONE": 0,
	"EMAIL": 1,
}

var ImpTofuSearchTypeRevMap = map[ImpTofuSearchType]string{
	0: "PHONE",
	1: "EMAIL",
}

func (e ImpTofuSearchType) String() string {
	if v, ok := ImpTofuSearchTypeRevMap[e]; ok {
		return v
	}
	return ""
}

type ImpTofuQuery struct {
	T__     ImpTofuSearchType `codec:"t" json:"t"`
	Phone__ *PhoneNumber      `codec:"phone,omitempty" json:"phone,omitempty"`
	Email__ *EmailAddress     `codec:"email,omitempty" json:"email,omitempty"`
}

func (o *ImpTofuQuery) T() (ret ImpTofuSearchType, err error) {
	switch o.T__ {
	case ImpTofuSearchType_PHONE:
		if o.Phone__ == nil {
			err = errors.New("unexpected nil value for Phone__")
			return ret, err
		}
	case ImpTofuSearchType_EMAIL:
		if o.Email__ == nil {
			err = errors.New("unexpected nil value for Email__")
			return ret, err
		}
	}
	return o.T__, nil
}

func (o ImpTofuQuery) Phone() (res PhoneNumber) {
	if o.T__ != ImpTofuSearchType_PHONE {
		panic("wrong case accessed")
	}
	if o.Phone__ == nil {
		return
	}
	return *o.Phone__
}

func (o ImpTofuQuery) Email() (res EmailAddress) {
	if o.T__ != ImpTofuSearchType_EMAIL {
		panic("wrong case accessed")
	}
	if o.Email__ == nil {
		return
	}
	return *o.Email__
}

func NewImpTofuQueryWithPhone(v PhoneNumber) ImpTofuQuery {
	return ImpTofuQuery{
		T__:     ImpTofuSearchType_PHONE,
		Phone__: &v,
	}
}

func NewImpTofuQueryWithEmail(v EmailAddress) ImpTofuQuery {
	return ImpTofuQuery{
		T__:     ImpTofuSearchType_EMAIL,
		Email__: &v,
	}
}

func (o ImpTofuQuery) DeepCopy() ImpTofuQuery {
	return ImpTofuQuery{
		T__: o.T__.DeepCopy(),
		Phone__: (func(x *PhoneNumber) *PhoneNumber {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Phone__),
		Email__: (func(x *EmailAddress) *EmailAddress {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.Email__),
	}
}

type UserSearchSourceType int

const (
	UserSearchSourceType_KEYBASE  UserSearchSourceType = 0
	UserSearchSourceType_SOCIAL   UserSearchSourceType = 1
	UserSearchSourceType_CONTACTS UserSearchSourceType = 2
	UserSearchSourceType_TOFU     UserSearchSourceType = 3
)

func (o UserSearchSourceType) DeepCopy() UserSearchSourceType { return o }

var UserSearchSourceTypeMap = map[string]UserSearchSourceType{
	"KEYBASE":  0,
	"SOCIAL":   1,
	"CONTACTS": 2,
	"TOFU":     3,
}

var UserSearchSourceTypeRevMap = map[UserSearchSourceType]string{
	0: "KEYBASE",
	1: "SOCIAL",
	2: "CONTACTS",
	3: "TOFU",
}

func (e UserSearchSourceType) String() string {
	if v, ok := UserSearchSourceTypeRevMap[e]; ok {
		return v
	}
	return ""
}

type UserSearchSource struct {
	T__      UserSearchSourceType `codec:"t" json:"t"`
	Social__ *string              `codec:"social,omitempty" json:"social,omitempty"`
}

func (o *UserSearchSource) T() (ret UserSearchSourceType, err error) {
	switch o.T__ {
	case UserSearchSourceType_SOCIAL:
		if o.Social__ == nil {
			err = errors.New("unexpected nil value for Social__")
			return ret, err
		}
	}
	return o.T__, nil
}

func (o UserSearchSource) Social() (res string) {
	if o.T__ != UserSearchSourceType_SOCIAL {
		panic("wrong case accessed")
	}
	if o.Social__ == nil {
		return
	}
	return *o.Social__
}

func NewUserSearchSourceWithSocial(v string) UserSearchSource {
	return UserSearchSource{
		T__:      UserSearchSourceType_SOCIAL,
		Social__: &v,
	}
}

func NewUserSearchSourceDefault(t UserSearchSourceType) UserSearchSource {
	return UserSearchSource{
		T__: t,
	}
}

func (o UserSearchSource) DeepCopy() UserSearchSource {
	return UserSearchSource{
		T__: o.T__.DeepCopy(),
		Social__: (func(x *string) *string {
			if x == nil {
				return nil
			}
			tmp := (*x)
			return &tmp
		})(o.Social__),
	}
}

type UserSearchResult struct {
	Id              string            `codec:"id" json:"id"`
	Assertion       string            `codec:"assertion" json:"assertion"`
	Username        string            `codec:"username" json:"username"`
	ServiceName     string            `codec:"serviceName" json:"serviceName"`
	PrettyName      string            `codec:"prettyName" json:"prettyName"`
	Label           string            `codec:"label" json:"label"`
	KeybaseUsername string            `codec:"keybaseUsername" json:"keybaseUsername"`
	Uid             UID               `codec:"uid" json:"uid"`
	Source          UserSearchSource  `codec:"source" json:"source"`
	ServiceMap      map[string]string `codec:"serviceMap" json:"serviceMap"`
	Score           float64           `codec:"score" json:"score"`
	RawScore        float64           `codec:"rawScore" json:"rawScore"`
}

func (o UserSearchResult) DeepCopy() UserSearchResult {
	return UserSearchResult{
		Id:              o.Id,
		Assertion:       o.Assertion,
		Username:        o.Username,
		ServiceName:     o.ServiceName,
		PrettyName:      o.PrettyName,
		Label:           o.Label,
		KeybaseUsername: o.KeybaseUsername,
		Uid:             o.Uid.DeepCopy(),
		Source:          o.Source.DeepCopy(),
		ServiceMap: (func(x map[string]string) map[string]string {
			if x == nil {
				return nil
			}
			ret := make(map[string]string, len(x))
			for k, v := range x {
				kCopy := k
				vCopy := v
				ret[kCopy] = vCopy
			}
			return ret
		})(o.ServiceMap),
		Score:    o.Score,
		RawScore: o.RawScore,
	}
}

type GetNonUserDetailsArg struct {
	SessionID int    `codec:"sessionID" json:"sessionID"`
	Assertion string `codec:"assertion" json:"assertion"`
}

type UserSearchArg struct {
	Query                  string        `codec:"query" json:"query"`
	Service                string        `codec:"service" json:"service"`
	MaxResults             int           `codec:"maxResults" json:"maxResults"`
	IncludeServicesSummary bool          `codec:"includeServicesSummary" json:"includeServicesSummary"`
	IncludeContacts        bool          `codec:"includeContacts" json:"includeContacts"`
	ImpTofuQuery           *ImpTofuQuery `codec:"impTofuQuery,omitempty" json:"impTofuQuery,omitempty"`
}

type UserSearchInterface interface {
	GetNonUserDetails(context.Context, GetNonUserDetailsArg) (NonUserDetails, error)
	UserSearch(context.Context, UserSearchArg) ([]UserSearchResult, error)
}

func UserSearchProtocol(i UserSearchInterface) rpc.Protocol {
	return rpc.Protocol{
		Name: "keybase.1.userSearch",
		Methods: map[string]rpc.ServeHandlerDescription{
			"getNonUserDetails": {
				MakeArg: func() interface{} {
					var ret [1]GetNonUserDetailsArg
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[1]GetNonUserDetailsArg)
					if !ok {
						err = rpc.NewTypeError((*[1]GetNonUserDetailsArg)(nil), args)
						return
					}
					ret, err = i.GetNonUserDetails(ctx, typedArgs[0])
					return
				},
			},
			"userSearch": {
				MakeArg: func() interface{} {
					var ret [1]UserSearchArg
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[1]UserSearchArg)
					if !ok {
						err = rpc.NewTypeError((*[1]UserSearchArg)(nil), args)
						return
					}
					ret, err = i.UserSearch(ctx, typedArgs[0])
					return
				},
			},
		},
	}
}

type UserSearchClient struct {
	Cli rpc.GenericClient
}

func (c UserSearchClient) GetNonUserDetails(ctx context.Context, __arg GetNonUserDetailsArg) (res NonUserDetails, err error) {
	err = c.Cli.Call(ctx, "keybase.1.userSearch.getNonUserDetails", []interface{}{__arg}, &res)
	return
}

func (c UserSearchClient) UserSearch(ctx context.Context, __arg UserSearchArg) (res []UserSearchResult, err error) {
	err = c.Cli.Call(ctx, "keybase.1.userSearch.userSearch", []interface{}{__arg}, &res)
	return
}

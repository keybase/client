"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;

var _kleur = _interopRequireDefault(require("kleur"));

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _which = _interopRequireDefault(require("which"));

var _crossSpawn = _interopRequireDefault(require("cross-spawn"));

var _del = _interopRequireDefault(require("del"));

var _json = _interopRequireDefault(require("json5"));

var _os = require("os");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function build({
  root,
  output,
  report,
  options
}) {
  report.info(`Cleaning up previous build at ${_kleur.default.blue(_path.default.relative(root, output))}`);
  await (0, _del.default)([output]);
  report.info(`Generating type definitions with ${_kleur.default.blue('tsc')}`);
  const project = options !== null && options !== void 0 && options.project ? options.project : 'tsconfig.json';

  const tsconfig = _path.default.join(root, project);

  try {
    if (await _fsExtra.default.pathExists(tsconfig)) {
      try {
        const config = _json.default.parse(await _fsExtra.default.readFile(tsconfig, 'utf-8'));

        if (config.compilerOptions) {
          const conflicts = [];

          if (config.compilerOptions.noEmit !== undefined) {
            conflicts.push('compilerOptions.noEmit');
          }

          if (config.compilerOptions.emitDeclarationOnly !== undefined) {
            conflicts.push('compilerOptions.emitDeclarationOnly');
          }

          if (config.compilerOptions.declarationDir) {
            conflicts.push('compilerOptions.declarationDir');
          }

          if (config.compilerOptions.outDir && _path.default.join(root, config.compilerOptions.outDir) !== output) {
            conflicts.push('compilerOptions.outDir');
          }

          if (conflicts.length) {
            report.warn(`Found following options in the config file which can conflict with the CLI options. Please remove them from ${_kleur.default.blue(project)}:${conflicts.reduce((acc, curr) => acc + `\n${_kleur.default.gray('-')} ${_kleur.default.yellow(curr)}`, '')}`);
          }
        }
      } catch (e) {
        report.warn(`Couldn't parse '${project}'. There might be validation errors.`);
      }
    } else {
      throw new Error(`Couldn't find a ${_kleur.default.blue('tsconfig.json')} in the project root.`);
    }

    let tsc = options !== null && options !== void 0 && options.tsc ? _path.default.resolve(root, options.tsc) : _path.default.resolve(root, 'node_modules', '.bin', 'tsc') + ((0, _os.platform)() === 'win32' ? '.cmd' : '');

    if (!(await _fsExtra.default.pathExists(tsc))) {
      try {
        tsc = await (0, _which.default)('tsc');
        report.warn(`Using a global version of ${_kleur.default.blue('tsc')}. Consider adding ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specifying the ${_kleur.default.blue('tsc')} option for the typescript target.`);
      } catch (e) {// Ignore
      }
    }

    if (!(await _fsExtra.default.pathExists(tsc))) {
      throw new Error(`The ${_kleur.default.blue('tsc')} binary doesn't seem to be installed under ${_kleur.default.blue('node_modules')} or present in $PATH. Make sure you have added ${_kleur.default.blue('typescript')} to your ${_kleur.default.blue('devDependencies')} or specify the ${_kleur.default.blue('tsc')} option for typescript.`);
    }

    const tsbuildinfo = _path.default.join(output, project.replace(/\.json$/, '.tsbuildinfo'));

    try {
      await (0, _del.default)([tsbuildinfo]);
    } catch (e) {// Ignore
    }

    const result = _crossSpawn.default.sync(tsc, ['--pretty', '--declaration', '--emitDeclarationOnly', '--project', project, '--outDir', output], {
      stdio: 'inherit'
    });

    if (result.status === 0) {
      await (0, _del.default)([tsbuildinfo]);
      report.success(`Wrote definition files to ${_kleur.default.blue(_path.default.relative(root, output))}`);
    } else {
      throw new Error('Failed to build definition files.');
    }
  } catch (e) {
    if (e.stdout) {
      report.error(`Errors found when building definition files:\n${e.stdout.toString()}`);
    } else {
      report.error(e.message);
    }

    throw new Error('Failed to build definition files.');
  }
}
//# sourceMappingURL=typescript.js.map
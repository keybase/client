// @flow

// This file is auto-generated by client/protocol/Makefile.
import * as gregor1 from './flow-types-gregor'
import * as keybase1 from './flow-types'
import engine from '../../engine'
import {RPCError} from '../../util/errors'
import {putOnChannelMap, createChannelMap, closeChannelMap} from '../../util/saga'
import {Buffer} from 'buffer'
import type {Exact} from './more'
import type {ChannelConfig, ChannelMap} from './saga'
export type int = number
export type int64 = number
export type uint = number
export type uint64 = number
export type long = number
export type double = number
export type bytes = Buffer
export type WaitingHandlerType = (waiting: boolean, method: string, sessionID: number) => void

// $FlowIssue we're calling an internal method on engine that's there just for us
const engineRpcOutgoing = (...args) => engine()._rpcOutgoing(...args)

type requestCommon = {
  waitingHandler?: WaitingHandlerType,
  incomingCallMap?: incomingCallMapType,
}

type requestErrorCallback = {
  callback?: ?(err: ?RPCError) => void
}

type RPCErrorHandler = (err: RPCError) => void

type CommonResponseHandler = {
  error: RPCErrorHandler,
  result: (...rest: Array<void>) => void,
}
function _channelMapRpcHelper(channelConfig: ChannelConfig<*>, partialRpcCall: (incomingCallMap: any, callback: Function) => void): ChannelMap<*> {
  const channelMap = createChannelMap(channelConfig)
  const incomingCallMap = Object.keys(channelMap).reduce((acc, k) => {
    acc[k] = (params, response) => {
      putOnChannelMap(channelMap, k, {params, response})
    }
    return acc
  }, {})
  const callback = (error, params) => {
    channelMap['finished'] && putOnChannelMap(channelMap, 'finished', {error, params})
    closeChannelMap(channelMap)
  }
  partialRpcCall(incomingCallMap, callback)
  return channelMap
}

export const CommonConversationStatus = {
  unfiled: 0,
  favorite: 1,
  ignored: 2,
  blocked: 3,
}

export const CommonInboxResType = {
  versionhit: 0,
  full: 1,
}

export const CommonMessageType = {
  none: 0,
  text: 1,
  attachment: 2,
  edit: 3,
  delete: 4,
  metadata: 5,
  tlfname: 6,
  headline: 7,
}

export const CommonTLFVisibility = {
  any: 0,
  public: 1,
  private: 2,
}

export const CommonTopicType = {
  none: 0,
  chat: 1,
  dev: 2,
}

export const LocalBodyPlaintextVersion = {
  v1: 1,
}

export const LocalHeaderPlaintextVersion = {
  v1: 1,
}

export const LocalMessageUnboxedState = {
  valid: 1,
  error: 2,
  outbox: 3,
}

export const LocalOutboxStateType = {
  sending: 0,
  error: 1,
}

export const NotifyChatChatActivityType = {
  reserved: 0,
  incomingMessage: 1,
  readMessage: 2,
  newConversation: 3,
  setStatus: 4,
  failedMessage: 5,
}

export function localCancelPostRpc (request: Exact<requestCommon & requestErrorCallback & {param: localCancelPostRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.CancelPost'})
}

export function localCancelPostRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & requestErrorCallback & {param: localCancelPostRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localCancelPostRpc({...request, incomingCallMap, callback}))
}

export function localCancelPostRpcPromise (request: $Exact<requestCommon & requestErrorCallback & {param: localCancelPostRpcParam}>): Promise<any> {
  return new Promise((resolve, reject) => { localCancelPostRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localDownloadAttachmentLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localDownloadAttachmentLocalResult) => void} & {param: localDownloadAttachmentLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.DownloadAttachmentLocal'})
}

export function localDownloadAttachmentLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localDownloadAttachmentLocalResult) => void} & {param: localDownloadAttachmentLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localDownloadAttachmentLocalRpc({...request, incomingCallMap, callback}))
}

export function localDownloadAttachmentLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localDownloadAttachmentLocalResult) => void} & {param: localDownloadAttachmentLocalRpcParam}>): Promise<localDownloadAttachmentLocalResult> {
  return new Promise((resolve, reject) => { localDownloadAttachmentLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localDownloadFileAttachmentLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localDownloadFileAttachmentLocalResult) => void} & {param: localDownloadFileAttachmentLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.DownloadFileAttachmentLocal'})
}

export function localDownloadFileAttachmentLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localDownloadFileAttachmentLocalResult) => void} & {param: localDownloadFileAttachmentLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localDownloadFileAttachmentLocalRpc({...request, incomingCallMap, callback}))
}

export function localDownloadFileAttachmentLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localDownloadFileAttachmentLocalResult) => void} & {param: localDownloadFileAttachmentLocalRpcParam}>): Promise<localDownloadFileAttachmentLocalResult> {
  return new Promise((resolve, reject) => { localDownloadFileAttachmentLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetConversationForCLILocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetConversationForCLILocalResult) => void} & {param: localGetConversationForCLILocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.getConversationForCLILocal'})
}

export function localGetConversationForCLILocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetConversationForCLILocalResult) => void} & {param: localGetConversationForCLILocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetConversationForCLILocalRpc({...request, incomingCallMap, callback}))
}

export function localGetConversationForCLILocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetConversationForCLILocalResult) => void} & {param: localGetConversationForCLILocalRpcParam}>): Promise<localGetConversationForCLILocalResult> {
  return new Promise((resolve, reject) => { localGetConversationForCLILocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetInboxAndUnboxLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxAndUnboxLocalResult) => void} & {param: localGetInboxAndUnboxLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.getInboxAndUnboxLocal'})
}

export function localGetInboxAndUnboxLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxAndUnboxLocalResult) => void} & {param: localGetInboxAndUnboxLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetInboxAndUnboxLocalRpc({...request, incomingCallMap, callback}))
}

export function localGetInboxAndUnboxLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxAndUnboxLocalResult) => void} & {param: localGetInboxAndUnboxLocalRpcParam}>): Promise<localGetInboxAndUnboxLocalResult> {
  return new Promise((resolve, reject) => { localGetInboxAndUnboxLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetInboxLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxLocalResult) => void} & {param: localGetInboxLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.getInboxLocal'})
}

export function localGetInboxLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxLocalResult) => void} & {param: localGetInboxLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetInboxLocalRpc({...request, incomingCallMap, callback}))
}

export function localGetInboxLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxLocalResult) => void} & {param: localGetInboxLocalRpcParam}>): Promise<localGetInboxLocalResult> {
  return new Promise((resolve, reject) => { localGetInboxLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetInboxNonblockLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxNonblockLocalResult) => void} & {param: localGetInboxNonblockLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.getInboxNonblockLocal'})
}

export function localGetInboxNonblockLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxNonblockLocalResult) => void} & {param: localGetInboxNonblockLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetInboxNonblockLocalRpc({...request, incomingCallMap, callback}))
}

export function localGetInboxNonblockLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxNonblockLocalResult) => void} & {param: localGetInboxNonblockLocalRpcParam}>): Promise<localGetInboxNonblockLocalResult> {
  return new Promise((resolve, reject) => { localGetInboxNonblockLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetInboxSummaryForCLILocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxSummaryForCLILocalResult) => void} & {param: localGetInboxSummaryForCLILocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.getInboxSummaryForCLILocal'})
}

export function localGetInboxSummaryForCLILocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxSummaryForCLILocalResult) => void} & {param: localGetInboxSummaryForCLILocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetInboxSummaryForCLILocalRpc({...request, incomingCallMap, callback}))
}

export function localGetInboxSummaryForCLILocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetInboxSummaryForCLILocalResult) => void} & {param: localGetInboxSummaryForCLILocalRpcParam}>): Promise<localGetInboxSummaryForCLILocalResult> {
  return new Promise((resolve, reject) => { localGetInboxSummaryForCLILocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetMessagesLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetMessagesLocalResult) => void} & {param: localGetMessagesLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.GetMessagesLocal'})
}

export function localGetMessagesLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetMessagesLocalResult) => void} & {param: localGetMessagesLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetMessagesLocalRpc({...request, incomingCallMap, callback}))
}

export function localGetMessagesLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetMessagesLocalResult) => void} & {param: localGetMessagesLocalRpcParam}>): Promise<localGetMessagesLocalResult> {
  return new Promise((resolve, reject) => { localGetMessagesLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localGetThreadLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localGetThreadLocalResult) => void} & {param: localGetThreadLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.getThreadLocal'})
}

export function localGetThreadLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetThreadLocalResult) => void} & {param: localGetThreadLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localGetThreadLocalRpc({...request, incomingCallMap, callback}))
}

export function localGetThreadLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localGetThreadLocalResult) => void} & {param: localGetThreadLocalRpcParam}>): Promise<localGetThreadLocalResult> {
  return new Promise((resolve, reject) => { localGetThreadLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localMarkAsReadLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localMarkAsReadLocalResult) => void} & {param: localMarkAsReadLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.markAsReadLocal'})
}

export function localMarkAsReadLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localMarkAsReadLocalResult) => void} & {param: localMarkAsReadLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localMarkAsReadLocalRpc({...request, incomingCallMap, callback}))
}

export function localMarkAsReadLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localMarkAsReadLocalResult) => void} & {param: localMarkAsReadLocalRpcParam}>): Promise<localMarkAsReadLocalResult> {
  return new Promise((resolve, reject) => { localMarkAsReadLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localNewConversationLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localNewConversationLocalResult) => void} & {param: localNewConversationLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.newConversationLocal'})
}

export function localNewConversationLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localNewConversationLocalResult) => void} & {param: localNewConversationLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localNewConversationLocalRpc({...request, incomingCallMap, callback}))
}

export function localNewConversationLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localNewConversationLocalResult) => void} & {param: localNewConversationLocalRpcParam}>): Promise<localNewConversationLocalResult> {
  return new Promise((resolve, reject) => { localNewConversationLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localPostAttachmentLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localPostAttachmentLocalResult) => void} & {param: localPostAttachmentLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.postAttachmentLocal'})
}

export function localPostAttachmentLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostAttachmentLocalResult) => void} & {param: localPostAttachmentLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localPostAttachmentLocalRpc({...request, incomingCallMap, callback}))
}

export function localPostAttachmentLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostAttachmentLocalResult) => void} & {param: localPostAttachmentLocalRpcParam}>): Promise<localPostAttachmentLocalResult> {
  return new Promise((resolve, reject) => { localPostAttachmentLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localPostFileAttachmentLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localPostFileAttachmentLocalResult) => void} & {param: localPostFileAttachmentLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.postFileAttachmentLocal'})
}

export function localPostFileAttachmentLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostFileAttachmentLocalResult) => void} & {param: localPostFileAttachmentLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localPostFileAttachmentLocalRpc({...request, incomingCallMap, callback}))
}

export function localPostFileAttachmentLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostFileAttachmentLocalResult) => void} & {param: localPostFileAttachmentLocalRpcParam}>): Promise<localPostFileAttachmentLocalResult> {
  return new Promise((resolve, reject) => { localPostFileAttachmentLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localPostLocalNonblockRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localPostLocalNonblockResult) => void} & {param: localPostLocalNonblockRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.postLocalNonblock'})
}

export function localPostLocalNonblockRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostLocalNonblockResult) => void} & {param: localPostLocalNonblockRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localPostLocalNonblockRpc({...request, incomingCallMap, callback}))
}

export function localPostLocalNonblockRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostLocalNonblockResult) => void} & {param: localPostLocalNonblockRpcParam}>): Promise<localPostLocalNonblockResult> {
  return new Promise((resolve, reject) => { localPostLocalNonblockRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localPostLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localPostLocalResult) => void} & {param: localPostLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.postLocal'})
}

export function localPostLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostLocalResult) => void} & {param: localPostLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localPostLocalRpc({...request, incomingCallMap, callback}))
}

export function localPostLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localPostLocalResult) => void} & {param: localPostLocalRpcParam}>): Promise<localPostLocalResult> {
  return new Promise((resolve, reject) => { localPostLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localRetryPostRpc (request: Exact<requestCommon & requestErrorCallback & {param: localRetryPostRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.RetryPost'})
}

export function localRetryPostRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & requestErrorCallback & {param: localRetryPostRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localRetryPostRpc({...request, incomingCallMap, callback}))
}

export function localRetryPostRpcPromise (request: $Exact<requestCommon & requestErrorCallback & {param: localRetryPostRpcParam}>): Promise<any> {
  return new Promise((resolve, reject) => { localRetryPostRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function localSetConversationStatusLocalRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: localSetConversationStatusLocalResult) => void} & {param: localSetConversationStatusLocalRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.local.SetConversationStatusLocal'})
}

export function localSetConversationStatusLocalRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localSetConversationStatusLocalResult) => void} & {param: localSetConversationStatusLocalRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => localSetConversationStatusLocalRpc({...request, incomingCallMap, callback}))
}

export function localSetConversationStatusLocalRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: localSetConversationStatusLocalResult) => void} & {param: localSetConversationStatusLocalRpcParam}>): Promise<localSetConversationStatusLocalResult> {
  return new Promise((resolve, reject) => { localSetConversationStatusLocalRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteGetInboxRemoteRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetInboxRemoteResult) => void} & {param: remoteGetInboxRemoteRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.getInboxRemote'})
}

export function remoteGetInboxRemoteRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetInboxRemoteResult) => void} & {param: remoteGetInboxRemoteRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteGetInboxRemoteRpc({...request, incomingCallMap, callback}))
}

export function remoteGetInboxRemoteRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetInboxRemoteResult) => void} & {param: remoteGetInboxRemoteRpcParam}>): Promise<remoteGetInboxRemoteResult> {
  return new Promise((resolve, reject) => { remoteGetInboxRemoteRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteGetMessagesRemoteRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetMessagesRemoteResult) => void} & {param: remoteGetMessagesRemoteRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.getMessagesRemote'})
}

export function remoteGetMessagesRemoteRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetMessagesRemoteResult) => void} & {param: remoteGetMessagesRemoteRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteGetMessagesRemoteRpc({...request, incomingCallMap, callback}))
}

export function remoteGetMessagesRemoteRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetMessagesRemoteResult) => void} & {param: remoteGetMessagesRemoteRpcParam}>): Promise<remoteGetMessagesRemoteResult> {
  return new Promise((resolve, reject) => { remoteGetMessagesRemoteRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteGetS3ParamsRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetS3ParamsResult) => void} & {param: remoteGetS3ParamsRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.getS3Params'})
}

export function remoteGetS3ParamsRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetS3ParamsResult) => void} & {param: remoteGetS3ParamsRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteGetS3ParamsRpc({...request, incomingCallMap, callback}))
}

export function remoteGetS3ParamsRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetS3ParamsResult) => void} & {param: remoteGetS3ParamsRpcParam}>): Promise<remoteGetS3ParamsResult> {
  return new Promise((resolve, reject) => { remoteGetS3ParamsRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteGetThreadRemoteRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetThreadRemoteResult) => void} & {param: remoteGetThreadRemoteRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.getThreadRemote'})
}

export function remoteGetThreadRemoteRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetThreadRemoteResult) => void} & {param: remoteGetThreadRemoteRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteGetThreadRemoteRpc({...request, incomingCallMap, callback}))
}

export function remoteGetThreadRemoteRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetThreadRemoteResult) => void} & {param: remoteGetThreadRemoteRpcParam}>): Promise<remoteGetThreadRemoteResult> {
  return new Promise((resolve, reject) => { remoteGetThreadRemoteRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteGetUnreadUpdateFullRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetUnreadUpdateFullResult) => void} & {param: remoteGetUnreadUpdateFullRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.GetUnreadUpdateFull'})
}

export function remoteGetUnreadUpdateFullRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetUnreadUpdateFullResult) => void} & {param: remoteGetUnreadUpdateFullRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteGetUnreadUpdateFullRpc({...request, incomingCallMap, callback}))
}

export function remoteGetUnreadUpdateFullRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteGetUnreadUpdateFullResult) => void} & {param: remoteGetUnreadUpdateFullRpcParam}>): Promise<remoteGetUnreadUpdateFullResult> {
  return new Promise((resolve, reject) => { remoteGetUnreadUpdateFullRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteMarkAsReadRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteMarkAsReadResult) => void} & {param: remoteMarkAsReadRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.markAsRead'})
}

export function remoteMarkAsReadRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteMarkAsReadResult) => void} & {param: remoteMarkAsReadRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteMarkAsReadRpc({...request, incomingCallMap, callback}))
}

export function remoteMarkAsReadRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteMarkAsReadResult) => void} & {param: remoteMarkAsReadRpcParam}>): Promise<remoteMarkAsReadResult> {
  return new Promise((resolve, reject) => { remoteMarkAsReadRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteNewConversationRemote2Rpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteNewConversationRemote2Result) => void} & {param: remoteNewConversationRemote2RpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.newConversationRemote2'})
}

export function remoteNewConversationRemote2RpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteNewConversationRemote2Result) => void} & {param: remoteNewConversationRemote2RpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteNewConversationRemote2Rpc({...request, incomingCallMap, callback}))
}

export function remoteNewConversationRemote2RpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteNewConversationRemote2Result) => void} & {param: remoteNewConversationRemote2RpcParam}>): Promise<remoteNewConversationRemote2Result> {
  return new Promise((resolve, reject) => { remoteNewConversationRemote2Rpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteNewConversationRemoteRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteNewConversationRemoteResult) => void} & {param: remoteNewConversationRemoteRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.newConversationRemote'})
}

export function remoteNewConversationRemoteRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteNewConversationRemoteResult) => void} & {param: remoteNewConversationRemoteRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteNewConversationRemoteRpc({...request, incomingCallMap, callback}))
}

export function remoteNewConversationRemoteRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteNewConversationRemoteResult) => void} & {param: remoteNewConversationRemoteRpcParam}>): Promise<remoteNewConversationRemoteResult> {
  return new Promise((resolve, reject) => { remoteNewConversationRemoteRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remotePostRemoteRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remotePostRemoteResult) => void} & {param: remotePostRemoteRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.postRemote'})
}

export function remotePostRemoteRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remotePostRemoteResult) => void} & {param: remotePostRemoteRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remotePostRemoteRpc({...request, incomingCallMap, callback}))
}

export function remotePostRemoteRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remotePostRemoteResult) => void} & {param: remotePostRemoteRpcParam}>): Promise<remotePostRemoteResult> {
  return new Promise((resolve, reject) => { remotePostRemoteRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteS3SignRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteS3SignResult) => void} & {param: remoteS3SignRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.s3Sign'})
}

export function remoteS3SignRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteS3SignResult) => void} & {param: remoteS3SignRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteS3SignRpc({...request, incomingCallMap, callback}))
}

export function remoteS3SignRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteS3SignResult) => void} & {param: remoteS3SignRpcParam}>): Promise<remoteS3SignResult> {
  return new Promise((resolve, reject) => { remoteS3SignRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteSetConversationStatusRpc (request: Exact<requestCommon & {callback?: ?(err: ?any, response: remoteSetConversationStatusResult) => void} & {param: remoteSetConversationStatusRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.SetConversationStatus'})
}

export function remoteSetConversationStatusRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteSetConversationStatusResult) => void} & {param: remoteSetConversationStatusRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteSetConversationStatusRpc({...request, incomingCallMap, callback}))
}

export function remoteSetConversationStatusRpcPromise (request: $Exact<requestCommon & {callback?: ?(err: ?any, response: remoteSetConversationStatusResult) => void} & {param: remoteSetConversationStatusRpcParam}>): Promise<remoteSetConversationStatusResult> {
  return new Promise((resolve, reject) => { remoteSetConversationStatusRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export function remoteTlfFinalizeRpc (request: Exact<requestCommon & requestErrorCallback & {param: remoteTlfFinalizeRpcParam}>) {
  engineRpcOutgoing({...request, method: 'chat.1.remote.tlfFinalize'})
}

export function remoteTlfFinalizeRpcChannelMap (channelConfig: ChannelConfig<*>, request: $Exact<requestCommon & requestErrorCallback & {param: remoteTlfFinalizeRpcParam}>): ChannelMap<*> {
  return _channelMapRpcHelper(channelConfig, (incomingCallMap, callback) => remoteTlfFinalizeRpc({...request, incomingCallMap, callback}))
}

export function remoteTlfFinalizeRpcPromise (request: $Exact<requestCommon & requestErrorCallback & {param: remoteTlfFinalizeRpcParam}>): Promise<any> {
  return new Promise((resolve, reject) => { remoteTlfFinalizeRpc({...request, callback: (error, result) => { if (error) { reject(error) } else { resolve(result) } }}) })
}

export type Asset = {
  filename: string,
  region: string,
  endpoint: string,
  bucket: string,
  path: string,
  size: int,
  mimeType: string,
  encHash: Hash,
  key: bytes,
  verifyKey: bytes,
  title: string,
  nonce: bytes,
  metadata: string,
}

export type BodyPlaintext = 
    { version : 1, v1 : ?BodyPlaintextV1 }

export type BodyPlaintextV1 = {
  messageBody: MessageBody,
}

export type BodyPlaintextVersion = 
    1 // V1_1

export type ChatActivity = 
    { activityType : 1, incomingMessage : ?IncomingMessage }
  | { activityType : 2, readMessage : ?ReadMessageInfo }
  | { activityType : 3, newConversation : ?NewConversationInfo }
  | { activityType : 4, setStatus : ?SetStatusInfo }
  | { activityType : 5, failedMessage : ?FailedMessageInfo }

export type ChatActivityType = 
    0 // RESERVED_0
  | 1 // INCOMING_MESSAGE_1
  | 2 // READ_MESSAGE_2
  | 3 // NEW_CONVERSATION_3
  | 4 // SET_STATUS_4
  | 5 // FAILED_MESSAGE_5

export type Conversation = {
  metadata: ConversationMetadata,
  readerInfo?: ?ConversationReaderInfo,
  supersedes?: ?Array<ConversationMetadata>,
  supersededBy?: ?Array<ConversationMetadata>,
  maxMsgs?: ?Array<MessageBoxed>,
}

export type ConversationFinalizeInfo = {
  resetUser: string,
  resetDate: string,
  resetTimestamp: gregor1.Time,
}

export type ConversationID = bytes

export type ConversationIDTriple = {
  tlfid: TLFID,
  topicType: TopicType,
  topicID: TopicID,
}

export type ConversationInfoLocal = {
  id: ConversationID,
  triple: ConversationIDTriple,
  tlfName: string,
  topicName: string,
  visibility: TLFVisibility,
  status: ConversationStatus,
  writerNames?: ?Array<string>,
  readerNames?: ?Array<string>,
  finalizeInfo?: ?ConversationFinalizeInfo,
}

export type ConversationLocal = {
  error?: ?string,
  info: ConversationInfoLocal,
  readerInfo: ConversationReaderInfo,
  supersedes?: ?Array<ConversationID>,
  supersededBy?: ?Array<ConversationID>,
  maxMessages?: ?Array<MessageUnboxed>,
  isEmpty: boolean,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type ConversationMetadata = {
  idTriple: ConversationIDTriple,
  conversationID: ConversationID,
  visibility: TLFVisibility,
  status: ConversationStatus,
  finalizeInfo?: ?ConversationFinalizeInfo,
  activeList?: ?Array<gregor1.UID>,
}

export type ConversationReaderInfo = {
  mtime: gregor1.Time,
  readMsgid: MessageID,
  maxMsgid: MessageID,
}

export type ConversationStatus = 
    0 // UNFILED_0
  | 1 // FAVORITE_1
  | 2 // IGNORED_2
  | 3 // BLOCKED_3

export type DownloadAttachmentLocalRes = {
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type EncryptedData = {
  v: int,
  e: bytes,
  n: bytes,
}

export type FailedMessageInfo = {
  outboxRecords?: ?Array<OutboxRecord>,
}

export type GenericPayload = {
  Action: string,
}

export type GetConversationForCLILocalQuery = {
  markAsRead: boolean,
  MessageTypes?: ?Array<MessageType>,
  Since?: ?string,
  limit: UnreadFirstNumLimit,
  conversationId: ConversationID,
}

export type GetConversationForCLILocalRes = {
  conversation: ConversationLocal,
  messages?: ?Array<MessageUnboxed>,
  rateLimits?: ?Array<RateLimit>,
}

export type GetConversationMetadataRemoteRes = {
  conv: Conversation,
  rateLimit?: ?RateLimit,
}

export type GetInboxAndUnboxLocalRes = {
  conversations?: ?Array<ConversationLocal>,
  pagination?: ?Pagination,
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type GetInboxByTLFIDRemoteRes = {
  convs?: ?Array<Conversation>,
  rateLimit?: ?RateLimit,
}

export type GetInboxLocalQuery = {
  tlfName?: ?string,
  topicName?: ?string,
  convID?: ?ConversationID,
  topicType?: ?TopicType,
  tlfVisibility?: ?TLFVisibility,
  before?: ?gregor1.Time,
  after?: ?gregor1.Time,
  oneChatTypePerTLF?: ?boolean,
  status?: ?Array<ConversationStatus>,
  unreadOnly: boolean,
  readOnly: boolean,
  computeActiveList: boolean,
}

export type GetInboxLocalRes = {
  conversationsUnverified?: ?Array<Conversation>,
  pagination?: ?Pagination,
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type GetInboxNonblockLocalRes = {
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
  rateLimits?: ?Array<RateLimit>,
}

export type GetInboxQuery = {
  convID?: ?ConversationID,
  topicType?: ?TopicType,
  tlfID?: ?TLFID,
  tlfVisibility?: ?TLFVisibility,
  before?: ?gregor1.Time,
  after?: ?gregor1.Time,
  oneChatTypePerTLF?: ?boolean,
  status?: ?Array<ConversationStatus>,
  unreadOnly: boolean,
  readOnly: boolean,
  computeActiveList: boolean,
}

export type GetInboxRemoteRes = {
  inbox: InboxView,
  rateLimit?: ?RateLimit,
}

export type GetInboxSummaryForCLILocalQuery = {
  topicType: TopicType,
  after: string,
  before: string,
  visibility: TLFVisibility,
  status?: ?Array<ConversationStatus>,
  unreadFirst: boolean,
  unreadFirstLimit: UnreadFirstNumLimit,
  activitySortedLimit: int,
}

export type GetInboxSummaryForCLILocalRes = {
  conversations?: ?Array<ConversationLocal>,
  rateLimits?: ?Array<RateLimit>,
}

export type GetMessagesLocalRes = {
  messages?: ?Array<MessageUnboxed>,
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type GetMessagesRemoteRes = {
  msgs?: ?Array<MessageBoxed>,
  rateLimit?: ?RateLimit,
}

export type GetThreadLocalRes = {
  thread: ThreadView,
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type GetThreadQuery = {
  markAsRead: boolean,
  messageTypes?: ?Array<MessageType>,
  before?: ?gregor1.Time,
  after?: ?gregor1.Time,
}

export type GetThreadRemoteRes = {
  thread: ThreadViewBoxed,
  rateLimit?: ?RateLimit,
}

export type Hash = bytes

export type HeaderPlaintext = 
    { version : 1, v1 : ?HeaderPlaintextV1 }

export type HeaderPlaintextV1 = {
  conv: ConversationIDTriple,
  tlfName: string,
  tlfPublic: boolean,
  messageType: MessageType,
  prev?: ?Array<MessagePreviousPointer>,
  sender: gregor1.UID,
  senderDevice: gregor1.DeviceID,
  bodyHash: Hash,
  outboxInfo?: ?OutboxInfo,
  outboxID?: ?OutboxID,
  headerSignature?: ?SignatureInfo,
}

export type HeaderPlaintextVersion = 
    1 // V1_1

export type InboxResType = 
    0 // VERSIONHIT_0
  | 1 // FULL_1

export type InboxVers = uint64

export type InboxView = 
    { rtype : 0 }
  | { rtype : 1, full : ?InboxViewFull }

export type InboxViewFull = {
  vers: InboxVers,
  conversations?: ?Array<Conversation>,
  pagination?: ?Pagination,
}

export type IncomingMessage = {
  message: MessageUnboxed,
  convID: ConversationID,
}

export type LocalFileSource = {
  filename: string,
}

export type LocalSource = {
  source: keybase1.Stream,
  filename: string,
  size: int,
}

export type MarkAsReadRes = {
  rateLimit?: ?RateLimit,
}

export type MerkleRoot = {
  seqno: long,
  hash: bytes,
}

export type MessageAttachment = {
  object: Asset,
  preview?: ?Asset,
  metadata: bytes,
}

export type MessageBody = 
    { messageType : 1, text : ?MessageText }
  | { messageType : 2, attachment : ?MessageAttachment }
  | { messageType : 3, edit : ?MessageEdit }
  | { messageType : 4, delete : ?MessageDelete }
  | { messageType : 5, metadata : ?MessageConversationMetadata }
  | { messageType : 7, headline : ?MessageHeadline }

export type MessageBoxed = {
  serverHeader?: ?MessageServerHeader,
  clientHeader: MessageClientHeader,
  headerCiphertext: EncryptedData,
  bodyCiphertext: EncryptedData,
  keyGeneration: int,
}

export type MessageClientHeader = {
  conv: ConversationIDTriple,
  tlfName: string,
  tlfPublic: boolean,
  messageType: MessageType,
  supersedes: MessageID,
  deletes?: ?Array<MessageID>,
  prev?: ?Array<MessagePreviousPointer>,
  sender: gregor1.UID,
  senderDevice: gregor1.DeviceID,
  merkleRoot?: ?MerkleRoot,
  outboxID?: ?OutboxID,
  outboxInfo?: ?OutboxInfo,
}

export type MessageConversationMetadata = {
  conversationTitle: string,
}

export type MessageDelete = {
  messageIDs?: ?Array<MessageID>,
}

export type MessageEdit = {
  messageID: MessageID,
  body: string,
}

export type MessageHeadline = {
  headline: string,
}

export type MessageID = uint

export type MessagePlaintext = {
  clientHeader: MessageClientHeader,
  messageBody: MessageBody,
}

export type MessagePreviousPointer = {
  id: MessageID,
  hash: Hash,
}

export type MessageSentInfo = {
  convID: ConversationID,
  rateLimit: RateLimit,
  outboxID: OutboxID,
}

export type MessageServerHeader = {
  messageID: MessageID,
  supersededBy: MessageID,
  ctime: gregor1.Time,
}

export type MessageText = {
  body: string,
}

export type MessageType = 
    0 // NONE_0
  | 1 // TEXT_1
  | 2 // ATTACHMENT_2
  | 3 // EDIT_3
  | 4 // DELETE_4
  | 5 // METADATA_5
  | 6 // TLFNAME_6
  | 7 // HEADLINE_7

export type MessageUnboxed = 
    { state : 1, valid : ?MessageUnboxedValid }
  | { state : 2, error : ?MessageUnboxedError }
  | { state : 3, outbox : ?OutboxRecord }

export type MessageUnboxedError = {
  errMsg: string,
  messageID: MessageID,
  messageType: MessageType,
}

export type MessageUnboxedState = 
    1 // VALID_1
  | 2 // ERROR_2
  | 3 // OUTBOX_3

export type MessageUnboxedValid = {
  clientHeader: MessageClientHeader,
  serverHeader: MessageServerHeader,
  messageBody: MessageBody,
  senderUsername: string,
  senderDeviceName: string,
  senderDeviceType: string,
  headerHash: Hash,
  headerSignature?: ?SignatureInfo,
  senderDeviceRevokedAt?: ?gregor1.Time,
}

export type NewConversationInfo = {
  conv: ConversationLocal,
}

export type NewConversationLocalRes = {
  conv: ConversationLocal,
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type NewConversationPayload = {
  Action: string,
  convID: ConversationID,
  inboxVers: InboxVers,
  unreadUpdate?: ?UnreadUpdate,
}

export type NewConversationRemoteRes = {
  convID: ConversationID,
  rateLimit?: ?RateLimit,
}

export type NewMessagePayload = {
  Action: string,
  convID: ConversationID,
  message: MessageBoxed,
  inboxVers: InboxVers,
  unreadUpdate?: ?UnreadUpdate,
}

export type NotifyChatChatIdentifyUpdateRpcParam = Exact<{
  update: keybase1.CanonicalTLFNameAndIDWithBreaks
}>

export type NotifyChatChatInboxStaleRpcParam = Exact<{
  uid: keybase1.UID
}>

export type NotifyChatChatTLFFinalizeRpcParam = Exact<{
  uid: keybase1.UID,
  convID: ConversationID,
  finalizeInfo: ConversationFinalizeInfo
}>

export type NotifyChatChatThreadsStaleRpcParam = Exact<{
  uid: keybase1.UID,
  convIDs?: ?Array<ConversationID>
}>

export type NotifyChatNewChatActivityRpcParam = Exact<{
  uid: keybase1.UID,
  activity: ChatActivity
}>

export type OutboxID = bytes

export type OutboxInfo = {
  prev: MessageID,
  composeTime: gregor1.Time,
}

export type OutboxRecord = {
  state: OutboxState,
  outboxID: OutboxID,
  convID: ConversationID,
  Msg: MessagePlaintext,
  identifyBehavior: keybase1.TLFIdentifyBehavior,
}

export type OutboxState = 
    { state : 0, sending : ?int }
  | { state : 1, error : ?string }

export type OutboxStateType = 
    0 // SENDING_0
  | 1 // ERROR_1

export type Pagination = {
  next: bytes,
  previous: bytes,
  num: int,
  last: boolean,
}

export type PostLocalNonblockRes = {
  rateLimits?: ?Array<RateLimit>,
  outboxID: OutboxID,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type PostLocalRes = {
  rateLimits?: ?Array<RateLimit>,
  messageID: MessageID,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type PostRemoteRes = {
  msgHeader: MessageServerHeader,
  rateLimit?: ?RateLimit,
}

export type RateLimit = {
  name: string,
  callsRemaining: int,
  windowReset: int,
  maxCalls: int,
}

export type ReadMessageInfo = {
  convID: ConversationID,
  msgID: MessageID,
}

export type ReadMessagePayload = {
  Action: string,
  convID: ConversationID,
  msgID: MessageID,
  inboxVers: InboxVers,
  unreadUpdate?: ?UnreadUpdate,
}

export type S3Params = {
  bucket: string,
  objectKey: string,
  accessKey: string,
  acl: string,
  regionName: string,
  regionEndpoint: string,
  regionBucketEndpoint: string,
}

export type SetConversationStatusLocalRes = {
  rateLimits?: ?Array<RateLimit>,
  identifyFailures?: ?Array<keybase1.TLFIdentifyFailure>,
}

export type SetConversationStatusRes = {
  rateLimit?: ?RateLimit,
}

export type SetStatusInfo = {
  convID: ConversationID,
  status: ConversationStatus,
}

export type SetStatusPayload = {
  Action: string,
  convID: ConversationID,
  status: ConversationStatus,
  inboxVers: InboxVers,
  unreadUpdate?: ?UnreadUpdate,
}

export type SignatureInfo = {
  v: int,
  s: bytes,
  k: bytes,
}

export type TLFFinalizeUpdate = {
  finalizeInfo: ConversationFinalizeInfo,
  convIDs?: ?Array<ConversationID>,
  inboxVers: InboxVers,
}

export type TLFID = bytes

export type TLFVisibility = 
    0 // ANY_0
  | 1 // PUBLIC_1
  | 2 // PRIVATE_2

export type ThreadID = bytes

export type ThreadView = {
  messages?: ?Array<MessageUnboxed>,
  pagination?: ?Pagination,
}

export type ThreadViewBoxed = {
  messages?: ?Array<MessageBoxed>,
  pagination?: ?Pagination,
}

export type TopicID = bytes

export type TopicType = 
    0 // NONE_0
  | 1 // CHAT_1
  | 2 // DEV_2

export type UnreadFirstNumLimit = {
  NumRead: int,
  AtLeast: int,
  AtMost: int,
}

export type UnreadUpdate = {
  convID: ConversationID,
  UnreadMessages: int,
}

export type UnreadUpdateFull = {
  ignore: boolean,
  inboxVers: InboxVers,
  updates?: ?Array<UnreadUpdate>,
}

export type chatUiChatAttachmentDownloadProgressRpcParam = Exact<{
  bytesComplete: int,
  bytesTotal: int
}>

export type chatUiChatAttachmentUploadProgressRpcParam = Exact<{
  bytesComplete: int,
  bytesTotal: int
}>

export type chatUiChatInboxConversationRpcParam = Exact<{
  conv: ConversationLocal
}>

export type chatUiChatInboxFailedRpcParam = Exact<{
  convID: ConversationID,
  error: string
}>

export type chatUiChatInboxUnverifiedRpcParam = Exact<{
  inbox: GetInboxLocalRes
}>

export type localCancelPostRpcParam = Exact<{
  outboxID: OutboxID
}>

export type localDownloadAttachmentLocalRpcParam = Exact<{
  conversationID: ConversationID,
  messageID: MessageID,
  sink: keybase1.Stream,
  preview: boolean,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localDownloadFileAttachmentLocalRpcParam = Exact<{
  conversationID: ConversationID,
  messageID: MessageID,
  filename: string,
  preview: boolean,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localGetConversationForCLILocalRpcParam = Exact<{
  query: GetConversationForCLILocalQuery
}>

export type localGetInboxAndUnboxLocalRpcParam = Exact<{
  query?: ?GetInboxLocalQuery,
  pagination?: ?Pagination,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localGetInboxLocalRpcParam = Exact<{
  query?: ?GetInboxLocalQuery,
  pagination?: ?Pagination,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localGetInboxNonblockLocalRpcParam = Exact<{
  query?: ?GetInboxLocalQuery,
  pagination?: ?Pagination,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localGetInboxSummaryForCLILocalRpcParam = Exact<{
  query: GetInboxSummaryForCLILocalQuery
}>

export type localGetMessagesLocalRpcParam = Exact<{
  conversationID: ConversationID,
  messageIDs?: ?Array<MessageID>,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localGetThreadLocalRpcParam = Exact<{
  conversationID: ConversationID,
  query?: ?GetThreadQuery,
  pagination?: ?Pagination,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localMarkAsReadLocalRpcParam = Exact<{
  conversationID: ConversationID,
  msgID: MessageID
}>

export type localNewConversationLocalRpcParam = Exact<{
  tlfName: string,
  topicType: TopicType,
  tlfVisibility: TLFVisibility,
  topicName?: ?string,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localPostAttachmentLocalRpcParam = Exact<{
  conversationID: ConversationID,
  clientHeader: MessageClientHeader,
  attachment: LocalSource,
  preview?: ?LocalSource,
  title: string,
  metadata: bytes,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localPostFileAttachmentLocalRpcParam = Exact<{
  conversationID: ConversationID,
  clientHeader: MessageClientHeader,
  attachment: LocalFileSource,
  preview?: ?LocalFileSource,
  title: string,
  metadata: bytes,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localPostLocalNonblockRpcParam = Exact<{
  conversationID: ConversationID,
  msg: MessagePlaintext,
  clientPrev: MessageID,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localPostLocalRpcParam = Exact<{
  conversationID: ConversationID,
  msg: MessagePlaintext,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type localRetryPostRpcParam = Exact<{
  outboxID: OutboxID
}>

export type localSetConversationStatusLocalRpcParam = Exact<{
  conversationID: ConversationID,
  status: ConversationStatus,
  identifyBehavior: keybase1.TLFIdentifyBehavior
}>

export type remoteGetInboxRemoteRpcParam = Exact<{
  vers: InboxVers,
  query?: ?GetInboxQuery,
  pagination?: ?Pagination
}>

export type remoteGetMessagesRemoteRpcParam = Exact<{
  conversationID: ConversationID,
  messageIDs?: ?Array<MessageID>
}>

export type remoteGetS3ParamsRpcParam = Exact<{
  conversationID: ConversationID
}>

export type remoteGetThreadRemoteRpcParam = Exact<{
  conversationID: ConversationID,
  query?: ?GetThreadQuery,
  pagination?: ?Pagination
}>

export type remoteGetUnreadUpdateFullRpcParam = Exact<{
  inboxVers: InboxVers
}>

export type remoteMarkAsReadRpcParam = Exact<{
  conversationID: ConversationID,
  msgID: MessageID
}>

export type remoteNewConversationRemote2RpcParam = Exact<{
  idTriple: ConversationIDTriple,
  TLFMessage: MessageBoxed
}>

export type remoteNewConversationRemoteRpcParam = Exact<{
  idTriple: ConversationIDTriple
}>

export type remotePostRemoteRpcParam = Exact<{
  conversationID: ConversationID,
  messageBoxed: MessageBoxed
}>

export type remoteS3SignRpcParam = Exact<{
  version: int,
  payload: bytes
}>

export type remoteSetConversationStatusRpcParam = Exact<{
  conversationID: ConversationID,
  status: ConversationStatus
}>

export type remoteTlfFinalizeRpcParam = Exact<{
  tlfID: TLFID,
  resetUser: string,
  resetDate: string,
  resetTimestamp: gregor1.Time
}>

type localDownloadAttachmentLocalResult = DownloadAttachmentLocalRes

type localDownloadFileAttachmentLocalResult = DownloadAttachmentLocalRes

type localGetConversationForCLILocalResult = GetConversationForCLILocalRes

type localGetInboxAndUnboxLocalResult = GetInboxAndUnboxLocalRes

type localGetInboxLocalResult = GetInboxLocalRes

type localGetInboxNonblockLocalResult = GetInboxNonblockLocalRes

type localGetInboxSummaryForCLILocalResult = GetInboxSummaryForCLILocalRes

type localGetMessagesLocalResult = GetMessagesLocalRes

type localGetThreadLocalResult = GetThreadLocalRes

type localMarkAsReadLocalResult = MarkAsReadRes

type localNewConversationLocalResult = NewConversationLocalRes

type localPostAttachmentLocalResult = PostLocalRes

type localPostFileAttachmentLocalResult = PostLocalRes

type localPostLocalNonblockResult = PostLocalNonblockRes

type localPostLocalResult = PostLocalRes

type localSetConversationStatusLocalResult = SetConversationStatusLocalRes

type remoteGetInboxRemoteResult = GetInboxRemoteRes

type remoteGetMessagesRemoteResult = GetMessagesRemoteRes

type remoteGetS3ParamsResult = S3Params

type remoteGetThreadRemoteResult = GetThreadRemoteRes

type remoteGetUnreadUpdateFullResult = UnreadUpdateFull

type remoteMarkAsReadResult = MarkAsReadRes

type remoteNewConversationRemote2Result = NewConversationRemoteRes

type remoteNewConversationRemoteResult = NewConversationRemoteRes

type remotePostRemoteResult = PostRemoteRes

type remoteS3SignResult = bytes

type remoteSetConversationStatusResult = SetConversationStatusRes

export type rpc =
    localCancelPostRpc
  | localDownloadAttachmentLocalRpc
  | localDownloadFileAttachmentLocalRpc
  | localGetConversationForCLILocalRpc
  | localGetInboxAndUnboxLocalRpc
  | localGetInboxLocalRpc
  | localGetInboxNonblockLocalRpc
  | localGetInboxSummaryForCLILocalRpc
  | localGetMessagesLocalRpc
  | localGetThreadLocalRpc
  | localMarkAsReadLocalRpc
  | localNewConversationLocalRpc
  | localPostAttachmentLocalRpc
  | localPostFileAttachmentLocalRpc
  | localPostLocalNonblockRpc
  | localPostLocalRpc
  | localRetryPostRpc
  | localSetConversationStatusLocalRpc
  | remoteGetInboxRemoteRpc
  | remoteGetMessagesRemoteRpc
  | remoteGetS3ParamsRpc
  | remoteGetThreadRemoteRpc
  | remoteGetUnreadUpdateFullRpc
  | remoteMarkAsReadRpc
  | remoteNewConversationRemote2Rpc
  | remoteNewConversationRemoteRpc
  | remotePostRemoteRpc
  | remoteS3SignRpc
  | remoteSetConversationStatusRpc
  | remoteTlfFinalizeRpc
export type incomingCallMapType = Exact<{
  'keybase.1.chatUi.chatAttachmentUploadStart'?: (
    params: Exact<{
      sessionID: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentUploadProgress'?: (
    params: Exact<{
      sessionID: int,
      bytesComplete: int,
      bytesTotal: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentUploadDone'?: (
    params: Exact<{
      sessionID: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentPreviewUploadStart'?: (
    params: Exact<{
      sessionID: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentPreviewUploadDone'?: (
    params: Exact<{
      sessionID: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentDownloadStart'?: (
    params: Exact<{
      sessionID: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentDownloadProgress'?: (
    params: Exact<{
      sessionID: int,
      bytesComplete: int,
      bytesTotal: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatAttachmentDownloadDone'?: (
    params: Exact<{
      sessionID: int
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatInboxUnverified'?: (
    params: Exact<{
      sessionID: int,
      inbox: GetInboxLocalRes
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatInboxConversation'?: (
    params: Exact<{
      sessionID: int,
      conv: ConversationLocal
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.chatUi.chatInboxFailed'?: (
    params: Exact<{
      sessionID: int,
      convID: ConversationID,
      error: string
    }>,
    response: CommonResponseHandler
  ) => void,
  'keybase.1.NotifyChat.NewChatActivity'?: (
    params: Exact<{
      uid: keybase1.UID,
      activity: ChatActivity
    }> /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyChat.ChatIdentifyUpdate'?: (
    params: Exact<{
      update: keybase1.CanonicalTLFNameAndIDWithBreaks
    }> /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyChat.ChatTLFFinalize'?: (
    params: Exact<{
      uid: keybase1.UID,
      convID: ConversationID,
      finalizeInfo: ConversationFinalizeInfo
    }> /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyChat.ChatInboxStale'?: (
    params: Exact<{
      uid: keybase1.UID
    }> /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyChat.ChatThreadsStale'?: (
    params: Exact<{
      uid: keybase1.UID,
      convIDs?: ?Array<ConversationID>
    }> /* ,
    response: {} // Notify call
    */
  ) => void
}>

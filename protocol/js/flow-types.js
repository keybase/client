/* @flow */

// This file is auto-generated by client/protocol/Makefile.

export type Int = number
export type Long = number
export type Double = number
export type String = string
export type Boolean = boolean
export type Null = null
export type Bytes = any
export type RPCError = {
  code: number,
  desc: string
}

export type AccountPassphraseChangeResult = void

export type AccountPassphraseChangeRpc = {
  method: 'account.passphraseChange',
  param: {
    oldPassphrase: String,
    passphrase: String,
    force: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: AccountPassphraseChangeResult) => void)
}

export type AccountPassphrasePromptResult = GetPassphraseRes

export type AccountPassphrasePromptRpc = {
  method: 'account.passphrasePrompt',
  param: {
    guiArg: GUIEntryArg
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: AccountPassphrasePromptResult) => void)
}

export type Asset = {
  name: String;
  url: String;
  digest: String;
  signature: String;
  localPath: String;
}

export type BTCRegisterBTCResult = void

export type BTCRegisterBTCRpc = {
  method: 'BTC.registerBTC',
  param: {
    address: String,
    force: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BTCRegisterBTCResult) => void)
}

export type BlockAddReferenceResult = void

export type BlockAddReferenceRpc = {
  method: 'block.addReference',
  param: {
    folder: String,
    ref: BlockReference
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockAddReferenceResult) => void)
}

export type BlockArchiveReferenceResult = Array<BlockReference>

export type BlockArchiveReferenceRpc = {
  method: 'block.archiveReference',
  param: {
    folder: String,
    refs: Array<BlockReference>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockArchiveReferenceResult) => void)
}

export type BlockArchiveReferenceWithCountResult = DowngradeReferenceRes

export type BlockArchiveReferenceWithCountRpc = {
  method: 'block.archiveReferenceWithCount',
  param: {
    folder: String,
    refs: Array<BlockReference>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockArchiveReferenceWithCountResult) => void)
}

export type BlockAuthenticateSessionResult = void

export type BlockAuthenticateSessionRpc = {
  method: 'block.authenticateSession',
  param: {
    signature: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockAuthenticateSessionResult) => void)
}

export type BlockDelReferenceResult = void

export type BlockDelReferenceRpc = {
  method: 'block.delReference',
  param: {
    folder: String,
    ref: BlockReference
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockDelReferenceResult) => void)
}

export type BlockDelReferenceWithCountResult = DowngradeReferenceRes

export type BlockDelReferenceWithCountRpc = {
  method: 'block.delReferenceWithCount',
  param: {
    folder: String,
    refs: Array<BlockReference>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockDelReferenceWithCountResult) => void)
}

export type BlockGetBlockResult = GetBlockRes

export type BlockGetBlockRpc = {
  method: 'block.getBlock',
  param: {
    bid: BlockIdCombo,
    folder: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockGetBlockResult) => void)
}

export type BlockGetSessionChallengeResult = ChallengeInfo

export type BlockGetSessionChallengeRpc = {
  method: 'block.getSessionChallenge',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockGetSessionChallengeResult) => void)
}

export type BlockGetUserQuotaInfoResult = Bytes

export type BlockGetUserQuotaInfoRpc = {
  method: 'block.getUserQuotaInfo',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockGetUserQuotaInfoResult) => void)
}

export type BlockIdCombo = {
  blockHash: String;
  chargedTo: UID;
}

export type BlockPutBlockResult = void

export type BlockPutBlockRpc = {
  method: 'block.putBlock',
  param: {
    bid: BlockIdCombo,
    folder: String,
    blockKey: String,
    buf: Bytes
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: BlockPutBlockResult) => void)
}

export type BlockRefNonce = any

export type BlockReference = {
  bid: BlockIdCombo;
  nonce: BlockRefNonce;
  chargedTo: UID;
}

export type BlockReferenceCount = {
  ref: BlockReference;
  liveCount: Int;
}

export type BoxNonce = any

export type BoxPublicKey = any

export type Bytes32 = any

export type ChallengeInfo = {
  now: Long;
  challenge: String;
}

export type CheckProofStatus = {
  found: Boolean;
  status: ProofStatus;
  proofText: String;
}

export type CheckResult = {
  proofResult: ProofResult;
  time: Time;
  freshness: CheckResultFreshness;
}

export type CheckResultFreshness =
    0 // FRESH_0
  | 1 // AGED_1
  | 2 // RANCID_2

export type ChooseType =
    0 // EXISTING_DEVICE_0
  | 1 // NEW_DEVICE_1

export type CiphertextBundle = {
  kid: KID;
  ciphertext: EncryptedBytes32;
  nonce: BoxNonce;
  publicKey: BoxPublicKey;
}

export type ClientDetails = {
  pid: Int;
  clientType: ClientType;
  argv: Array<string>;
  desc: String;
  version: String;
}

export type ClientType = 2 // FORCE GUI ONLY

export type ComponentResult = {
  name: String;
  status: Status;
}

export type Config = {
  serverURI: String;
  socketFile: String;
  label: String;
  runMode: String;
  gpgExists: Boolean;
  gpgPath: String;
  version: String;
  path: String;
  configPath: String;
  versionShort: String;
  versionFull: String;
  isAutoForked: Boolean;
  forkType: ForkType;
}

export type ConfigClearValueResult = void

export type ConfigClearValueRpc = {
  method: 'config.clearValue',
  param: {
    path: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigClearValueResult) => void)
}

export type ConfigGetConfigResult = Config

export type ConfigGetConfigRpc = {
  method: 'config.getConfig',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigGetConfigResult) => void)
}

export type ConfigGetCurrentStatusResult = GetCurrentStatusRes

export type ConfigGetCurrentStatusRpc = {
  method: 'config.getCurrentStatus',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigGetCurrentStatusResult) => void)
}

export type ConfigGetExtendedStatusResult = ExtendedStatus

export type ConfigGetExtendedStatusRpc = {
  method: 'config.getExtendedStatus',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigGetExtendedStatusResult) => void)
}

export type ConfigGetValueResult = ConfigValue

export type ConfigGetValueRpc = {
  method: 'config.getValue',
  param: {
    path: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigGetValueResult) => void)
}

export type ConfigHelloIAmResult = void

export type ConfigHelloIAmRpc = {
  method: 'config.helloIAm',
  param: {
    details: ClientDetails
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigHelloIAmResult) => void)
}

export type ConfigSetPathResult = void

export type ConfigSetPathRpc = {
  method: 'config.setPath',
  param: {
    path: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigSetPathResult) => void)
}

export type ConfigSetUserConfigResult = void

export type ConfigSetUserConfigRpc = {
  method: 'config.setUserConfig',
  param: {
    username: String,
    key: String,
    value: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigSetUserConfigResult) => void)
}

export type ConfigSetValueResult = void

export type ConfigSetValueRpc = {
  method: 'config.setValue',
  param: {
    path: String,
    value: ConfigValue
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ConfigSetValueResult) => void)
}

export type ConfigValue = {
  isNull: Boolean;
  b?: ?Boolean;
  i?: ?Int;
  s?: ?String;
  o?: ?String;
}

export type ConfiguredAccount = {
  username: String;
  hasStoredSecret: Boolean;
}

export type ConfirmResult = {
  identityConfirmed: Boolean;
  remoteConfirmed: Boolean;
  expiringLocal: Boolean;
}

export type CryptoSignED25519Result = ED25519SignatureInfo

export type CryptoSignED25519Rpc = {
  method: 'crypto.signED25519',
  param: {
    msg: Bytes,
    reason: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CryptoSignED25519Result) => void)
}

export type CryptoSignToStringResult = String

export type CryptoSignToStringRpc = {
  method: 'crypto.signToString',
  param: {
    msg: Bytes,
    reason: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CryptoSignToStringResult) => void)
}

export type CryptoUnboxBytes32AnyResult = UnboxAnyRes

export type CryptoUnboxBytes32AnyRpc = {
  method: 'crypto.unboxBytes32Any',
  param: {
    bundles: Array<CiphertextBundle>,
    reason: String,
    promptPaper: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CryptoUnboxBytes32AnyResult) => void)
}

export type CryptoUnboxBytes32Result = Bytes32

export type CryptoUnboxBytes32Rpc = {
  method: 'crypto.unboxBytes32',
  param: {
    encryptedBytes32: EncryptedBytes32,
    nonce: BoxNonce,
    peersPublicKey: BoxPublicKey,
    reason: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CryptoUnboxBytes32Result) => void)
}

export type Cryptocurrency = {
  rowId: Int;
  pkhash: Bytes;
  address: String;
}

export type CsrfToken = String

export type CtlDbNukeResult = void

export type CtlDbNukeRpc = {
  method: 'ctl.dbNuke',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CtlDbNukeResult) => void)
}

export type CtlLogRotateResult = void

export type CtlLogRotateRpc = {
  method: 'ctl.logRotate',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CtlLogRotateResult) => void)
}

export type CtlReloadResult = void

export type CtlReloadRpc = {
  method: 'ctl.reload',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CtlReloadResult) => void)
}

export type CtlStopResult = void

export type CtlStopRpc = {
  method: 'ctl.stop',
  param: {
    exitCode: ExitCode
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: CtlStopResult) => void)
}

export type DebuggingFirstStepResult = FirstStepResult

export type DebuggingFirstStepRpc = {
  method: 'debugging.firstStep',
  param: {
    val: Int
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DebuggingFirstStepResult) => void)
}

export type DebuggingIncrementResult = Int

export type DebuggingIncrementRpc = {
  method: 'debugging.increment',
  param: {
    val: Int
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DebuggingIncrementResult) => void)
}

export type DebuggingSecondStepResult = Int

export type DebuggingSecondStepRpc = {
  method: 'debugging.secondStep',
  param: {
    val: Int
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DebuggingSecondStepResult) => void)
}

export type DelegateUiCtlRegisterIdentifyUIResult = void

export type DelegateUiCtlRegisterIdentifyUIRpc = {
  method: 'delegateUiCtl.registerIdentifyUI',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DelegateUiCtlRegisterIdentifyUIResult) => void)
}

export type DelegateUiCtlRegisterRekeyUIResult = void

export type DelegateUiCtlRegisterRekeyUIRpc = {
  method: 'delegateUiCtl.registerRekeyUI',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DelegateUiCtlRegisterRekeyUIResult) => void)
}

export type DelegateUiCtlRegisterSecretUIResult = void

export type DelegateUiCtlRegisterSecretUIRpc = {
  method: 'delegateUiCtl.registerSecretUI',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DelegateUiCtlRegisterSecretUIResult) => void)
}

export type DelegateUiCtlRegisterUpdateUIResult = void

export type DelegateUiCtlRegisterUpdateUIRpc = {
  method: 'delegateUiCtl.registerUpdateUI',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DelegateUiCtlRegisterUpdateUIResult) => void)
}

export type Device = {
  type: String;
  name: String;
  deviceID: DeviceID;
  cTime: Time;
  mTime: Time;
  lastUsedTime: Time;
  encryptKey: KID;
  verifyKey: KID;
  status: Int;
}

export type DeviceCheckDeviceNameFormatResult = Boolean

export type DeviceCheckDeviceNameFormatRpc = {
  method: 'device.checkDeviceNameFormat',
  param: {
    name: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DeviceCheckDeviceNameFormatResult) => void)
}

export type DeviceDetail = {
  device: Device;
  eldest: Boolean;
  provisioner?: ?Device;
  provisionedAt?: ?Time;
  revokedAt?: ?Time;
  currentDevice: Boolean;
}

export type DeviceDeviceAddResult = void

export type DeviceDeviceAddRpc = {
  method: 'device.deviceAdd',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DeviceDeviceAddResult) => void)
}

export type DeviceDeviceHistoryListResult = Array<DeviceDetail>

export type DeviceDeviceHistoryListRpc = {
  method: 'device.deviceHistoryList',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DeviceDeviceHistoryListResult) => void)
}

export type DeviceDeviceListResult = Array<Device>

export type DeviceDeviceListRpc = {
  method: 'device.deviceList',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: DeviceDeviceListResult) => void)
}

export type DeviceID = String

export type DeviceType =
    0 // DESKTOP_0
  | 1 // MOBILE_1

export type DismissReason = {
  type: DismissReasonType;
  reason: String;
  resource: String;
}

export type DismissReasonType =
    0 // NONE_0
  | 1 // HANDLED_ELSEWHERE_1

export type DowngradeReferenceRes = {
  completed: Array<BlockReferenceCount>;
  failed: BlockReference;
}

export type ED25519PublicKey = any

export type ED25519Signature = any

export type ED25519SignatureInfo = {
  sig: ED25519Signature;
  publicKey: ED25519PublicKey;
}

export type EncryptedBytes32 = any

export type ExitCode =
    0 // OK_0
  | 2 // NOTOK_2
  | 4 // RESTART_4

export type ExtendedStatus = {
  standalone: Boolean;
  passphraseStreamCached: Boolean;
  lksecLoaded: Boolean;
  device?: ?Device;
  logDir: String;
  session?: ?SessionStatus;
  defaultUsername: String;
  provisionedUsernames: Array<string>;
  Clients: Array<ClientDetails>;
  platformInfo: PlatformInfo;
}

export type FSErrorType =
    0 // ACCESS_DENIED_0
  | 1 // USER_NOT_FOUND_1
  | 2 // REVOKED_DATA_DETECTED_2
  | 3 // NOT_LOGGED_IN_3
  | 4 // TIMEOUT_4
  | 5 // REKEY_NEEDED_5
  | 6 // BAD_FOLDER_6
  | 7 // NOT_IMPLEMENTED_7
  | 8 // OLD_VERSION_8

export type FSNotification = {
  publicTopLevelFolder: Boolean;
  filename: String;
  status: String;
  statusCode: FSStatusCode;
  notificationType: FSNotificationType;
  errorType: FSErrorType;
  params: {[key: string]: string};
}

export type FSNotificationType =
    0 // ENCRYPTING_0
  | 1 // DECRYPTING_1
  | 2 // SIGNING_2
  | 3 // VERIFYING_3
  | 4 // REKEYING_4
  | 5 // CONNECTION_5
  | 6 // MD_READ_SUCCESS_6

export type FSStatusCode =
    0 // START_0
  | 1 // FINISH_1
  | 2 // ERROR_2

export type FavoriteFavoriteAddResult = void

export type FavoriteFavoriteAddRpc = {
  method: 'favorite.favoriteAdd',
  param: {
    folder: Folder
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: FavoriteFavoriteAddResult) => void)
}

export type FavoriteFavoriteIgnoreResult = void

export type FavoriteFavoriteIgnoreRpc = {
  method: 'favorite.favoriteIgnore',
  param: {
    folder: Folder
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: FavoriteFavoriteIgnoreResult) => void)
}

export type FavoriteGetFavoritesResult = FavoritesResult

export type FavoriteGetFavoritesRpc = {
  method: 'favorite.getFavorites',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: FavoriteGetFavoritesResult) => void)
}

export type FavoritesResult = {
  favoriteFolders: Array<Folder>;
  ignoredFolders: Array<Folder>;
  newFolders: Array<Folder>;
}

export type Feature = {
  allow: Boolean;
  defaultValue: Boolean;
  readonly: Boolean;
  label: String;
}

export type FileDescriptor = {
  name: String;
  type: FileType;
}

export type FileType =
    0 // UNKNOWN_0
  | 1 // DIRECTORY_1
  | 2 // FILE_2

export type FirstStepResult = {
  valPlusTwo: Int;
}

export type Folder = {
  name: String;
  private: Boolean;
  notificationsOn: Boolean;
  created: Boolean;
}

export type ForkType =
    0 // NONE_0
  | 1 // AUTO_1
  | 2 // WATCHDOG_2
  | 3 // LAUNCHD_3

export type FuseMountInfo = {
  path: String;
  fstype: String;
  output: String;
}

export type FuseStatus = {
  version: String;
  bundleVersion: String;
  kextID: String;
  path: String;
  kextStarted: Boolean;
  installStatus: InstallStatus;
  installAction: InstallAction;
  mountInfos: Array<FuseMountInfo>;
  status: Status;
}

export type GPGKey = {
  algorithm: String;
  keyID: String;
  creation: String;
  expiration: String;
  identities: Array<PGPIdentity>;
}

export type GPGMethod =
    0 // GPG_NONE_0
  | 1 // GPG_IMPORT_1
  | 2 // GPG_SIGN_2

export type GUIEntryArg = {
  windowTitle: String;
  prompt: String;
  username: String;
  submitLabel: String;
  cancelLabel: String;
  retryLabel: String;
  type: PassphraseType;
  features: GUIEntryFeatures;
}

export type GUIEntryFeatures = {
  storeSecret: Feature;
  showTyping: Feature;
}

export type GetBlockRes = {
  blockKey: String;
  buf: Bytes;
}

export type GetCurrentStatusRes = {
  configured: Boolean;
  registered: Boolean;
  loggedIn: Boolean;
  sessionIsValid: Boolean;
  user?: ?User;
}

export type GetPassphraseRes = {
  passphrase: String;
  storeSecret: Boolean;
}

export type GpgUiConfirmDuplicateKeyChosenResult = Boolean

export type GpgUiConfirmDuplicateKeyChosenRpc = {
  method: 'gpgUi.confirmDuplicateKeyChosen',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: GpgUiConfirmDuplicateKeyChosenResult) => void)
}

export type GpgUiSelectKeyAndPushOptionResult = SelectKeyRes

export type GpgUiSelectKeyAndPushOptionRpc = {
  method: 'gpgUi.selectKeyAndPushOption',
  param: {
    keys: Array<GPGKey>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: GpgUiSelectKeyAndPushOptionResult) => void)
}

export type GpgUiSelectKeyResult = String

export type GpgUiSelectKeyRpc = {
  method: 'gpgUi.selectKey',
  param: {
    keys: Array<GPGKey>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: GpgUiSelectKeyResult) => void)
}

export type GpgUiSignResult = String

export type GpgUiSignRpc = {
  method: 'gpgUi.sign',
  param: {
    msg: Bytes,
    fingerprint: Bytes
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: GpgUiSignResult) => void)
}

export type GpgUiWantToAddGPGKeyResult = Boolean

export type GpgUiWantToAddGPGKeyRpc = {
  method: 'gpgUi.wantToAddGPGKey',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: GpgUiWantToAddGPGKeyResult) => void)
}

export type HelloRes = String

export type Identify2Res = {
  upk: UserPlusKeys;
}

export type IdentifyIdentify2Result = Identify2Res

export type IdentifyIdentify2Rpc = {
  method: 'identify.identify2',
  param: {
    uid: UID,
    userAssertion: String,
    reason: IdentifyReason,
    useDelegateUI?: Boolean,
    alwaysBlock?: Boolean,
    noErrorOnTrackFailure?: Boolean,
    forceRemoteCheck?: Boolean,
    needProofSet?: Boolean,
    allowEmptySelfID?: Boolean,
    noSkipSelf?: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyIdentify2Result) => void)
}

export type IdentifyIdentifyResult = IdentifyRes

export type IdentifyIdentifyRpc = {
  method: 'identify.identify',
  param: {
    userAssertion: String,
    forceRemoteCheck?: Boolean,
    useDelegateUI?: Boolean,
    reason: IdentifyReason,
    source: ClientType
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyIdentifyResult) => void)
}

export type IdentifyKey = {
  pgpFingerprint: Bytes;
  KID: KID;
  trackDiff?: ?TrackDiff;
  breaksTracking: Boolean;
}

export type IdentifyOutcome = {
  username: String;
  status?: ?Status;
  warnings: Array<string>;
  trackUsed?: ?TrackSummary;
  trackStatus: TrackStatus;
  numTrackFailures: Int;
  numTrackChanges: Int;
  numProofFailures: Int;
  numRevoked: Int;
  numProofSuccesses: Int;
  revoked: Array<TrackDiff>;
  trackOptions: TrackOptions;
  forPGPPull: Boolean;
  reason: IdentifyReason;
}

export type IdentifyReason = {
  type: IdentifyReasonType;
  reason: String;
  resource: String;
}

export type IdentifyReasonType =
    0 // NONE_0
  | 1 // ID_1
  | 2 // TRACK_2
  | 3 // ENCRYPT_3
  | 4 // DECRYPT_4
  | 5 // VERIFY_5
  | 6 // RESOURCE_6

export type IdentifyRes = {
  user?: ?User;
  publicKeys: Array<PublicKey>;
  outcome: IdentifyOutcome;
  trackToken: TrackToken;
}

export type IdentifyResolve2Result = User

export type IdentifyResolve2Rpc = {
  method: 'identify.Resolve2',
  param: {
    assertion: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyResolve2Result) => void)
}

export type IdentifyResolveResult = UID

export type IdentifyResolveRpc = {
  method: 'identify.Resolve',
  param: {
    assertion: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyResolveResult) => void)
}

export type IdentifyRow = {
  rowId: Int;
  proof: RemoteProof;
  trackDiff?: ?TrackDiff;
}

export type IdentifyUiConfirmResult = ConfirmResult

export type IdentifyUiConfirmRpc = {
  method: 'identifyUi.confirm',
  param: {
    outcome: IdentifyOutcome
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiConfirmResult) => void)
}

export type IdentifyUiDelegateIdentifyUIResult = Int

export type IdentifyUiDelegateIdentifyUIRpc = {
  method: 'identifyUi.delegateIdentifyUI',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDelegateIdentifyUIResult) => void)
}

export type IdentifyUiDismissResult = void

export type IdentifyUiDismissRpc = {
  method: 'identifyUi.dismiss',
  param: {
    username: String,
    reason: DismissReason
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDismissResult) => void)
}

export type IdentifyUiDisplayCryptocurrencyResult = void

export type IdentifyUiDisplayCryptocurrencyRpc = {
  method: 'identifyUi.displayCryptocurrency',
  param: {
    c: Cryptocurrency
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDisplayCryptocurrencyResult) => void)
}

export type IdentifyUiDisplayKeyResult = void

export type IdentifyUiDisplayKeyRpc = {
  method: 'identifyUi.displayKey',
  param: {
    key: IdentifyKey
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDisplayKeyResult) => void)
}

export type IdentifyUiDisplayTLFCreateWithInviteResult = void

export type IdentifyUiDisplayTLFCreateWithInviteRpc = {
  method: 'identifyUi.displayTLFCreateWithInvite',
  param: {
    folderName: String,
    isPrivate: Boolean,
    assertion: String,
    socialAssertion: SocialAssertion,
    inviteLink: String,
    throttled: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDisplayTLFCreateWithInviteResult) => void)
}

export type IdentifyUiDisplayTrackStatementResult = void

export type IdentifyUiDisplayTrackStatementRpc = {
  method: 'identifyUi.displayTrackStatement',
  param: {
    stmt: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDisplayTrackStatementResult) => void)
}

export type IdentifyUiDisplayUserCardResult = void

export type IdentifyUiDisplayUserCardRpc = {
  method: 'identifyUi.displayUserCard',
  param: {
    card: UserCard
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiDisplayUserCardResult) => void)
}

export type IdentifyUiFinishResult = void

export type IdentifyUiFinishRpc = {
  method: 'identifyUi.finish',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiFinishResult) => void)
}

export type IdentifyUiFinishSocialProofCheckResult = void

export type IdentifyUiFinishSocialProofCheckRpc = {
  method: 'identifyUi.finishSocialProofCheck',
  param: {
    rp: RemoteProof,
    lcr: LinkCheckResult
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiFinishSocialProofCheckResult) => void)
}

export type IdentifyUiFinishWebProofCheckResult = void

export type IdentifyUiFinishWebProofCheckRpc = {
  method: 'identifyUi.finishWebProofCheck',
  param: {
    rp: RemoteProof,
    lcr: LinkCheckResult
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiFinishWebProofCheckResult) => void)
}

export type IdentifyUiLaunchNetworkChecksResult = void

export type IdentifyUiLaunchNetworkChecksRpc = {
  method: 'identifyUi.launchNetworkChecks',
  param: {
    identity: Identity,
    user: User
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiLaunchNetworkChecksResult) => void)
}

export type IdentifyUiReportLastTrackResult = void

export type IdentifyUiReportLastTrackRpc = {
  method: 'identifyUi.reportLastTrack',
  param: {
    track: (null | TrackSummary)
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiReportLastTrackResult) => void)
}

export type IdentifyUiReportTrackTokenResult = void

export type IdentifyUiReportTrackTokenRpc = {
  method: 'identifyUi.reportTrackToken',
  param: {
    trackToken: TrackToken
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiReportTrackTokenResult) => void)
}

export type IdentifyUiStartResult = void

export type IdentifyUiStartRpc = {
  method: 'identifyUi.start',
  param: {
    username: String,
    reason: IdentifyReason
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: IdentifyUiStartResult) => void)
}

export type Identity = {
  status?: ?Status;
  whenLastTracked: Time;
  proofs: Array<IdentifyRow>;
  cryptocurrency: Array<Cryptocurrency>;
  revoked: Array<TrackDiff>;
  revokedDetails: Array<RevokedProof>;
  breaksTracking: Boolean;
}

export type InstallAction =
    0 // UNKNOWN_0
  | 1 // NONE_1
  | 2 // UPGRADE_2
  | 3 // REINSTALL_3
  | 4 // INSTALL_4

export type InstallResult = {
  componentResults: Array<ComponentResult>;
  status: Status;
  fatal: Boolean;
}

export type InstallStatus =
    0 // UNKNOWN_0
  | 1 // ERROR_1
  | 2 // NOT_INSTALLED_2
  | 4 // INSTALLED_4

export type KID = String

export type KbfsFSEventResult = void

export type KbfsFSEventRpc = {
  method: 'kbfs.FSEvent',
  param: {
    event: FSNotification
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: KbfsFSEventResult) => void)
}

export type Kex2ProvisioneeDidCounterSignResult = void

export type Kex2ProvisioneeDidCounterSignRpc = {
  method: 'Kex2Provisionee.didCounterSign',
  param: {
    sig: Bytes
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: Kex2ProvisioneeDidCounterSignResult) => void)
}

export type Kex2ProvisioneeHelloResult = HelloRes

export type Kex2ProvisioneeHelloRpc = {
  method: 'Kex2Provisionee.hello',
  param: {
    uid: UID,
    token: SessionToken,
    csrf: CsrfToken,
    pps: PassphraseStream,
    sigBody: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: Kex2ProvisioneeHelloResult) => void)
}

export type Kex2ProvisionerKexStartResult = void

export type Kex2ProvisionerKexStartRpc = {
  method: 'Kex2Provisioner.kexStart',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: Kex2ProvisionerKexStartResult) => void)
}

export type KeyHalf = {
  user: UID;
  deviceKID: KID;
  key: Bytes;
}

export type KeyInfo = {
  fingerprint: String;
  key: String;
  desc: String;
}

export type KeybaseTime = {
  unix: Time;
  chain: Int;
}

export type LinkCheckResult = {
  proofId: Int;
  proofResult: ProofResult;
  snoozedResult: ProofResult;
  torWarning: Boolean;
  tmpTrackExpireTime: Time;
  cached?: ?CheckResult;
  diff?: ?TrackDiff;
  remoteDiff?: ?TrackDiff;
  hint?: ?SigHint;
  breaksTracking: Boolean;
}

export type LogLevel =
    0 // NONE_0
  | 1 // DEBUG_1
  | 2 // INFO_2
  | 3 // NOTICE_3
  | 4 // WARN_4
  | 5 // ERROR_5
  | 6 // CRITICAL_6
  | 7 // FATAL_7

export type LogRegisterLoggerResult = void

export type LogRegisterLoggerRpc = {
  method: 'log.registerLogger',
  param: {
    name: String,
    level: LogLevel
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LogRegisterLoggerResult) => void)
}

export type LogUiLogResult = void

export type LogUiLogRpc = {
  method: 'logUi.log',
  param: {
    level: LogLevel,
    text: Text
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LogUiLogResult) => void)
}

export type LoginClearStoredSecretResult = void

export type LoginClearStoredSecretRpc = {
  method: 'login.clearStoredSecret',
  param: {
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginClearStoredSecretResult) => void)
}

export type LoginDeprovisionResult = void

export type LoginDeprovisionRpc = {
  method: 'login.deprovision',
  param: {
    username: String,
    doRevoke: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginDeprovisionResult) => void)
}

export type LoginGetConfiguredAccountsResult = Array<ConfiguredAccount>

export type LoginGetConfiguredAccountsRpc = {
  method: 'login.getConfiguredAccounts',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginGetConfiguredAccountsResult) => void)
}

export type LoginLoginResult = void

export type LoginLoginRpc = {
  method: 'login.login',
  param: {
    deviceType: String,
    usernameOrEmail: String,
    clientType: ClientType
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginLoginResult) => void)
}

export type LoginLogoutResult = void

export type LoginLogoutRpc = {
  method: 'login.logout',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginLogoutResult) => void)
}

export type LoginPaperKeyResult = void

export type LoginPaperKeyRpc = {
  method: 'login.paperKey',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginPaperKeyResult) => void)
}

export type LoginRecoverAccountFromEmailAddressResult = void

export type LoginRecoverAccountFromEmailAddressRpc = {
  method: 'login.recoverAccountFromEmailAddress',
  param: {
    email: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginRecoverAccountFromEmailAddressResult) => void)
}

export type LoginUiDisplayPaperKeyPhraseResult = void

export type LoginUiDisplayPaperKeyPhraseRpc = {
  method: 'loginUi.displayPaperKeyPhrase',
  param: {
    phrase: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginUiDisplayPaperKeyPhraseResult) => void)
}

export type LoginUiDisplayPrimaryPaperKeyResult = void

export type LoginUiDisplayPrimaryPaperKeyRpc = {
  method: 'loginUi.displayPrimaryPaperKey',
  param: {
    phrase: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginUiDisplayPrimaryPaperKeyResult) => void)
}

export type LoginUiGetEmailOrUsernameResult = String

export type LoginUiGetEmailOrUsernameRpc = {
  method: 'loginUi.getEmailOrUsername',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginUiGetEmailOrUsernameResult) => void)
}

export type LoginUiPromptRevokePaperKeysResult = Boolean

export type LoginUiPromptRevokePaperKeysRpc = {
  method: 'loginUi.promptRevokePaperKeys',
  param: {
    device: Device,
    index: Int
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginUiPromptRevokePaperKeysResult) => void)
}

export type LoginUnlockResult = void

export type LoginUnlockRpc = {
  method: 'login.unlock',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginUnlockResult) => void)
}

export type LoginUnlockWithPassphraseResult = void

export type LoginUnlockWithPassphraseRpc = {
  method: 'login.unlockWithPassphrase',
  param: {
    passphrase: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: LoginUnlockWithPassphraseResult) => void)
}

export type MDBlock = {
  version: Int;
  timestamp: Time;
  block: Bytes;
}

export type MerkleRoot = {
  version: Int;
  root: Bytes;
}

export type MerkleTreeID =
    0 // MASTER_0
  | 1 // KBFS_PUBLIC_1
  | 2 // KBFS_PRIVATE_2

export type MetadataAuthenticateResult = Int

export type MetadataAuthenticateRpc = {
  method: 'metadata.authenticate',
  param: {
    signature: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataAuthenticateResult) => void)
}

export type MetadataDeleteKeyResult = void

export type MetadataDeleteKeyRpc = {
  method: 'metadata.deleteKey',
  param: {
    uid: UID,
    deviceKID: KID,
    keyHalfID: Bytes,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataDeleteKeyResult) => void)
}

export type MetadataGetChallengeResult = ChallengeInfo

export type MetadataGetChallengeRpc = {
  method: 'metadata.getChallenge',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetChallengeResult) => void)
}

export type MetadataGetFolderHandleResult = Bytes

export type MetadataGetFolderHandleRpc = {
  method: 'metadata.getFolderHandle',
  param: {
    folderID: String,
    signature: String,
    challenge: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetFolderHandleResult) => void)
}

export type MetadataGetFoldersForRekeyResult = void

export type MetadataGetFoldersForRekeyRpc = {
  method: 'metadata.getFoldersForRekey',
  param: {
    deviceKID: KID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetFoldersForRekeyResult) => void)
}

export type MetadataGetKeyResult = Bytes

export type MetadataGetKeyRpc = {
  method: 'metadata.getKey',
  param: {
    keyHalfID: Bytes,
    deviceKID: String,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetKeyResult) => void)
}

export type MetadataGetLatestFolderHandleResult = Bytes

export type MetadataGetLatestFolderHandleRpc = {
  method: 'metadata.getLatestFolderHandle',
  param: {
    folderID: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetLatestFolderHandleResult) => void)
}

export type MetadataGetMerkleNodeResult = Bytes

export type MetadataGetMerkleNodeRpc = {
  method: 'metadata.getMerkleNode',
  param: {
    hash: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetMerkleNodeResult) => void)
}

export type MetadataGetMerkleRootLatestResult = MerkleRoot

export type MetadataGetMerkleRootLatestRpc = {
  method: 'metadata.getMerkleRootLatest',
  param: {
    treeID: MerkleTreeID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetMerkleRootLatestResult) => void)
}

export type MetadataGetMerkleRootResult = MerkleRoot

export type MetadataGetMerkleRootRpc = {
  method: 'metadata.getMerkleRoot',
  param: {
    treeID: MerkleTreeID,
    seqNo: Long
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetMerkleRootResult) => void)
}

export type MetadataGetMerkleRootSinceResult = MerkleRoot

export type MetadataGetMerkleRootSinceRpc = {
  method: 'metadata.getMerkleRootSince',
  param: {
    treeID: MerkleTreeID,
    when: Time
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetMerkleRootSinceResult) => void)
}

export type MetadataGetMetadataResult = MetadataResponse

export type MetadataGetMetadataRpc = {
  method: 'metadata.getMetadata',
  param: {
    folderID: String,
    folderHandle: Bytes,
    branchID: String,
    unmerged: Boolean,
    startRevision: Long,
    stopRevision: Long,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataGetMetadataResult) => void)
}

export type MetadataPingResult = void

export type MetadataPingRpc = {
  method: 'metadata.ping',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataPingResult) => void)
}

export type MetadataPruneBranchResult = void

export type MetadataPruneBranchRpc = {
  method: 'metadata.pruneBranch',
  param: {
    folderID: String,
    branchID: String,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataPruneBranchResult) => void)
}

export type MetadataPutKeysResult = void

export type MetadataPutKeysRpc = {
  method: 'metadata.putKeys',
  param: {
    keyHalves: Array<KeyHalf>,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataPutKeysResult) => void)
}

export type MetadataPutMetadataResult = void

export type MetadataPutMetadataRpc = {
  method: 'metadata.putMetadata',
  param: {
    mdBlock: MDBlock,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataPutMetadataResult) => void)
}

export type MetadataRegisterForUpdatesResult = void

export type MetadataRegisterForUpdatesRpc = {
  method: 'metadata.registerForUpdates',
  param: {
    folderID: String,
    currRevision: Long,
    logTags: {[key: string]: string}
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataRegisterForUpdatesResult) => void)
}

export type MetadataResponse = {
  folderID: String;
  mdBlocks: Array<MDBlock>;
}

export type MetadataTruncateLockResult = Boolean

export type MetadataTruncateLockRpc = {
  method: 'metadata.truncateLock',
  param: {
    folderID: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataTruncateLockResult) => void)
}

export type MetadataTruncateUnlockResult = Boolean

export type MetadataTruncateUnlockRpc = {
  method: 'metadata.truncateUnlock',
  param: {
    folderID: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataTruncateUnlockResult) => void)
}

export type MetadataUpdateFolderNeedsRekeyResult = void

export type MetadataUpdateFolderNeedsRekeyRpc = {
  method: 'metadataUpdate.folderNeedsRekey',
  param: {
    folderID: String,
    revision: Long
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataUpdateFolderNeedsRekeyResult) => void)
}

export type MetadataUpdateMetadataUpdateResult = void

export type MetadataUpdateMetadataUpdateRpc = {
  method: 'metadataUpdate.metadataUpdate',
  param: {
    folderID: String,
    revision: Long
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: MetadataUpdateMetadataUpdateResult) => void)
}

export type NaclDHKeyPrivate = any

export type NaclDHKeyPublic = any

export type NaclSigningKeyPrivate = any

export type NaclSigningKeyPublic = any

export type NotificationChannels = {
  session: Boolean;
  users: Boolean;
  kbfs: Boolean;
  tracking: Boolean;
  favorites: Boolean;
}

export type NotifyCtlSetNotificationsResult = void

export type NotifyCtlSetNotificationsRpc = {
  method: 'notifyCtl.setNotifications',
  param: {
    channels: NotificationChannels
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifyCtlSetNotificationsResult) => void)
}

export type NotifyFSFSActivityResult = void

export type NotifyFSFSActivityRpc = {
  method: 'NotifyFS.FSActivity',
  param: {
    notification: FSNotification
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifyFSFSActivityResult) => void)
}

export type NotifyFavoritesFavoritesChangedResult = void

export type NotifyFavoritesFavoritesChangedRpc = {
  method: 'NotifyFavorites.favoritesChanged',
  param: {
    uid: UID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifyFavoritesFavoritesChangedResult) => void)
}

export type NotifySessionClientOutOfDateResult = void

export type NotifySessionClientOutOfDateRpc = {
  method: 'NotifySession.clientOutOfDate',
  param: {
    upgradeTo: String,
    upgradeURI: String,
    upgradeMsg: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifySessionClientOutOfDateResult) => void)
}

export type NotifySessionLoggedInResult = void

export type NotifySessionLoggedInRpc = {
  method: 'NotifySession.loggedIn',
  param: {
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifySessionLoggedInResult) => void)
}

export type NotifySessionLoggedOutResult = void

export type NotifySessionLoggedOutRpc = {
  method: 'NotifySession.loggedOut',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifySessionLoggedOutResult) => void)
}

export type NotifyTrackingTrackingChangedResult = void

export type NotifyTrackingTrackingChangedRpc = {
  method: 'NotifyTracking.trackingChanged',
  param: {
    uid: UID,
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifyTrackingTrackingChangedResult) => void)
}

export type NotifyUsersUserChangedResult = void

export type NotifyUsersUserChangedRpc = {
  method: 'NotifyUsers.userChanged',
  param: {
    uid: UID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: NotifyUsersUserChangedResult) => void)
}

export type Outcome =
    0 // NONE_0
  | 1 // FIXED_1
  | 2 // IGNORED_2

export type PGPCreateUids = {
  useDefault: Boolean;
  ids: Array<PGPIdentity>;
}

export type PGPDecryptOptions = {
  assertSigned: Boolean;
  signedBy: String;
}

export type PGPEncryptOptions = {
  recipients: Array<string>;
  noSign: Boolean;
  noSelf: Boolean;
  binaryOut: Boolean;
  keyQuery: String;
}

export type PGPIdentity = {
  username: String;
  comment: String;
  email: String;
}

export type PGPQuery = {
  secret: Boolean;
  query: String;
  exactMatch: Boolean;
}

export type PGPSigVerification = {
  isSigned: Boolean;
  verified: Boolean;
  signer: User;
  signKey: PublicKey;
}

export type PGPSignOptions = {
  keyQuery: String;
  mode: SignMode;
  binaryIn: Boolean;
  binaryOut: Boolean;
}

export type PGPVerifyOptions = {
  signedBy: String;
  signature: Bytes;
}

export type PaperprovisionPaperProvisionResult = void

export type PaperprovisionPaperProvisionRpc = {
  method: 'paperprovision.paperProvision',
  param: {
    username: String,
    deviceName: String,
    paperKey: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PaperprovisionPaperProvisionResult) => void)
}

export type PassphraseStream = {
  passphraseStream: Bytes;
  generation: Int;
}

export type PassphraseType =
    0 // NONE_0
  | 1 // PAPER_KEY_1
  | 2 // PASS_PHRASE_2
  | 3 // VERIFY_PASS_PHRASE_3

export type PgpPgpDecryptResult = PGPSigVerification

export type PgpPgpDecryptRpc = {
  method: 'pgp.pgpDecrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: PGPDecryptOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpDecryptResult) => void)
}

export type PgpPgpDeletePrimaryResult = void

export type PgpPgpDeletePrimaryRpc = {
  method: 'pgp.pgpDeletePrimary',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpDeletePrimaryResult) => void)
}

export type PgpPgpEncryptResult = void

export type PgpPgpEncryptRpc = {
  method: 'pgp.pgpEncrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: PGPEncryptOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpEncryptResult) => void)
}

export type PgpPgpExportByFingerprintResult = Array<KeyInfo>

export type PgpPgpExportByFingerprintRpc = {
  method: 'pgp.pgpExportByFingerprint',
  param: {
    options: PGPQuery
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpExportByFingerprintResult) => void)
}

export type PgpPgpExportByKIDResult = Array<KeyInfo>

export type PgpPgpExportByKIDRpc = {
  method: 'pgp.pgpExportByKID',
  param: {
    options: PGPQuery
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpExportByKIDResult) => void)
}

export type PgpPgpExportResult = Array<KeyInfo>

export type PgpPgpExportRpc = {
  method: 'pgp.pgpExport',
  param: {
    options: PGPQuery
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpExportResult) => void)
}

export type PgpPgpImportResult = void

export type PgpPgpImportRpc = {
  method: 'pgp.pgpImport',
  param: {
    key: Bytes,
    pushSecret: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpImportResult) => void)
}

export type PgpPgpKeyGenResult = void

export type PgpPgpKeyGenRpc = {
  method: 'pgp.pgpKeyGen',
  param: {
    primaryBits: Int,
    subkeyBits: Int,
    createUids: PGPCreateUids,
    allowMulti: Boolean,
    doExport: Boolean,
    pushSecret: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpKeyGenResult) => void)
}

export type PgpPgpPullResult = void

export type PgpPgpPullRpc = {
  method: 'pgp.pgpPull',
  param: {
    userAsserts: Array<string>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpPullResult) => void)
}

export type PgpPgpSelectResult = void

export type PgpPgpSelectRpc = {
  method: 'pgp.pgpSelect',
  param: {
    fingerprintQuery: String,
    allowMulti: Boolean,
    skipImport: Boolean,
    onlyImport: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpSelectResult) => void)
}

export type PgpPgpSignResult = void

export type PgpPgpSignRpc = {
  method: 'pgp.pgpSign',
  param: {
    source: Stream,
    sink: Stream,
    opts: PGPSignOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpSignResult) => void)
}

export type PgpPgpUpdateResult = void

export type PgpPgpUpdateRpc = {
  method: 'pgp.pgpUpdate',
  param: {
    all: Boolean,
    fingerprints: Array<string>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpUpdateResult) => void)
}

export type PgpPgpVerifyResult = PGPSigVerification

export type PgpPgpVerifyRpc = {
  method: 'pgp.pgpVerify',
  param: {
    source: Stream,
    opts: PGPVerifyOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpPgpVerifyResult) => void)
}

export type PgpUiOutputSignatureSuccessResult = void

export type PgpUiOutputSignatureSuccessRpc = {
  method: 'pgpUi.outputSignatureSuccess',
  param: {
    fingerprint: String,
    username: String,
    signedAt: Time
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: PgpUiOutputSignatureSuccessResult) => void)
}

export type PlatformInfo = {
  os: String;
  arch: String;
  goVersion: String;
}

export type ProblemSet = {
  user: User;
  kid: KID;
  tlfs: Array<ProblemTLF>;
}

export type ProblemSetDevices = {
  problemSet: ProblemSet;
  devices: Array<Device>;
}

export type ProblemTLF = {
  tlf: TLF;
  score: Int;
  solutions: Array<KID>;
}

export type Process = {
  pid: String;
  command: String;
  fileDescriptors: Array<FileDescriptor>;
}

export type PromptDefault =
    0 // NONE_0
  | 1 // YES_1
  | 2 // NO_2

export type PromptOverwriteType =
    0 // SOCIAL_0
  | 1 // SITE_1

export type ProofResult = {
  state: ProofState;
  status: ProofStatus;
  desc: String;
}

export type ProofState =
    0 // NONE_0
  | 1 // OK_1
  | 2 // TEMP_FAILURE_2
  | 3 // PERM_FAILURE_3
  | 4 // LOOKING_4
  | 5 // SUPERSEDED_5
  | 6 // POSTED_6
  | 7 // REVOKED_7

export type ProofStatus =
    0 // NONE_0
  | 1 // OK_1
  | 2 // LOCAL_2
  | 3 // FOUND_3
  | 100 // BASE_ERROR_100
  | 101 // HOST_UNREACHABLE_101
  | 103 // PERMISSION_DENIED_103
  | 106 // FAILED_PARSE_106
  | 107 // DNS_ERROR_107
  | 108 // AUTH_FAILED_108
  | 129 // HTTP_429_129
  | 150 // HTTP_500_150
  | 160 // TIMEOUT_160
  | 170 // INTERNAL_ERROR_170
  | 200 // BASE_HARD_ERROR_200
  | 201 // NOT_FOUND_201
  | 202 // CONTENT_FAILURE_202
  | 203 // BAD_USERNAME_203
  | 204 // BAD_REMOTE_ID_204
  | 205 // TEXT_NOT_FOUND_205
  | 206 // BAD_ARGS_206
  | 207 // CONTENT_MISSING_207
  | 208 // TITLE_NOT_FOUND_208
  | 209 // SERVICE_ERROR_209
  | 210 // TOR_SKIPPED_210
  | 211 // TOR_INCOMPATIBLE_211
  | 230 // HTTP_300_230
  | 240 // HTTP_400_240
  | 260 // HTTP_OTHER_260
  | 270 // EMPTY_JSON_270
  | 301 // DELETED_301
  | 302 // SERVICE_DEAD_302
  | 303 // BAD_SIGNATURE_303
  | 304 // BAD_API_URL_304
  | 305 // UNKNOWN_TYPE_305
  | 306 // NO_HINT_306
  | 307 // BAD_HINT_TEXT_307

export type ProofType =
    0 // NONE_0
  | 1 // KEYBASE_1
  | 2 // TWITTER_2
  | 3 // GITHUB_3
  | 4 // REDDIT_4
  | 5 // COINBASE_5
  | 6 // HACKERNEWS_6
  | 1000 // GENERIC_WEB_SITE_1000
  | 1001 // DNS_1001
  | 1002 // PGP_1002
  | 100001 // ROOTER_100001

export type Proofs = {
  social: Array<TrackProof>;
  web: Array<WebProof>;
  publicKeys: Array<PublicKey>;
}

export type ProveCheckProofResult = CheckProofStatus

export type ProveCheckProofRpc = {
  method: 'prove.checkProof',
  param: {
    sigID: SigID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveCheckProofResult) => void)
}

export type ProveStartProofResult = StartProofResult

export type ProveStartProofRpc = {
  method: 'prove.startProof',
  param: {
    service: String,
    username: String,
    force: Boolean,
    promptPosted: Boolean,
    auto: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveStartProofResult) => void)
}

export type ProveUiDisplayRecheckWarningResult = void

export type ProveUiDisplayRecheckWarningRpc = {
  method: 'proveUi.displayRecheckWarning',
  param: {
    text: Text
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiDisplayRecheckWarningResult) => void)
}

export type ProveUiOkToCheckResult = Boolean

export type ProveUiOkToCheckRpc = {
  method: 'proveUi.okToCheck',
  param: {
    name: String,
    attempt: Int
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiOkToCheckResult) => void)
}

export type ProveUiOutputInstructionsResult = void

export type ProveUiOutputInstructionsRpc = {
  method: 'proveUi.outputInstructions',
  param: {
    instructions: Text,
    proof: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiOutputInstructionsResult) => void)
}

export type ProveUiOutputPrechecksResult = void

export type ProveUiOutputPrechecksRpc = {
  method: 'proveUi.outputPrechecks',
  param: {
    text: Text
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiOutputPrechecksResult) => void)
}

export type ProveUiPreProofWarningResult = Boolean

export type ProveUiPreProofWarningRpc = {
  method: 'proveUi.preProofWarning',
  param: {
    text: Text
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiPreProofWarningResult) => void)
}

export type ProveUiPromptOverwriteResult = Boolean

export type ProveUiPromptOverwriteRpc = {
  method: 'proveUi.promptOverwrite',
  param: {
    account: String,
    typ: PromptOverwriteType
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiPromptOverwriteResult) => void)
}

export type ProveUiPromptUsernameResult = String

export type ProveUiPromptUsernameRpc = {
  method: 'proveUi.promptUsername',
  param: {
    prompt: String,
    prevError: (null | Status)
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProveUiPromptUsernameResult) => void)
}

export type ProvisionMethod =
    0 // DEVICE_0
  | 1 // PAPER_KEY_1
  | 2 // PASSPHRASE_2
  | 3 // GPG_IMPORT_3
  | 4 // GPG_SIGN_4

export type ProvisionUiChooseDeviceResult = DeviceID

export type ProvisionUiChooseDeviceRpc = {
  method: 'provisionUi.chooseDevice',
  param: {
    devices: Array<Device>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiChooseDeviceResult) => void)
}

export type ProvisionUiChooseDeviceTypeResult = DeviceType

export type ProvisionUiChooseDeviceTypeRpc = {
  method: 'provisionUi.chooseDeviceType',
  param: {
    kind: ChooseType
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiChooseDeviceTypeResult) => void)
}

export type ProvisionUiChooseGPGMethodResult = GPGMethod

export type ProvisionUiChooseGPGMethodRpc = {
  method: 'provisionUi.chooseGPGMethod',
  param: {
    keys: Array<GPGKey>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiChooseGPGMethodResult) => void)
}

export type ProvisionUiChooseProvisioningMethodResult = ProvisionMethod

export type ProvisionUiChooseProvisioningMethodRpc = {
  method: 'provisionUi.chooseProvisioningMethod',
  param: {
    gpgOption: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiChooseProvisioningMethodResult) => void)
}

export type ProvisionUiDisplayAndPromptSecretResult = SecretResponse

export type ProvisionUiDisplayAndPromptSecretRpc = {
  method: 'provisionUi.DisplayAndPromptSecret',
  param: {
    secret: Bytes,
    phrase: String,
    otherDeviceType: DeviceType
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiDisplayAndPromptSecretResult) => void)
}

export type ProvisionUiDisplaySecretExchangedResult = void

export type ProvisionUiDisplaySecretExchangedRpc = {
  method: 'provisionUi.DisplaySecretExchanged',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiDisplaySecretExchangedResult) => void)
}

export type ProvisionUiPromptNewDeviceNameResult = String

export type ProvisionUiPromptNewDeviceNameRpc = {
  method: 'provisionUi.PromptNewDeviceName',
  param: {
    existingDevices: Array<string>,
    errorMessage: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiPromptNewDeviceNameResult) => void)
}

export type ProvisionUiProvisioneeSuccessResult = void

export type ProvisionUiProvisioneeSuccessRpc = {
  method: 'provisionUi.ProvisioneeSuccess',
  param: {
    username: String,
    deviceName: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiProvisioneeSuccessResult) => void)
}

export type ProvisionUiProvisionerSuccessResult = void

export type ProvisionUiProvisionerSuccessRpc = {
  method: 'provisionUi.ProvisionerSuccess',
  param: {
    deviceName: String,
    deviceType: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiProvisionerSuccessResult) => void)
}

export type ProvisionUiSwitchToGPGSignOKResult = Boolean

export type ProvisionUiSwitchToGPGSignOKRpc = {
  method: 'provisionUi.switchToGPGSignOK',
  param: {
    key: GPGKey,
    importError: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: ProvisionUiSwitchToGPGSignOKResult) => void)
}

export type PublicKey = {
  KID: KID;
  PGPFingerprint: String;
  PGPIdentities: Array<PGPIdentity>;
  isSibkey: Boolean;
  isEldest: Boolean;
  parentID: String;
  deviceID: DeviceID;
  deviceDescription: String;
  deviceType: String;
  cTime: Time;
  eTime: Time;
}

export type QuotaVerifySessionResult = VerifySessionRes

export type QuotaVerifySessionRpc = {
  method: 'quota.verifySession',
  param: {
    session: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: QuotaVerifySessionResult) => void)
}

export type RekeyGetProblemSetResult = ProblemSetDevices

export type RekeyGetProblemSetRpc = {
  method: 'rekey.getProblemSet',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RekeyGetProblemSetResult) => void)
}

export type RekeyRekeyStatusFinishResult = Outcome

export type RekeyRekeyStatusFinishRpc = {
  method: 'rekey.rekeyStatusFinish',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RekeyRekeyStatusFinishResult) => void)
}

export type RekeyShowPendingRekeyStatusResult = void

export type RekeyShowPendingRekeyStatusRpc = {
  method: 'rekey.showPendingRekeyStatus',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RekeyShowPendingRekeyStatusResult) => void)
}

export type RekeyShowRekeyStatusResult = void

export type RekeyShowRekeyStatusRpc = {
  method: 'rekey.showRekeyStatus',
  param: {
    tlfs: Array<TLFID>,
    user: (null | UID),
    kid: (null | KID)
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RekeyShowRekeyStatusResult) => void)
}

export type RekeyUIDelegateRekeyUIResult = Int

export type RekeyUIDelegateRekeyUIRpc = {
  method: 'rekeyUI.delegateRekeyUI',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RekeyUIDelegateRekeyUIResult) => void)
}

export type RekeyUIRefreshResult = void

export type RekeyUIRefreshRpc = {
  method: 'rekeyUI.refresh',
  param: {
    problemSetDevices: ProblemSetDevices
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RekeyUIRefreshResult) => void)
}

export type RemoteProof = {
  proofType: ProofType;
  key: String;
  value: String;
  displayMarkup: String;
  sigID: SigID;
  mTime: Time;
}

export type RevokeRevokeDeviceResult = void

export type RevokeRevokeDeviceRpc = {
  method: 'revoke.revokeDevice',
  param: {
    deviceID: DeviceID,
    force: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RevokeRevokeDeviceResult) => void)
}

export type RevokeRevokeKeyResult = void

export type RevokeRevokeKeyRpc = {
  method: 'revoke.revokeKey',
  param: {
    keyID: KID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RevokeRevokeKeyResult) => void)
}

export type RevokeRevokeSigsResult = void

export type RevokeRevokeSigsRpc = {
  method: 'revoke.revokeSigs',
  param: {
    sigIDQueries: Array<string>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: RevokeRevokeSigsResult) => void)
}

export type RevokedKey = {
  key: PublicKey;
  time: KeybaseTime;
}

export type RevokedProof = {
  proof: RemoteProof;
  diff: TrackDiff;
}

export type SaltpackDecryptOptions = {
  interactive: Boolean;
  forceRemoteCheck: Boolean;
  usePaperKey: Boolean;
}

export type SaltpackEncryptOptions = {
  recipients: Array<string>;
  hideSelf: Boolean;
  noSelfEncrypt: Boolean;
  binary: Boolean;
  hideRecipients: Boolean;
}

export type SaltpackEncryptedMessageInfo = {
  devices: Array<Device>;
  numAnonReceivers: Int;
  receiverIsAnon: Boolean;
}

export type SaltpackSaltpackDecryptResult = SaltpackEncryptedMessageInfo

export type SaltpackSaltpackDecryptRpc = {
  method: 'saltpack.saltpackDecrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackDecryptOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SaltpackSaltpackDecryptResult) => void)
}

export type SaltpackSaltpackEncryptResult = void

export type SaltpackSaltpackEncryptRpc = {
  method: 'saltpack.saltpackEncrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackEncryptOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SaltpackSaltpackEncryptResult) => void)
}

export type SaltpackSaltpackSignResult = void

export type SaltpackSaltpackSignRpc = {
  method: 'saltpack.saltpackSign',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackSignOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SaltpackSaltpackSignResult) => void)
}

export type SaltpackSaltpackVerifyResult = void

export type SaltpackSaltpackVerifyRpc = {
  method: 'saltpack.saltpackVerify',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackVerifyOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SaltpackSaltpackVerifyResult) => void)
}

export type SaltpackSender = {
  uid: UID;
  username: String;
  senderType: SaltpackSenderType;
}

export type SaltpackSenderType =
    0 // NOT_TRACKED_0
  | 1 // UNKNOWN_1
  | 2 // ANONYMOUS_2
  | 3 // TRACKING_BROKE_3
  | 4 // TRACKING_OK_4
  | 5 // SELF_5

export type SaltpackSignOptions = {
  detached: Boolean;
  binary: Boolean;
}

export type SaltpackUiSaltpackPromptForDecryptResult = void

export type SaltpackUiSaltpackPromptForDecryptRpc = {
  method: 'saltpackUi.saltpackPromptForDecrypt',
  param: {
    sender: SaltpackSender
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SaltpackUiSaltpackPromptForDecryptResult) => void)
}

export type SaltpackUiSaltpackVerifySuccessResult = void

export type SaltpackUiSaltpackVerifySuccessRpc = {
  method: 'saltpackUi.saltpackVerifySuccess',
  param: {
    signingKID: KID,
    sender: SaltpackSender
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SaltpackUiSaltpackVerifySuccessResult) => void)
}

export type SaltpackVerifyOptions = {
  signedBy: String;
  signature: Bytes;
}

export type SearchComponent = {
  key: String;
  value: String;
  score: Double;
}

export type SearchResult = {
  uid: UID;
  username: String;
  components: Array<SearchComponent>;
  score: Double;
}

export type SecretEntryArg = {
  desc: String;
  prompt: String;
  err: String;
  cancel: String;
  ok: String;
  reason: String;
  useSecretStore: Boolean;
}

export type SecretEntryRes = {
  text: String;
  canceled: Boolean;
  storeSecret: Boolean;
}

export type SecretKeys = {
  signing: NaclSigningKeyPrivate;
  encryption: NaclDHKeyPrivate;
}

export type SecretKeysGetSecretKeysResult = SecretKeys

export type SecretKeysGetSecretKeysRpc = {
  method: 'SecretKeys.getSecretKeys',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SecretKeysGetSecretKeysResult) => void)
}

export type SecretResponse = {
  secret: Bytes;
  phrase: String;
}

export type SecretUiGetPassphraseResult = GetPassphraseRes

export type SecretUiGetPassphraseRpc = {
  method: 'secretUi.getPassphrase',
  param: {
    pinentry: GUIEntryArg,
    terminal: (null | SecretEntryArg)
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SecretUiGetPassphraseResult) => void)
}

export type SelectKeyRes = {
  keyID: String;
  doSecretPush: Boolean;
}

export type ServiceStatus = {
  version: String;
  label: String;
  pid: String;
  lastExitStatus: String;
  bundleVersion: String;
  installStatus: InstallStatus;
  installAction: InstallAction;
  status: Status;
}

export type ServicesStatus = {
  service: Array<ServiceStatus>;
  kbfs: Array<ServiceStatus>;
  updater: Array<ServiceStatus>;
}

export type Session = {
  uid: UID;
  username: String;
  token: String;
  deviceSubkeyKid: KID;
  deviceSibkeyKid: KID;
}

export type SessionCurrentSessionResult = Session

export type SessionCurrentSessionRpc = {
  method: 'session.currentSession',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SessionCurrentSessionResult) => void)
}

export type SessionStatus = {
  SessionFor: String;
  Loaded: Boolean;
  Cleared: Boolean;
  SaltOnly: Boolean;
  Expired: Boolean;
}

export type SessionToken = String

export type Sig = {
  seqno: Int;
  sigID: SigID;
  sigIDDisplay: String;
  type: String;
  cTime: Time;
  revoked: Boolean;
  active: Boolean;
  key: String;
  body: String;
}

export type SigHint = {
  remoteId: String;
  humanUrl: String;
  apiUrl: String;
  checkText: String;
}

export type SigID = String

export type SigListArgs = {
  sessionID: Int;
  username: String;
  allKeys: Boolean;
  types?: ?SigTypes;
  filterx: String;
  verbose: Boolean;
  revoked: Boolean;
}

export type SigTypes = {
  track: Boolean;
  proof: Boolean;
  cryptocurrency: Boolean;
  isSelf: Boolean;
}

export type SignMode =
    0 // ATTACHED_0
  | 1 // DETACHED_1
  | 2 // CLEAR_2

export type SignupCheckInvitationCodeResult = void

export type SignupCheckInvitationCodeRpc = {
  method: 'signup.checkInvitationCode',
  param: {
    invitationCode: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SignupCheckInvitationCodeResult) => void)
}

export type SignupCheckUsernameAvailableResult = void

export type SignupCheckUsernameAvailableRpc = {
  method: 'signup.checkUsernameAvailable',
  param: {
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SignupCheckUsernameAvailableResult) => void)
}

export type SignupInviteRequestResult = void

export type SignupInviteRequestRpc = {
  method: 'signup.inviteRequest',
  param: {
    email: String,
    fullname: String,
    notes: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SignupInviteRequestResult) => void)
}

export type SignupRes = {
  passphraseOk: Boolean;
  postOk: Boolean;
  writeOk: Boolean;
}

export type SignupSignupResult = SignupRes

export type SignupSignupRpc = {
  method: 'signup.signup',
  param: {
    email: String,
    inviteCode: String,
    passphrase: String,
    username: String,
    deviceName: String,
    storeSecret: Boolean,
    skipMail: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SignupSignupResult) => void)
}

export type SigsSigListJSONResult = String

export type SigsSigListJSONRpc = {
  method: 'sigs.sigListJSON',
  param: {
    arg: SigListArgs
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SigsSigListJSONResult) => void)
}

export type SigsSigListResult = Array<Sig>

export type SigsSigListRpc = {
  method: 'sigs.sigList',
  param: {
    arg: SigListArgs
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: SigsSigListResult) => void)
}

export type SocialAssertion = {
  user: String;
  service: SocialAssertionService;
}

export type SocialAssertionService = String

export type StartProofResult = {
  sigID: SigID;
}

export type Status = {
  code: Int;
  name: String;
  desc: String;
  fields: Array<StringKVPair>;
}

export type StatusCode =
    0 // SCOk_0
  | 201 // SCLoginRequired_201
  | 202 // SCBadSession_202
  | 203 // SCBadLoginUserNotFound_203
  | 204 // SCBadLoginPassword_204
  | 205 // SCNotFound_205
  | 210 // SCThrottleControl_210
  | 218 // SCGeneric_218
  | 235 // SCAlreadyLoggedIn_235
  | 237 // SCCanceled_237
  | 239 // SCInputCanceled_239
  | 274 // SCReloginRequired_274
  | 275 // SCResolutionFailed_275
  | 276 // SCProfileNotPublic_276
  | 277 // SCIdentifyFailed_277
  | 278 // SCTrackingBroke_278
  | 279 // SCWrongCryptoFormat_279
  | 280 // SCDecryptionError_280
  | 701 // SCBadSignupUsernameTaken_701
  | 707 // SCBadInvitationCode_707
  | 801 // SCMissingResult_801
  | 901 // SCKeyNotFound_901
  | 907 // SCKeyInUse_907
  | 913 // SCKeyBadGen_913
  | 914 // SCKeyNoSecret_914
  | 915 // SCKeyBadUIDs_915
  | 916 // SCKeyNoActive_916
  | 917 // SCKeyNoSig_917
  | 918 // SCKeyBadSig_918
  | 919 // SCKeyBadEldest_919
  | 920 // SCKeyNoEldest_920
  | 921 // SCKeyDuplicateUpdate_921
  | 922 // SCSibkeyAlreadyExists_922
  | 924 // SCDecryptionKeyNotFound_924
  | 927 // SCKeyNoPGPEncryption_927
  | 928 // SCKeyNoNaClEncryption_928
  | 929 // SCKeySyncedPGPNotFound_929
  | 930 // SCKeyNoMatchingGPG_930
  | 1301 // SCBadTrackSession_1301
  | 1409 // SCDeviceNotFound_1409
  | 1410 // SCDeviceMismatch_1410
  | 1411 // SCDeviceRequired_1411
  | 1413 // SCDevicePrevProvisioned_1413
  | 1414 // SCDeviceNoProvision_1414
  | 1501 // SCStreamExists_1501
  | 1502 // SCStreamNotFound_1502
  | 1503 // SCStreamWrongKind_1503
  | 1504 // SCStreamEOF_1504
  | 1601 // SCAPINetworkError_1601
  | 1602 // SCTimeout_1602
  | 1701 // SCProofError_1701
  | 1702 // SCIdentificationExpired_1702
  | 1703 // SCSelfNotFound_1703
  | 1704 // SCBadKexPhrase_1704
  | 1705 // SCNoUIDelegation_1705
  | 1706 // SCNoUI_1706
  | 1707 // SCGPGUnavailable_1707
  | 1800 // SCInvalidVersionError_1800
  | 1801 // SCOldVersionError_1801
  | 1802 // SCInvalidLocationError_1802
  | 1803 // SCServiceStatusError_1803
  | 1804 // SCInstallError_1804

export type Stream = {
  fd: Int;
}

export type StreamUiCloseResult = void

export type StreamUiCloseRpc = {
  method: 'streamUi.close',
  param: {
    s: Stream
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: StreamUiCloseResult) => void)
}

export type StreamUiReadResult = Bytes

export type StreamUiReadRpc = {
  method: 'streamUi.read',
  param: {
    s: Stream,
    sz: Int
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: StreamUiReadResult) => void)
}

export type StreamUiWriteResult = Int

export type StreamUiWriteRpc = {
  method: 'streamUi.write',
  param: {
    s: Stream,
    buf: Bytes
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: StreamUiWriteResult) => void)
}

export type StringKVPair = {
  key: String;
  value: String;
}

export type TLF = {
  tlfid: TLFID;
  name: String;
  writers: Array<string>;
  readers: Array<string>;
  isPrivate: Boolean;
}

export type TLFID = String

export type Test = {
  reply: String;
}

export type TestPanicResult = void

export type TestPanicRpc = {
  method: 'test.panic',
  param: {
    message: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TestPanicResult) => void)
}

export type TestTestCallbackResult = String

export type TestTestCallbackRpc = {
  method: 'test.testCallback',
  param: {
    name: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TestTestCallbackResult) => void)
}

export type TestTestResult = Test

export type TestTestRpc = {
  method: 'test.test',
  param: {
    name: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TestTestResult) => void)
}

export type Text = {
  data: String;
  markup: Boolean;
}

export type Time = Long

export type TrackCheckTrackingResult = void

export type TrackCheckTrackingRpc = {
  method: 'track.checkTracking',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TrackCheckTrackingResult) => void)
}

export type TrackDiff = {
  type: TrackDiffType;
  displayMarkup: String;
}

export type TrackDiffType =
    0 // NONE_0
  | 1 // ERROR_1
  | 2 // CLASH_2
  | 3 // REVOKED_3
  | 4 // UPGRADED_4
  | 5 // NEW_5
  | 6 // REMOTE_FAIL_6
  | 7 // REMOTE_WORKING_7
  | 8 // REMOTE_CHANGED_8
  | 9 // NEW_ELDEST_9
  | 10 // NONE_VIA_TEMPORARY_10

export type TrackDismissWithTokenResult = void

export type TrackDismissWithTokenRpc = {
  method: 'track.dismissWithToken',
  param: {
    trackToken: TrackToken
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TrackDismissWithTokenResult) => void)
}

export type TrackFakeTrackingChangedResult = void

export type TrackFakeTrackingChangedRpc = {
  method: 'track.fakeTrackingChanged',
  param: {
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TrackFakeTrackingChangedResult) => void)
}

export type TrackOptions = {
  localOnly: Boolean;
  bypassConfirm: Boolean;
  forceRetrack: Boolean;
  expiringLocal: Boolean;
}

export type TrackProof = {
  proofType: String;
  proofName: String;
  idString: String;
}

export type TrackStatus =
    1 // NEW_OK_1
  | 2 // NEW_ZERO_PROOFS_2
  | 3 // NEW_FAIL_PROOFS_3
  | 4 // UPDATE_BROKEN_FAILED_PROOFS_4
  | 5 // UPDATE_NEW_PROOFS_5
  | 6 // UPDATE_OK_6
  | 7 // UPDATE_BROKEN_REVOKED_7

export type TrackSummary = {
  username: String;
  time: Time;
  isRemote: Boolean;
}

export type TrackToken = String

export type TrackTrackResult = void

export type TrackTrackRpc = {
  method: 'track.track',
  param: {
    userAssertion: String,
    options: TrackOptions,
    forceRemoteCheck: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TrackTrackResult) => void)
}

export type TrackTrackWithTokenResult = void

export type TrackTrackWithTokenRpc = {
  method: 'track.trackWithToken',
  param: {
    trackToken: TrackToken,
    options: TrackOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TrackTrackWithTokenResult) => void)
}

export type TrackUntrackResult = void

export type TrackUntrackRpc = {
  method: 'track.untrack',
  param: {
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: TrackUntrackResult) => void)
}

export type Tracker = {
  tracker: UID;
  status: Int;
  mTime: Time;
}

export type UID = String

export type UiPromptYesNoResult = Boolean

export type UiPromptYesNoRpc = {
  method: 'ui.promptYesNo',
  param: {
    text: Text,
    promptDefault: PromptDefault
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UiPromptYesNoResult) => void)
}

export type UnboxAnyRes = {
  kid: KID;
  plaintext: Bytes32;
  index: Int;
}

export type UninstallResult = {
  componentResults: Array<ComponentResult>;
  status: Status;
}

export type Update = {
  version: String;
  name: String;
  description: String;
  instructions?: ?String;
  type: UpdateType;
  publishedAt?: ?Time;
  asset?: ?Asset;
}

export type UpdateAction =
    0 // UPDATE_0
  | 1 // SKIP_1
  | 2 // SNOOZE_2
  | 3 // CANCEL_3

export type UpdateAppInUseAction =
    0 // CANCEL_0
  | 1 // FORCE_1
  | 2 // SNOOZE_2
  | 3 // KILL_PROCESSES_3

export type UpdateAppInUseRes = {
  action: UpdateAppInUseAction;
}

export type UpdateOptions = {
  version: String;
  platform: String;
  destinationPath: String;
  source: String;
  URL: String;
  channel: String;
  force: Boolean;
  defaultInstructions: String;
  signaturePath: String;
}

export type UpdatePromptOptions = {
  alwaysAutoInstall: Boolean;
}

export type UpdatePromptRes = {
  action: UpdateAction;
  alwaysAutoInstall: Boolean;
  snoozeUntil: Time;
}

export type UpdateQuitRes = {
  quit: Boolean;
  pid: Int;
  applicationPath: String;
}

export type UpdateResult = {
  update?: ?Update;
}

export type UpdateType =
    0 // NORMAL_0
  | 1 // BUGFIX_1
  | 2 // CRITICAL_2

export type UpdateUiUpdateAppInUseResult = UpdateAppInUseRes

export type UpdateUiUpdateAppInUseRpc = {
  method: 'updateUi.updateAppInUse',
  param: {
    update: Update,
    processes: Array<Process>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UpdateUiUpdateAppInUseResult) => void)
}

export type UpdateUiUpdatePromptResult = UpdatePromptRes

export type UpdateUiUpdatePromptRpc = {
  method: 'updateUi.updatePrompt',
  param: {
    update: Update,
    options: UpdatePromptOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UpdateUiUpdatePromptResult) => void)
}

export type UpdateUiUpdateQuitResult = UpdateQuitRes

export type UpdateUiUpdateQuitRpc = {
  method: 'updateUi.updateQuit',
  param: {
    update: Update,
    status: Status
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UpdateUiUpdateQuitResult) => void)
}

export type UpdateUpdateCheckResult = void

export type UpdateUpdateCheckRpc = {
  method: 'update.updateCheck',
  param: {
    force: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UpdateUpdateCheckResult) => void)
}

export type UpdateUpdateResult = UpdateResult

export type UpdateUpdateRpc = {
  method: 'update.update',
  param: {
    options: UpdateOptions
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UpdateUpdateResult) => void)
}

export type User = {
  uid: UID;
  username: String;
}

export type UserCard = {
  following: Int;
  followers: Int;
  uid: UID;
  fullName: String;
  location: String;
  bio: String;
  website: String;
  twitter: String;
  youFollowThem: Boolean;
  theyFollowYou: Boolean;
}

export type UserListTrackersByNameResult = Array<Tracker>

export type UserListTrackersByNameRpc = {
  method: 'user.listTrackersByName',
  param: {
    username: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserListTrackersByNameResult) => void)
}

export type UserListTrackersResult = Array<Tracker>

export type UserListTrackersRpc = {
  method: 'user.listTrackers',
  param: {
    uid: UID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserListTrackersResult) => void)
}

export type UserListTrackersSelfResult = Array<Tracker>

export type UserListTrackersSelfRpc = {
  method: 'user.listTrackersSelf',
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserListTrackersSelfResult) => void)
}

export type UserListTrackingJSONResult = String

export type UserListTrackingJSONRpc = {
  method: 'user.listTrackingJSON',
  param: {
    filter: String,
    verbose: Boolean
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserListTrackingJSONResult) => void)
}

export type UserListTrackingResult = Array<UserSummary>

export type UserListTrackingRpc = {
  method: 'user.listTracking',
  param: {
    filter: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserListTrackingResult) => void)
}

export type UserLoadPublicKeysResult = Array<PublicKey>

export type UserLoadPublicKeysRpc = {
  method: 'user.loadPublicKeys',
  param: {
    uid: UID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserLoadPublicKeysResult) => void)
}

export type UserLoadUncheckedUserSummariesResult = Array<UserSummary>

export type UserLoadUncheckedUserSummariesRpc = {
  method: 'user.loadUncheckedUserSummaries',
  param: {
    uids: Array<UID>
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserLoadUncheckedUserSummariesResult) => void)
}

export type UserLoadUserPlusKeysResult = UserPlusKeys

export type UserLoadUserPlusKeysRpc = {
  method: 'user.loadUserPlusKeys',
  param: {
    uid: UID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserLoadUserPlusKeysResult) => void)
}

export type UserLoadUserResult = User

export type UserLoadUserRpc = {
  method: 'user.loadUser',
  param: {
    uid: UID
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserLoadUserResult) => void)
}

export type UserPlusKeys = {
  uid: UID;
  username: String;
  deviceKeys: Array<PublicKey>;
  revokedDeviceKeys: Array<RevokedKey>;
  pgpKeyCount: Int;
  uvv: UserVersionVector;
}

export type UserResolution = {
  assertion: SocialAssertion;
  userID: UID;
}

export type UserSearchResult = Array<SearchResult>

export type UserSearchRpc = {
  method: 'user.search',
  param: {
    query: String
  },
  incomingCallMap?: IncomingCallMapType,
  callback: (null | (err: ?any, response: UserSearchResult) => void)
}

export type UserSummary = {
  uid: UID;
  username: String;
  thumbnail: String;
  idVersion: Int;
  fullName: String;
  bio: String;
  proofs: Proofs;
  sigIDDisplay: String;
  trackTime: Time;
}

export type UserVersionVector = {
  id: Long;
  sigHints: Int;
  sigChain: Long;
  cachedAt: Time;
  lastIdentifiedAt: Time;
}

export type VerifySessionRes = {
  uid: UID;
  sid: String;
  generated: Int;
  lifetime: Int;
}

export type WebProof = {
  hostname: String;
  protocols: Array<string>;
}

export type Rpc =
    AccountPassphraseChangeRpc
  | AccountPassphrasePromptRpc
  | BTCRegisterBTCRpc
  | BlockAddReferenceRpc
  | BlockArchiveReferenceRpc
  | BlockArchiveReferenceWithCountRpc
  | BlockAuthenticateSessionRpc
  | BlockDelReferenceRpc
  | BlockDelReferenceWithCountRpc
  | BlockGetBlockRpc
  | BlockGetSessionChallengeRpc
  | BlockGetUserQuotaInfoRpc
  | BlockPutBlockRpc
  | ConfigClearValueRpc
  | ConfigGetConfigRpc
  | ConfigGetCurrentStatusRpc
  | ConfigGetExtendedStatusRpc
  | ConfigGetValueRpc
  | ConfigHelloIAmRpc
  | ConfigSetPathRpc
  | ConfigSetUserConfigRpc
  | ConfigSetValueRpc
  | CryptoSignED25519Rpc
  | CryptoSignToStringRpc
  | CryptoUnboxBytes32AnyRpc
  | CryptoUnboxBytes32Rpc
  | CtlDbNukeRpc
  | CtlLogRotateRpc
  | CtlReloadRpc
  | CtlStopRpc
  | DebuggingFirstStepRpc
  | DebuggingIncrementRpc
  | DebuggingSecondStepRpc
  | DelegateUiCtlRegisterIdentifyUIRpc
  | DelegateUiCtlRegisterRekeyUIRpc
  | DelegateUiCtlRegisterSecretUIRpc
  | DelegateUiCtlRegisterUpdateUIRpc
  | DeviceCheckDeviceNameFormatRpc
  | DeviceDeviceAddRpc
  | DeviceDeviceHistoryListRpc
  | DeviceDeviceListRpc
  | FavoriteFavoriteAddRpc
  | FavoriteFavoriteIgnoreRpc
  | FavoriteGetFavoritesRpc
  | GpgUiConfirmDuplicateKeyChosenRpc
  | GpgUiSelectKeyAndPushOptionRpc
  | GpgUiSelectKeyRpc
  | GpgUiSignRpc
  | GpgUiWantToAddGPGKeyRpc
  | IdentifyIdentify2Rpc
  | IdentifyIdentifyRpc
  | IdentifyResolve2Rpc
  | IdentifyResolveRpc
  | IdentifyUiConfirmRpc
  | IdentifyUiDelegateIdentifyUIRpc
  | IdentifyUiDismissRpc
  | IdentifyUiDisplayCryptocurrencyRpc
  | IdentifyUiDisplayKeyRpc
  | IdentifyUiDisplayTLFCreateWithInviteRpc
  | IdentifyUiDisplayTrackStatementRpc
  | IdentifyUiDisplayUserCardRpc
  | IdentifyUiFinishRpc
  | IdentifyUiFinishSocialProofCheckRpc
  | IdentifyUiFinishWebProofCheckRpc
  | IdentifyUiLaunchNetworkChecksRpc
  | IdentifyUiReportLastTrackRpc
  | IdentifyUiReportTrackTokenRpc
  | IdentifyUiStartRpc
  | KbfsFSEventRpc
  | Kex2ProvisioneeDidCounterSignRpc
  | Kex2ProvisioneeHelloRpc
  | Kex2ProvisionerKexStartRpc
  | LogRegisterLoggerRpc
  | LogUiLogRpc
  | LoginClearStoredSecretRpc
  | LoginDeprovisionRpc
  | LoginGetConfiguredAccountsRpc
  | LoginLoginRpc
  | LoginLogoutRpc
  | LoginPaperKeyRpc
  | LoginRecoverAccountFromEmailAddressRpc
  | LoginUiDisplayPaperKeyPhraseRpc
  | LoginUiDisplayPrimaryPaperKeyRpc
  | LoginUiGetEmailOrUsernameRpc
  | LoginUiPromptRevokePaperKeysRpc
  | LoginUnlockRpc
  | LoginUnlockWithPassphraseRpc
  | MetadataAuthenticateRpc
  | MetadataDeleteKeyRpc
  | MetadataGetChallengeRpc
  | MetadataGetFolderHandleRpc
  | MetadataGetFoldersForRekeyRpc
  | MetadataGetKeyRpc
  | MetadataGetLatestFolderHandleRpc
  | MetadataGetMerkleNodeRpc
  | MetadataGetMerkleRootLatestRpc
  | MetadataGetMerkleRootRpc
  | MetadataGetMerkleRootSinceRpc
  | MetadataGetMetadataRpc
  | MetadataPingRpc
  | MetadataPruneBranchRpc
  | MetadataPutKeysRpc
  | MetadataPutMetadataRpc
  | MetadataRegisterForUpdatesRpc
  | MetadataTruncateLockRpc
  | MetadataTruncateUnlockRpc
  | MetadataUpdateFolderNeedsRekeyRpc
  | MetadataUpdateMetadataUpdateRpc
  | NotifyCtlSetNotificationsRpc
  | NotifyFSFSActivityRpc
  | NotifyFavoritesFavoritesChangedRpc
  | NotifySessionClientOutOfDateRpc
  | NotifySessionLoggedInRpc
  | NotifySessionLoggedOutRpc
  | NotifyTrackingTrackingChangedRpc
  | NotifyUsersUserChangedRpc
  | PaperprovisionPaperProvisionRpc
  | PgpPgpDecryptRpc
  | PgpPgpDeletePrimaryRpc
  | PgpPgpEncryptRpc
  | PgpPgpExportByFingerprintRpc
  | PgpPgpExportByKIDRpc
  | PgpPgpExportRpc
  | PgpPgpImportRpc
  | PgpPgpKeyGenRpc
  | PgpPgpPullRpc
  | PgpPgpSelectRpc
  | PgpPgpSignRpc
  | PgpPgpUpdateRpc
  | PgpPgpVerifyRpc
  | PgpUiOutputSignatureSuccessRpc
  | ProveCheckProofRpc
  | ProveStartProofRpc
  | ProveUiDisplayRecheckWarningRpc
  | ProveUiOkToCheckRpc
  | ProveUiOutputInstructionsRpc
  | ProveUiOutputPrechecksRpc
  | ProveUiPreProofWarningRpc
  | ProveUiPromptOverwriteRpc
  | ProveUiPromptUsernameRpc
  | ProvisionUiChooseDeviceRpc
  | ProvisionUiChooseDeviceTypeRpc
  | ProvisionUiChooseGPGMethodRpc
  | ProvisionUiChooseProvisioningMethodRpc
  | ProvisionUiDisplayAndPromptSecretRpc
  | ProvisionUiDisplaySecretExchangedRpc
  | ProvisionUiPromptNewDeviceNameRpc
  | ProvisionUiProvisioneeSuccessRpc
  | ProvisionUiProvisionerSuccessRpc
  | ProvisionUiSwitchToGPGSignOKRpc
  | QuotaVerifySessionRpc
  | RekeyGetProblemSetRpc
  | RekeyRekeyStatusFinishRpc
  | RekeyShowPendingRekeyStatusRpc
  | RekeyShowRekeyStatusRpc
  | RekeyUIDelegateRekeyUIRpc
  | RekeyUIRefreshRpc
  | RevokeRevokeDeviceRpc
  | RevokeRevokeKeyRpc
  | RevokeRevokeSigsRpc
  | SaltpackSaltpackDecryptRpc
  | SaltpackSaltpackEncryptRpc
  | SaltpackSaltpackSignRpc
  | SaltpackSaltpackVerifyRpc
  | SaltpackUiSaltpackPromptForDecryptRpc
  | SaltpackUiSaltpackVerifySuccessRpc
  | SecretKeysGetSecretKeysRpc
  | SecretUiGetPassphraseRpc
  | SessionCurrentSessionRpc
  | SignupCheckInvitationCodeRpc
  | SignupCheckUsernameAvailableRpc
  | SignupInviteRequestRpc
  | SignupSignupRpc
  | SigsSigListJSONRpc
  | SigsSigListRpc
  | StreamUiCloseRpc
  | StreamUiReadRpc
  | StreamUiWriteRpc
  | TestPanicRpc
  | TestTestCallbackRpc
  | TestTestRpc
  | TrackCheckTrackingRpc
  | TrackDismissWithTokenRpc
  | TrackFakeTrackingChangedRpc
  | TrackTrackRpc
  | TrackTrackWithTokenRpc
  | TrackUntrackRpc
  | UiPromptYesNoRpc
  | UpdateUiUpdateAppInUseRpc
  | UpdateUiUpdatePromptRpc
  | UpdateUiUpdateQuitRpc
  | UpdateUpdateCheckRpc
  | UpdateUpdateRpc
  | UserListTrackersByNameRpc
  | UserListTrackersRpc
  | UserListTrackersSelfRpc
  | UserListTrackingJSONRpc
  | UserListTrackingRpc
  | UserLoadPublicKeysRpc
  | UserLoadUncheckedUserSummariesRpc
  | UserLoadUserPlusKeysRpc
  | UserLoadUserRpc
  | UserSearchRpc

export type IncomingCallMapType = {
  'keybase.1.account.passphraseChange'?: (
    params: {
      sessionID: Int,
      oldPassphrase: String,
      passphrase: String,
      force: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.account.passphrasePrompt'?: (
    params: {
      sessionID: Int,
      guiArg: GUIEntryArg
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: AccountPassphrasePromptResult) => void
    }
  ) => void,
  'keybase.1.block.getSessionChallenge'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: BlockGetSessionChallengeResult) => void
    }
  ) => void,
  'keybase.1.block.authenticateSession'?: (
    params: {
      signature: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.putBlock'?: (
    params: {
      bid: BlockIdCombo,
      folder: String,
      blockKey: String,
      buf: Bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.getBlock'?: (
    params: {
      bid: BlockIdCombo,
      folder: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: BlockGetBlockResult) => void
    }
  ) => void,
  'keybase.1.block.addReference'?: (
    params: {
      folder: String,
      ref: BlockReference
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.delReference'?: (
    params: {
      folder: String,
      ref: BlockReference
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.archiveReference'?: (
    params: {
      folder: String,
      refs: Array<BlockReference>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: BlockArchiveReferenceResult) => void
    }
  ) => void,
  'keybase.1.block.delReferenceWithCount'?: (
    params: {
      folder: String,
      refs: Array<BlockReference>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: BlockDelReferenceWithCountResult) => void
    }
  ) => void,
  'keybase.1.block.archiveReferenceWithCount'?: (
    params: {
      folder: String,
      refs: Array<BlockReference>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: BlockArchiveReferenceWithCountResult) => void
    }
  ) => void,
  'keybase.1.block.getUserQuotaInfo'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: BlockGetUserQuotaInfoResult) => void
    }
  ) => void,
  'keybase.1.BTC.registerBTC'?: (
    params: {
      sessionID: Int,
      address: String,
      force: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.getCurrentStatus'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ConfigGetCurrentStatusResult) => void
    }
  ) => void,
  'keybase.1.config.getExtendedStatus'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ConfigGetExtendedStatusResult) => void
    }
  ) => void,
  'keybase.1.config.getConfig'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ConfigGetConfigResult) => void
    }
  ) => void,
  'keybase.1.config.setUserConfig'?: (
    params: {
      sessionID: Int,
      username: String,
      key: String,
      value: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.setPath'?: (
    params: {
      sessionID: Int,
      path: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.helloIAm'?: (
    params: {
      details: ClientDetails
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.setValue'?: (
    params: {
      path: String,
      value: ConfigValue
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.clearValue'?: (
    params: {
      path: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.getValue'?: (
    params: {
      path: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ConfigGetValueResult) => void
    }
  ) => void,
  'keybase.1.crypto.signED25519'?: (
    params: {
      sessionID: Int,
      msg: Bytes,
      reason: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: CryptoSignED25519Result) => void
    }
  ) => void,
  'keybase.1.crypto.signToString'?: (
    params: {
      sessionID: Int,
      msg: Bytes,
      reason: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: CryptoSignToStringResult) => void
    }
  ) => void,
  'keybase.1.crypto.unboxBytes32'?: (
    params: {
      sessionID: Int,
      encryptedBytes32: EncryptedBytes32,
      nonce: BoxNonce,
      peersPublicKey: BoxPublicKey,
      reason: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: CryptoUnboxBytes32Result) => void
    }
  ) => void,
  'keybase.1.crypto.unboxBytes32Any'?: (
    params: {
      sessionID: Int,
      bundles: Array<CiphertextBundle>,
      reason: String,
      promptPaper: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: CryptoUnboxBytes32AnyResult) => void
    }
  ) => void,
  'keybase.1.ctl.stop'?: (
    params: {
      sessionID: Int,
      exitCode: ExitCode
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ctl.logRotate'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ctl.reload'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ctl.dbNuke'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.debugging.firstStep'?: (
    params: {
      sessionID: Int,
      val: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: DebuggingFirstStepResult) => void
    }
  ) => void,
  'keybase.1.debugging.secondStep'?: (
    params: {
      sessionID: Int,
      val: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: DebuggingSecondStepResult) => void
    }
  ) => void,
  'keybase.1.debugging.increment'?: (
    params: {
      sessionID: Int,
      val: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: DebuggingIncrementResult) => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerIdentifyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerSecretUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerUpdateUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerRekeyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.device.deviceList'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: DeviceDeviceListResult) => void
    }
  ) => void,
  'keybase.1.device.deviceHistoryList'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: DeviceDeviceHistoryListResult) => void
    }
  ) => void,
  'keybase.1.device.deviceAdd'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.device.checkDeviceNameFormat'?: (
    params: {
      sessionID: Int,
      name: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: DeviceCheckDeviceNameFormatResult) => void
    }
  ) => void,
  'keybase.1.favorite.favoriteAdd'?: (
    params: {
      sessionID: Int,
      folder: Folder
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.favorite.favoriteIgnore'?: (
    params: {
      sessionID: Int,
      folder: Folder
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.favorite.getFavorites'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: FavoriteGetFavoritesResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.wantToAddGPGKey'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: GpgUiWantToAddGPGKeyResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.confirmDuplicateKeyChosen'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: GpgUiConfirmDuplicateKeyChosenResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.selectKeyAndPushOption'?: (
    params: {
      sessionID: Int,
      keys: Array<GPGKey>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: GpgUiSelectKeyAndPushOptionResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.selectKey'?: (
    params: {
      sessionID: Int,
      keys: Array<GPGKey>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: GpgUiSelectKeyResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.sign'?: (
    params: {
      msg: Bytes,
      fingerprint: Bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: GpgUiSignResult) => void
    }
  ) => void,
  'keybase.1.identify.Resolve'?: (
    params: {
      assertion: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: IdentifyResolveResult) => void
    }
  ) => void,
  'keybase.1.identify.Resolve2'?: (
    params: {
      assertion: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: IdentifyResolve2Result) => void
    }
  ) => void,
  'keybase.1.identify.identify'?: (
    params: {
      sessionID: Int,
      userAssertion: String,
      forceRemoteCheck?: Boolean,
      useDelegateUI?: Boolean,
      reason: IdentifyReason,
      source: ClientType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: IdentifyIdentifyResult) => void
    }
  ) => void,
  'keybase.1.identify.identify2'?: (
    params: {
      sessionID: Int,
      uid: UID,
      userAssertion: String,
      reason: IdentifyReason,
      useDelegateUI?: Boolean,
      alwaysBlock?: Boolean,
      noErrorOnTrackFailure?: Boolean,
      forceRemoteCheck?: Boolean,
      needProofSet?: Boolean,
      allowEmptySelfID?: Boolean,
      noSkipSelf?: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: IdentifyIdentify2Result) => void
    }
  ) => void,
  'keybase.1.identifyUi.displayTLFCreateWithInvite'?: (
    params: {
      sessionID: Int,
      folderName: String,
      isPrivate: Boolean,
      assertion: String,
      socialAssertion: SocialAssertion,
      inviteLink: String,
      throttled: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.delegateIdentifyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: IdentifyUiDelegateIdentifyUIResult) => void
    }
  ) => void,
  'keybase.1.identifyUi.start'?: (
    params: {
      sessionID: Int,
      username: String,
      reason: IdentifyReason
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayKey'?: (
    params: {
      sessionID: Int,
      key: IdentifyKey
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.reportLastTrack'?: (
    params: {
      sessionID: Int,
      track: (null | TrackSummary)
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.launchNetworkChecks'?: (
    params: {
      sessionID: Int,
      identity: Identity,
      user: User
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayTrackStatement'?: (
    params: {
      sessionID: Int,
      stmt: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.finishWebProofCheck'?: (
    params: {
      sessionID: Int,
      rp: RemoteProof,
      lcr: LinkCheckResult
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.finishSocialProofCheck'?: (
    params: {
      sessionID: Int,
      rp: RemoteProof,
      lcr: LinkCheckResult
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayCryptocurrency'?: (
    params: {
      sessionID: Int,
      c: Cryptocurrency
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.reportTrackToken'?: (
    params: {
      sessionID: Int,
      trackToken: TrackToken
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayUserCard'?: (
    params: {
      sessionID: Int,
      card: UserCard
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.confirm'?: (
    params: {
      sessionID: Int,
      outcome: IdentifyOutcome
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: IdentifyUiConfirmResult) => void
    }
  ) => void,
  'keybase.1.identifyUi.finish'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.dismiss'?: (
    params: {
      sessionID: Int,
      username: String,
      reason: DismissReason
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.kbfs.FSEvent'?: (
    params: {
      event: FSNotification
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.Kex2Provisionee.hello'?: (
    params: {
      uid: UID,
      token: SessionToken,
      csrf: CsrfToken,
      pps: PassphraseStream,
      sigBody: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: Kex2ProvisioneeHelloResult) => void
    }
  ) => void,
  'keybase.1.Kex2Provisionee.didCounterSign'?: (
    params: {
      sig: Bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.Kex2Provisioner.kexStart'?: (
    params: {} /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.log.registerLogger'?: (
    params: {
      sessionID: Int,
      name: String,
      level: LogLevel
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.logUi.log'?: (
    params: {
      sessionID: Int,
      level: LogLevel,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.getConfiguredAccounts'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: LoginGetConfiguredAccountsResult) => void
    }
  ) => void,
  'keybase.1.login.login'?: (
    params: {
      sessionID: Int,
      deviceType: String,
      usernameOrEmail: String,
      clientType: ClientType
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.clearStoredSecret'?: (
    params: {
      sessionID: Int,
      username: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.logout'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.deprovision'?: (
    params: {
      sessionID: Int,
      username: String,
      doRevoke: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.recoverAccountFromEmailAddress'?: (
    params: {
      email: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.paperKey'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.unlock'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.unlockWithPassphrase'?: (
    params: {
      sessionID: Int,
      passphrase: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.loginUi.getEmailOrUsername'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: LoginUiGetEmailOrUsernameResult) => void
    }
  ) => void,
  'keybase.1.loginUi.promptRevokePaperKeys'?: (
    params: {
      sessionID: Int,
      device: Device,
      index: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: LoginUiPromptRevokePaperKeysResult) => void
    }
  ) => void,
  'keybase.1.loginUi.displayPaperKeyPhrase'?: (
    params: {
      sessionID: Int,
      phrase: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.loginUi.displayPrimaryPaperKey'?: (
    params: {
      sessionID: Int,
      phrase: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getChallenge'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetChallengeResult) => void
    }
  ) => void,
  'keybase.1.metadata.authenticate'?: (
    params: {
      signature: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataAuthenticateResult) => void
    }
  ) => void,
  'keybase.1.metadata.putMetadata'?: (
    params: {
      mdBlock: MDBlock,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getMetadata'?: (
    params: {
      folderID: String,
      folderHandle: Bytes,
      branchID: String,
      unmerged: Boolean,
      startRevision: Long,
      stopRevision: Long,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetMetadataResult) => void
    }
  ) => void,
  'keybase.1.metadata.registerForUpdates'?: (
    params: {
      folderID: String,
      currRevision: Long,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.pruneBranch'?: (
    params: {
      folderID: String,
      branchID: String,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.putKeys'?: (
    params: {
      keyHalves: Array<KeyHalf>,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getKey'?: (
    params: {
      keyHalfID: Bytes,
      deviceKID: String,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetKeyResult) => void
    }
  ) => void,
  'keybase.1.metadata.deleteKey'?: (
    params: {
      uid: UID,
      deviceKID: KID,
      keyHalfID: Bytes,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.truncateLock'?: (
    params: {
      folderID: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataTruncateLockResult) => void
    }
  ) => void,
  'keybase.1.metadata.truncateUnlock'?: (
    params: {
      folderID: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataTruncateUnlockResult) => void
    }
  ) => void,
  'keybase.1.metadata.getFolderHandle'?: (
    params: {
      folderID: String,
      signature: String,
      challenge: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetFolderHandleResult) => void
    }
  ) => void,
  'keybase.1.metadata.getFoldersForRekey'?: (
    params: {
      deviceKID: KID
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.ping'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getLatestFolderHandle'?: (
    params: {
      folderID: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetLatestFolderHandleResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleRoot'?: (
    params: {
      treeID: MerkleTreeID,
      seqNo: Long
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetMerkleRootResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleRootLatest'?: (
    params: {
      treeID: MerkleTreeID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetMerkleRootLatestResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleRootSince'?: (
    params: {
      treeID: MerkleTreeID,
      when: Time
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetMerkleRootSinceResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleNode'?: (
    params: {
      hash: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: MetadataGetMerkleNodeResult) => void
    }
  ) => void,
  'keybase.1.metadataUpdate.metadataUpdate'?: (
    params: {
      folderID: String,
      revision: Long
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadataUpdate.folderNeedsRekey'?: (
    params: {
      folderID: String,
      revision: Long
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.notifyCtl.setNotifications'?: (
    params: {
      channels: NotificationChannels
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifyFavorites.favoritesChanged'?: (
    params: {
      uid: UID
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyFS.FSActivity'?: (
    params: {
      notification: FSNotification
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifySession.loggedOut'?: (
    params: {} /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifySession.loggedIn'?: (
    params: {
      username: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifySession.clientOutOfDate'?: (
    params: {
      upgradeTo: String,
      upgradeURI: String,
      upgradeMsg: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifyTracking.trackingChanged'?: (
    params: {
      uid: UID,
      username: String
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyUsers.userChanged'?: (
    params: {
      uid: UID
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.paperprovision.paperProvision'?: (
    params: {
      sessionID: Int,
      username: String,
      deviceName: String,
      paperKey: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpSign'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: PGPSignOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpPull'?: (
    params: {
      sessionID: Int,
      userAsserts: Array<string>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpEncrypt'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: PGPEncryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpDecrypt'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: PGPDecryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: PgpPgpDecryptResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpVerify'?: (
    params: {
      sessionID: Int,
      source: Stream,
      opts: PGPVerifyOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: PgpPgpVerifyResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpImport'?: (
    params: {
      sessionID: Int,
      key: Bytes,
      pushSecret: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpExport'?: (
    params: {
      sessionID: Int,
      options: PGPQuery
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: PgpPgpExportResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpExportByFingerprint'?: (
    params: {
      sessionID: Int,
      options: PGPQuery
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: PgpPgpExportByFingerprintResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpExportByKID'?: (
    params: {
      sessionID: Int,
      options: PGPQuery
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: PgpPgpExportByKIDResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpKeyGen'?: (
    params: {
      sessionID: Int,
      primaryBits: Int,
      subkeyBits: Int,
      createUids: PGPCreateUids,
      allowMulti: Boolean,
      doExport: Boolean,
      pushSecret: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpDeletePrimary'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpSelect'?: (
    params: {
      sessionID: Int,
      fingerprintQuery: String,
      allowMulti: Boolean,
      skipImport: Boolean,
      onlyImport: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpUpdate'?: (
    params: {
      sessionID: Int,
      all: Boolean,
      fingerprints: Array<string>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgpUi.outputSignatureSuccess'?: (
    params: {
      sessionID: Int,
      fingerprint: String,
      username: String,
      signedAt: Time
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.prove.startProof'?: (
    params: {
      sessionID: Int,
      service: String,
      username: String,
      force: Boolean,
      promptPosted: Boolean,
      auto: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProveStartProofResult) => void
    }
  ) => void,
  'keybase.1.prove.checkProof'?: (
    params: {
      sessionID: Int,
      sigID: SigID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProveCheckProofResult) => void
    }
  ) => void,
  'keybase.1.proveUi.promptOverwrite'?: (
    params: {
      sessionID: Int,
      account: String,
      typ: PromptOverwriteType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProveUiPromptOverwriteResult) => void
    }
  ) => void,
  'keybase.1.proveUi.promptUsername'?: (
    params: {
      sessionID: Int,
      prompt: String,
      prevError: (null | Status)
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProveUiPromptUsernameResult) => void
    }
  ) => void,
  'keybase.1.proveUi.outputPrechecks'?: (
    params: {
      sessionID: Int,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.proveUi.preProofWarning'?: (
    params: {
      sessionID: Int,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProveUiPreProofWarningResult) => void
    }
  ) => void,
  'keybase.1.proveUi.outputInstructions'?: (
    params: {
      sessionID: Int,
      instructions: Text,
      proof: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.proveUi.okToCheck'?: (
    params: {
      sessionID: Int,
      name: String,
      attempt: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProveUiOkToCheckResult) => void
    }
  ) => void,
  'keybase.1.proveUi.displayRecheckWarning'?: (
    params: {
      sessionID: Int,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseProvisioningMethod'?: (
    params: {
      sessionID: Int,
      gpgOption: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiChooseProvisioningMethodResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseGPGMethod'?: (
    params: {
      sessionID: Int,
      keys: Array<GPGKey>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiChooseGPGMethodResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.switchToGPGSignOK'?: (
    params: {
      sessionID: Int,
      key: GPGKey,
      importError: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiSwitchToGPGSignOKResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseDevice'?: (
    params: {
      sessionID: Int,
      devices: Array<Device>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiChooseDeviceResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseDeviceType'?: (
    params: {
      sessionID: Int,
      kind: ChooseType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiChooseDeviceTypeResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.DisplayAndPromptSecret'?: (
    params: {
      sessionID: Int,
      secret: Bytes,
      phrase: String,
      otherDeviceType: DeviceType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiDisplayAndPromptSecretResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.DisplaySecretExchanged'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.provisionUi.PromptNewDeviceName'?: (
    params: {
      sessionID: Int,
      existingDevices: Array<string>,
      errorMessage: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: ProvisionUiPromptNewDeviceNameResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.ProvisioneeSuccess'?: (
    params: {
      sessionID: Int,
      username: String,
      deviceName: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.provisionUi.ProvisionerSuccess'?: (
    params: {
      sessionID: Int,
      deviceName: String,
      deviceType: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.quota.verifySession'?: (
    params: {
      session: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: QuotaVerifySessionResult) => void
    }
  ) => void,
  'keybase.1.rekey.showPendingRekeyStatus'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.rekey.showRekeyStatus'?: (
    params: {
      sessionID: Int,
      tlfs: Array<TLFID>,
      user: (null | UID),
      kid: (null | KID)
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.rekey.getProblemSet'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: RekeyGetProblemSetResult) => void
    }
  ) => void,
  'keybase.1.rekey.rekeyStatusFinish'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: RekeyRekeyStatusFinishResult) => void
    }
  ) => void,
  'keybase.1.rekeyUI.delegateRekeyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: RekeyUIDelegateRekeyUIResult) => void
    }
  ) => void,
  'keybase.1.rekeyUI.refresh'?: (
    params: {
      sessionID: Int,
      problemSetDevices: ProblemSetDevices
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.revoke.revokeKey'?: (
    params: {
      sessionID: Int,
      keyID: KID
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.revoke.revokeDevice'?: (
    params: {
      sessionID: Int,
      deviceID: DeviceID,
      force: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.revoke.revokeSigs'?: (
    params: {
      sessionID: Int,
      sigIDQueries: Array<string>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackEncrypt'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: SaltpackEncryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackDecrypt'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: SaltpackDecryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SaltpackSaltpackDecryptResult) => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackSign'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: SaltpackSignOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackVerify'?: (
    params: {
      sessionID: Int,
      source: Stream,
      sink: Stream,
      opts: SaltpackVerifyOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpackUi.saltpackPromptForDecrypt'?: (
    params: {
      sessionID: Int,
      sender: SaltpackSender
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpackUi.saltpackVerifySuccess'?: (
    params: {
      sessionID: Int,
      signingKID: KID,
      sender: SaltpackSender
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.secretUi.getPassphrase'?: (
    params: {
      sessionID: Int,
      pinentry: GUIEntryArg,
      terminal: (null | SecretEntryArg)
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SecretUiGetPassphraseResult) => void
    }
  ) => void,
  'keybase.1.SecretKeys.getSecretKeys'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SecretKeysGetSecretKeysResult) => void
    }
  ) => void,
  'keybase.1.session.currentSession'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SessionCurrentSessionResult) => void
    }
  ) => void,
  'keybase.1.signup.checkUsernameAvailable'?: (
    params: {
      sessionID: Int,
      username: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.signup.signup'?: (
    params: {
      sessionID: Int,
      email: String,
      inviteCode: String,
      passphrase: String,
      username: String,
      deviceName: String,
      storeSecret: Boolean,
      skipMail: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SignupSignupResult) => void
    }
  ) => void,
  'keybase.1.signup.inviteRequest'?: (
    params: {
      sessionID: Int,
      email: String,
      fullname: String,
      notes: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.signup.checkInvitationCode'?: (
    params: {
      sessionID: Int,
      invitationCode: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.sigs.sigList'?: (
    params: {
      sessionID: Int,
      arg: SigListArgs
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SigsSigListResult) => void
    }
  ) => void,
  'keybase.1.sigs.sigListJSON'?: (
    params: {
      sessionID: Int,
      arg: SigListArgs
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SigsSigListJSONResult) => void
    }
  ) => void,
  'keybase.1.streamUi.close'?: (
    params: {
      sessionID: Int,
      s: Stream
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.streamUi.read'?: (
    params: {
      sessionID: Int,
      s: Stream,
      sz: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: StreamUiReadResult) => void
    }
  ) => void,
  'keybase.1.streamUi.write'?: (
    params: {
      sessionID: Int,
      s: Stream,
      buf: Bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: StreamUiWriteResult) => void
    }
  ) => void,
  'keybase.1.test.test'?: (
    params: {
      sessionID: Int,
      name: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: TestTestResult) => void
    }
  ) => void,
  'keybase.1.test.testCallback'?: (
    params: {
      sessionID: Int,
      name: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: TestTestCallbackResult) => void
    }
  ) => void,
  'keybase.1.test.panic'?: (
    params: {
      message: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.track'?: (
    params: {
      sessionID: Int,
      userAssertion: String,
      options: TrackOptions,
      forceRemoteCheck: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.trackWithToken'?: (
    params: {
      sessionID: Int,
      trackToken: TrackToken,
      options: TrackOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.dismissWithToken'?: (
    params: {
      sessionID: Int,
      trackToken: TrackToken
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.untrack'?: (
    params: {
      sessionID: Int,
      username: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.checkTracking'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.fakeTrackingChanged'?: (
    params: {
      sessionID: Int,
      username: String
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ui.promptYesNo'?: (
    params: {
      sessionID: Int,
      text: Text,
      promptDefault: PromptDefault
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UiPromptYesNoResult) => void
    }
  ) => void,
  'keybase.1.update.update'?: (
    params: {
      options: UpdateOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UpdateUpdateResult) => void
    }
  ) => void,
  'keybase.1.update.updateCheck'?: (
    params: {
      force: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.updateUi.updatePrompt'?: (
    params: {
      sessionID: Int,
      update: Update,
      options: UpdatePromptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UpdateUiUpdatePromptResult) => void
    }
  ) => void,
  'keybase.1.updateUi.updateAppInUse'?: (
    params: {
      sessionID: Int,
      update: Update,
      processes: Array<Process>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UpdateUiUpdateAppInUseResult) => void
    }
  ) => void,
  'keybase.1.updateUi.updateQuit'?: (
    params: {
      sessionID: Int,
      update: Update,
      status: Status
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UpdateUiUpdateQuitResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackers'?: (
    params: {
      sessionID: Int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserListTrackersResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackersByName'?: (
    params: {
      sessionID: Int,
      username: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserListTrackersByNameResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackersSelf'?: (
    params: {
      sessionID: Int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserListTrackersSelfResult) => void
    }
  ) => void,
  'keybase.1.user.loadUncheckedUserSummaries'?: (
    params: {
      sessionID: Int,
      uids: Array<UID>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserLoadUncheckedUserSummariesResult) => void
    }
  ) => void,
  'keybase.1.user.loadUser'?: (
    params: {
      sessionID: Int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserLoadUserResult) => void
    }
  ) => void,
  'keybase.1.user.loadUserPlusKeys'?: (
    params: {
      sessionID: Int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserLoadUserPlusKeysResult) => void
    }
  ) => void,
  'keybase.1.user.loadPublicKeys'?: (
    params: {
      sessionID: Int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserLoadPublicKeysResult) => void
    }
  ) => void,
  'keybase.1.user.listTracking'?: (
    params: {
      sessionID: Int,
      filter: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserListTrackingResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackingJSON'?: (
    params: {
      sessionID: Int,
      filter: String,
      verbose: Boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserListTrackingJSONResult) => void
    }
  ) => void,
  'keybase.1.user.search'?: (
    params: {
      sessionID: Int,
      query: String
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: UserSearchResult) => void
    }
  ) => void
}


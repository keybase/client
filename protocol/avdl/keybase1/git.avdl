@namespace("keybase.1")

protocol git {
  import idl "common.avdl";
  // for Folder and FolderType -- maybe these should be in kbfs_common?
  import idl "favorite.avdl";

  // The same format as in chat1.EncryptedData (and KBFS)
  record EncryptedGitMetadata {
    int   v;                  // version = 1
    bytes e;                  // encryptedData (output of secret box)
    BoxNonce n;               // nonce
    PerTeamKeyGeneration gen; // key generation that was used
  }

  @typedef("string")
  record RepoID {}

  enum GitLocalMetadataVersion {
    V1_1
  }

  record GitLocalMetadataV1 {
    GitRepoName repoName;
  }

  // GitLocalMetadataVersioned is a variant container for all the
  // versions of GitLocalMetadata.
  variant GitLocalMetadataVersioned switch (GitLocalMetadataVersion version) {
    case V1 : GitLocalMetadataV1;
  }

  record GitCommit {
    string commitHash;
    string message;
    string authorName;
    string authorEmail;
    Time ctime; // unix time in milliseconds
  }

  enum GitPushType {
    DEFAULT_0,
    CREATEREPO_1,
    // UNUSED_2, <- this was DELETEBRANCH_2, which we never used. Using isDelete flag in GitRefMetadata instead.
    RENAMEREPO_3
  }
  record GitRefMetadata {
    string refName;
    array<GitCommit> commits;
    boolean moreCommitsAvailable; // true if `commits` doesn't include all
    boolean isDelete; // true if this is a branch/ref delete operation
  }

  // GitLocalMetadata is the struct that local RPCs use to read and write repo
  // metadata. It's decoupled from GitLocalMetadataVersioned, which is the
  // format that we serialize and encrypt, in case we ever need to support
  // multiple versions. Right now, however, its fields are exactly the same as
  // the only current variant, GitLocalMetadataV1.
  record GitLocalMetadata {
    GitRepoName repoName;
    array<GitRefMetadata> refs;
    GitPushType pushType;
    GitRepoName previousRepoName; // filled in for renames
  }

  // Additional metadata maintained by the server, returned with query results.
  record GitServerMetadata {
    Time ctime;
    Time mtime;
    string lastModifyingUsername;
    DeviceID lastModifyingDeviceID;
    string lastModifyingDeviceName;
  }

  // These RPCs are only exposed for testing. Public commands won't call it directly.
  void putGitMetadata(FolderHandle folder, RepoID repoID, GitLocalMetadata metadata, boolean notifyTeam);
  void deleteGitMetadata(FolderHandle folder, GitRepoName repoName);

  enum GitRepoResultState {
    ERR_0,
    OK_1
  }

  variant GitRepoResult switch (GitRepoResultState state) {
    case ERR: string;
    case OK: GitRepoInfo;
  }

  record GitRepoInfo {
    FolderHandle folder;
    RepoID repoID;
    GitLocalMetadata localMetadata;
    GitServerMetadata serverMetadata;
    string repoUrl;
    string globalUniqueID;  // for the GUI's convenient bookkeeping
    boolean canDelete;
    union { null, GitTeamRepoSettings } teamRepoSettings;
  }

  // fetch git repos for a single team / implicit team
  // (note that non-team TLFs are mapped to implicit teams on the core side of this)
  array<GitRepoResult> getGitMetadata(FolderHandle folder);

  // fetch git repos for all teams that the user has access to
  array<GitRepoResult> getAllGitMetadata();

  // create a personal, private repo
  RepoID createPersonalRepo(GitRepoName repoName);

  // create a team repo
  RepoID createTeamRepo(GitRepoName repoName, TeamName teamName, boolean notifyTeam);

  // delete a personal, private repo
  void deletePersonalRepo(GitRepoName repoName);

  // delete a team repo
  void deleteTeamRepo(GitRepoName repoName, TeamName teamName, boolean notifyTeam);

  // GC a personal, private repo
  void gcPersonalRepo(GitRepoName repoName, boolean force);

  // GC a team repo
  void gcTeamRepo(GitRepoName repoName, TeamName teamName, boolean force);

  record GitTeamRepoSettings {
    union { null, string } channelName;
    boolean chatDisabled;
  }
  GitTeamRepoSettings getTeamRepoSettings(FolderHandle folder, RepoID repoID);
  void setTeamRepoSettings(FolderHandle folder, RepoID repoID, union { null, string } channelName, boolean chatDisabled);
}

@namespace("keybase.1")

protocol teams {

  enum TeamRole {
    // These must be ordered by privilege.
    NONE_0,
    READER_1,
    WRITER_2,
    ADMIN_3,
    OWNER_4
  }

  enum TeamApplication {
    KBFS_1,
    CHAT_2,
    SALTPACK_3,
    GIT_METADATA_4
  }

  // PerTeamKeyGeneration describes the generation of the secret.
  // The sequence starts at 1.
  @typedef("int")
  record PerTeamKeyGeneration {}

  record TeamApplicationKey {
    TeamApplication application;
    PerTeamKeyGeneration keyGeneration;
    Bytes32 key;
  }

  @typedef("bytes")
  record MaskB64 {}

  @typedef("string")
  record TeamInviteID {}

  record ReaderKeyMask {
    TeamApplication application;
    PerTeamKeyGeneration generation;
    MaskB64 mask;
  }

  @lint("ignore")
  record PerTeamKey {
      PerTeamKeyGeneration gen;
      Seqno seqno;
      KID sigKID;
      KID encKID;
  }

  fixed PerTeamKeySeed(32);

  // Secret from which team keys are derived
  record PerTeamKeySeedItem {
    PerTeamKeySeed seed;
    PerTeamKeyGeneration generation;
    Seqno seqno;
  }

  record TeamMember {
    UID uid;
    TeamRole role;
    Seqno eldestSeqno;     // eldest seqno of the team member record
    Seqno userEldestSeqno; // actual eldest seqno of the user
  }

  record TeamMembers {
    array<UserVersion> owners;
    array<UserVersion> admins;
    array<UserVersion> writers;
    array<UserVersion> readers;
  }

  record TeamMemberDetails {
    UserVersion uv;
    string username;
    boolean active;
    @lint("ignore")
    boolean needsPUK;
  }

  record TeamMembersDetails {
    array<TeamMemberDetails> owners;
    array<TeamMemberDetails> admins;
    array<TeamMemberDetails> writers;
    array<TeamMemberDetails> readers;
  }

  record TeamDetails {
    TeamMembersDetails members;
    PerTeamKeyGeneration keyGeneration;
    map<TeamInviteID,AnnotatedTeamInvite> annotatedActiveInvites;
    TeamSettings settings;
  }

  record UserVersion {
    UID uid;
    Seqno eldestSeqno;
  }

  @typedef("string")
  record UserVersionPercentForm {}


  record TeamChangeReq {
    array<UserVersion> owners;
    array<UserVersion> admins;
    array<UserVersion> writers;
    array<UserVersion> readers;
    array<UserVersion> none;
    map<TeamInviteID,UserVersionPercentForm> completedInvites;
  }

  record TeamPlusApplicationKeys {
      TeamID id;
      string name;
      boolean implicit;
      boolean public;
      TeamApplication application;

      array<UserVersion> writers;
      array<UserVersion> onlyReaders;

      array<TeamApplicationKey> applicationKeys;
  }

  // Snapshot of a loaded team.
  // If this is changed in incompatible way, increment teams/storage.go:diskStorageVersion
  record TeamData {
    // Whether this snapshot is entirely missing secrets.
    // Not used. Might as well get rid of this field next time the cache is busted.
    boolean secretless;

    // Name of the team. This is tricky.
    // The root ancestor, final part, and the depth are always correct.
    // But the middle parts (b in a.b.c) do not track the sigchain.
    // They are kept fairly up to date by TeamLoader, but the guarantees are fuzzy.
    TeamName name;
    TeamSigChainState chain;

    // These secrets may be behind or missing if this is a public team.
    // generation -> seed
    // generations _must_ start from 1 with no gaps
    map<PerTeamKeyGeneration,PerTeamKeySeedItem> perTeamKeySeeds;
    // application -> generation -> mask
    // in each slot generations _must_ start from 1 with no gaps
    map<TeamApplication,map<PerTeamKeyGeneration,MaskB64>> readerKeyMasks;

    // Should only be used by TeamLoader
    // because it is the only mutated field, and thus is not threadsafe to read.
    Time cachedAt;
  }

  enum TeamInviteCategory {
    NONE_0,
    UNKNOWN_1,
    KEYBASE_2,
    EMAIL_3,
    SBS_4
  }

  variant TeamInviteType switch (TeamInviteCategory c) {
    case UNKNOWN: string;
    case SBS: TeamInviteSocialNetwork;
    default: void;
  }

  @typedef("string")
  record TeamInviteSocialNetwork {}
  @typedef("string")
  record TeamInviteName {}

  record TeamInvite {
    TeamRole role;
    TeamInviteID id;
    TeamInviteType type;
    TeamInviteName name;
    UserVersion inviter;
  }

  record AnnotatedTeamInvite {
    TeamRole role;
    TeamInviteID id;
    TeamInviteType type;
    TeamInviteName name;
    UserVersion uv;
    UserVersion inviter;
    string inviterUsername;
    string teamName;
  }

  // State of a parsed team sigchain.
  // Should be treated as immutable when outside TeamSigChainPlayer.
  // Modified internally to TeamSigChainPlayer.
  record TeamSigChainState {
    // The user who loaded this sigchain
    UserVersion reader;

    TeamID id;

    // Whether this is an implicit team.
    boolean implicit;
    // Whether this is a public team.
    boolean public;

    // Name of the root ancestor. For A.B.C this is 'A'.
    TeamName rootAncestor;
    // Depth of the name.
    int nameDepth;

    // Log of the last part of the team name.
    array<TeamNameLogPoint> nameLog;

    // The last link procesed
    Seqno lastSeqno;
    LinkID lastLinkID;

    // Present if a subteam
    union { null, TeamID } parentID;

    // For each user; the timeline of their role status.
    // The role checkpoints are always ordered by seqno.
    // The latest role of the user is the role of their last checkpoint.
    // When a user leaves the team a NONE checkpoint appears in their list.
    map<UserVersion,array<UserLogPoint>> userLog;

    // For each subteam; the timeline of its name.
    // The checkpoints are always ordered by seqno.
    // The latest name of the subteam is the role of its last checkpoint.
    map<TeamID,array<SubteamLogPoint>> subteamLog;

    // Keyed by per-team-key generation
    map<PerTeamKeyGeneration, PerTeamKey> perTeamKeys;

    // This is filled up to lastSeqno.
    map<Seqno, LinkID> linkIDs;

    // Set of links that are stubbed-out and whose contents are missing.
    // Keyed by seqno
    map<Seqno, boolean> stubbedLinks;

    // All invitations that are currently active.
    map<TeamInviteID,TeamInvite> activeInvites;

    // Whether this is an open team.
    boolean open;
    TeamRole openTeamJoinAs;
  }

  // The team got this name at this point in time.
  record TeamNameLogPoint {
    TeamNamePart lastPart;
    // The seqno at which the team got this name.
    Seqno seqno;
  }

  // A user became this role at a point in time
  record UserLogPoint {
    // The new role. Including NONE if the user left the team.
    TeamRole role;
    // The seqno at which the user became this role, and other imporant
    // details, like the last known MerkleRoot at that time.
    SignatureMetadata sigMeta;
  }

  // A subteam got this name at this point in time.
  record SubteamLogPoint {
    // The new subteam name.
    TeamName name;
    // The (parent) seqno at which the subteam got this name.
    Seqno seqno;
  }

  @typedef("string")
  record TeamNamePart {}

  // matches the team name struct from api server
  record TeamName {
    array<TeamNamePart> parts;
  }

  // team.clkr gregor message body
  @lint("ignore")
  record TeamCLKRMsg {
    @jsonkey("team_id")
    TeamID teamID;
    PerTeamKeyGeneration generation;
    int score;
  }

  record TeamChangeRow {
    TeamID id;
    string name;
    @jsonkey("key_rotated")
    boolean keyRotated;
    @jsonkey("membership_changed")
    boolean membershipChanged;
    @jsonkey("latest_seqno")
    Seqno latestSeqno;
  }

  record TeamExitRow {
    TeamID id;
  }

  record TeamInvitee {
    @jsonkey("invite_id")
    TeamInviteID inviteID;
    UID uid;
    @jsonkey("eldest_seqno")
    Seqno eldestSeqno;
    TeamRole role;
  }

  // team.sbs gregor message body
  @lint("ignore")
  record TeamSBSMsg {
    @jsonkey("team_id")
    TeamID teamID;
    int score;
    array<TeamInvitee> invitees;
  }

  record TeamAccessRequest {
    UID uid;
    @jsonkey("eldest_seqno")
    Seqno eldestSeqno;
  }

  @lint("ignore")
  record TeamOpenReqMsg {
    @jsonkey("team_id")
    TeamID teamID;
    array<TeamAccessRequest> tars;
  }

  /**
   * TeamRefreshData are needed or wanted data requirements that, if unmet, will cause
   * a refresh of the cache.
   */
  record TeamRefreshers {
    // Load at least up to the keygen. Returns an error if the keygen is not loaded.
    PerTeamKeyGeneration needKeyGeneration;
    // Refresh if the cached version does not have these members at the minimum role `wantMembersRole`.
    // Does not guarantee these members will be present in the returned team. This is especially
    // relevant in the case of deleted users, who won't be there after the refresh.
    // Does not work on implicit admins.
    // If the EldestSeqno of an item is zero, the latest EldestSeqno for that UID will be looked
    // up and used. But the used EldestSeqno may come from a cache.
    array<UserVersion> wantMembers;
    // The minimum role each of wantMembers must have in order to avoid a refresh.
    // The default value is WRITER. So if the role is NONE, it will act like WRITER.
    TeamRole wantMembersRole;
  }

  record LoadTeamArg {
    // One of these must be specified.
    // ID is preferred. Name will always hit the server.
    // If both are specified ID will be used and Name will be checked.
    @lint("ignore")
    TeamID ID;
    string name;

    // Whether we need to be an admin.
    // Will fail unless we are an admin in the returned Team.
    // If this is false, looking at invites or listing subteams in the response
    // may not work even if the loading user is an admin.
    boolean needAdmin;

    TeamRefreshers refreshers;

    boolean forceFullReload;      // Ignore local data and fetch from the server.
    boolean forceRepoll;          // Force a sync with merkle.
    boolean staleOK;              // If a very stale cache hit is OK.
    boolean public;               // For public teams.
  }

  record ImplicitRole {
    TeamRole role;
    TeamID ancestor;
  }

  record MemberInfo {
    @jsonkey("uid")
    UID userID;
    @jsonkey("team_id")
    TeamID teamID;
    @jsonkey("fq_name")
    string fqName;
    @jsonkey("is_implicit_team")
    boolean isImplicitTeam;
    TeamRole role;
    union{null, ImplicitRole} implicit;
  }

  record TeamList {
    array<MemberInfo> teams;
  }

  record AnnotatedMemberInfo {
    @jsonkey("uid")
    UID userID;
    @jsonkey("team_id")
    TeamID teamID;
    string username;
    @jsonkey("full_name")
    string fullName;
    @jsonkey("fq_name")
    string fqName;
    @jsonkey("is_implicit_team")
    boolean isImplicitTeam;
    TeamRole role;
    union{null, ImplicitRole} implicit;
    @lint("ignore")
    boolean needsPUK;
  }

  record AnnotatedTeamList {
      array<AnnotatedMemberInfo> teams;
      map<TeamInviteID,AnnotatedTeamInvite> annotatedActiveInvites;
  }

  record TeamAddMemberResult {
    boolean invited;
    union{null, User} user;
    boolean emailSent;
    boolean chatSent;
  }

  record TeamJoinRequest {
    string name;
    string username;
  }

  record TeamTreeResult {
    array<TeamTreeEntry> entries;
  }

  record TeamTreeEntry {
    TeamName name;
    boolean admin; // Whether the user is an admin, explicit or implicit.
  }

  record TeamCreateResult {
    boolean chatSent;
    boolean creatorAdded;
  }

  record TeamSettings {
    boolean open;
    TeamRole joinAs;
  }

  TeamCreateResult teamCreate(int sessionID, string name, boolean sendChatNotification);
  TeamCreateResult teamCreateWithSettings(int sessionID, string name, boolean sendChatNotification, TeamSettings settings);
  TeamDetails teamGet(int sessionID, string name, boolean forceRepoll);
  AnnotatedTeamList teamList(int sessionID, string userAssertion, boolean all, boolean includeImplicitTeams);
  // admin only
  array<TeamIDAndName> teamListSubteamsRecursive(int sessionID, string parentTeamName, boolean forceRepoll);
  void teamChangeMembership(int sessionID, string name, TeamChangeReq req);
  TeamAddMemberResult teamAddMember(int sessionID, string name, string email, string username, TeamRole role, boolean sendChatNotification);
  void teamRemoveMember(int sessionID, string name, string username, string email, boolean permanent);
  void teamLeave(int sessionID, string name, boolean permanent);
  void teamEditMember(int sessionID, string name, string username, TeamRole role);
  void teamRename(int sessionID, TeamName prevName, TeamName newName);
  void teamAcceptInvite(int sessionID, string token);
  void teamRequestAccess(int sessionID, string name);
  // Accept an invite or request to join a team, try both.
  void teamAcceptInviteOrRequestAccess(int sessionID, string tokenOrName);
  array<TeamJoinRequest> teamListRequests(int sessionID);
  void teamIgnoreRequest(int sessionID, string name, string username);
  // Get a list of all recursive subteams recursively. Sorted alphabetically like a tree.
  // Team must be a root team.
  // Example: a -> [a, a.b, a.b.c, a.b.d, a.e.f, a.e.g]
  TeamTreeResult teamTree(int sessionID, TeamName name);
  void teamDelete(int sessionID, string name);
  void teamSetSettings(int sessionID, string name, TeamSettings settings);

  record BulkRes {
    array<string> invited;
    array<string> alreadyInvited;
    array<string> malformed;
  }

  // emails is a list of email addresses separated by whitespace or commas.
  // returns a list of emails that were not invited, most likely because of
  // malformed email addresses.
  BulkRes teamAddEmailsBulk(int sessionID, string name, string emails, TeamRole role);

  record ImplicitTeamUserSet {
    array<string> keybaseUsers;
    array<SocialAssertion> unresolvedUsers;
  }

  /**
   * iTeams
  */
  record ImplicitTeamDisplayName {
    boolean isPublic;
    ImplicitTeamUserSet writers;
    ImplicitTeamUserSet readers;
    union { null, ImplicitTeamConflictInfo } conflictInfo;
  }

  record ImplicitTeamConflictInfo {
    int generation;
    Time time;
  }

  record LookupImplicitTeamRes {
    TeamID teamID;
    TeamName name;
    ImplicitTeamDisplayName displayName;
  }

  LookupImplicitTeamRes lookupImplicitTeam(string name, boolean public);
  LookupImplicitTeamRes lookupOrCreateImplicitTeam(string name, boolean public);

  void teamReAddMemberAfterReset(int sessionID, TeamID id, string username);

  /**
   * loadTeamPlusApplicationKeys loads team information for applications like KBFS and Chat.
   * If refreshers are non-empty, then force a refresh of the cache if the requirements
   * of the refreshers aren't met.
   */
  TeamPlusApplicationKeys loadTeamPlusApplicationKeys(int sessionID, TeamID id, TeamApplication application, TeamRefreshers refreshers);
  TeamID getTeamRootID(TeamID id);
}

@namespace("keybase.1")

protocol SimpleFS {

  import idl "common.avdl";

/*
  File manipulation interface
  
  Caller provides OpID to one of these methods to begin an operation:
    list
    listRecursive
    copy
    open
    move
    remove
  then calls one of the following until until status is no longer pending
  or operation is cancelled:
    readList (after list or listRecursive)
    read (after open)
    write (after open)
    check (after copy, move or remove)
  Caller can optionally block by calling wait()
  Operation must be closed by calling close
*/

  // Random GUID provided by caller 
  fixed OpID(16);
  
  enum PathType {
    LOCAL_0,
    KBFS_1
  }  

  @typedef("string")
  record LocalPath {}

  // TODO: do we want to separately specify public/private, 
  // or leave it as part of the string?
  @typedef("string")
  record KBFSPath {}
  
  variant Path switch (PathType PathType) {
    case LOCAL: LocalPath;
    case KBFS: KBFSPath;
  }

  enum DirentType {
    FILE,
    DIR,
    SYM,
    EXEC
  }
  
  record Dirent {
    Time time;
    int size;   // size of file or count of dir entries (TBD - mmay be expensive/unnecessary)
    DirentType direntType;
  }

  @typedef("int")
  record ErrorNum {}

  enum OpenFlags {
    READ_0,         // exclusive of other flags
    REPLACE_1,      // overwrite
    EXISTING_2,     // fail if not present already
    WRITE_4,        // read is implied if not write, executable, or directory
    EXECUTABLE_8,
    DIRECTORY_16
  }

  @typedef("int")
  record Progress {}

  record ListResult {
    array<KBFSPath> Paths;
    Progress progress;
  }
  
  record FileContent {
    bytes data;         // Zero bytes when read is complete
    Progress progress;  // Amount of data copied so far during this and previous reads
  }                     // (TBD: should this be percentage?)
  
  enum PathType {
    LOCAL_0,
    KBFS_1
  }  

  @typedef("string")
  record LocalPath {}

  @typedef("string")
  record KBFSPath {}
  
  variant Path switch (PathType PathType) {
    case LOCAL: LocalPath;
    case KBFS: KBFSPath;
  }

  enum AsyncOps {
    list_0,
    listRecursive_1,
    read_2,
    write_3,
    copy_4,
    move_5,
    remove_6
  }

  record ListRemoveArgs {
    OpID opID;
    KBFSPath path;
  }

  record ReadWriteArgs {
    OpID opID;
    KBFSPath path;
    int offset;
  }

  record CopyMoveArgs {
    OpID opID;
    Path src;
    Path dest;
  }

  record OpDescription switch (AsyncOps AsyncOp) {
    case list: ListArgs;
    case listRecursive: ListArgs;
    case read: ReadWriteArgs;
    case write: ReadWriteArgs;
    case copy: CopyMoveArgs;
    case move: CopyMoveArgs;
    case remove: ListRemoveArgs;
  }

  /**
   Begin list of items in directory at path
   Retrieve results with readList()
   Can be a single file to get flags/status
   */
  void list(OpID opID, KBFSPath path);

  /**
   Begin recursive list of items in directory at path
   */
  void listRecursive(OpID opID, KBFSPath path);

  /**
   Get list of Paths in progress. Can indicate status of pending
   to get more entries.
   */
  ListResult readList(OpID opID);

  /**
   Begin copy of file or directory 
   */
  void copy(OpID opID, Path src, Path dest);

  /**
   Begin recursive copy of directory 
   */
  void copyRecursive(OpID opID, Path src, Path dest);

  /**
   Begin move of file or directory, from/to KBFS only
   */
  void move(OpID opID, KBFSPath src, KBFSPath dest);

  /**
   Rename file or directory, KBFS side only
   */
  void rename(KBFSPath src, KBFSPath dest);

  /**
   Create/open a file and leave it open
   or create a directory
   or set the executable bit on an existing file.
   Files must be closed afterwards.
   */
  void open(OpID opID, KBFSPath dest, OpenFlags flags);

  /**
   Read (possibly partial) contents of open file,
   up to the amount specified by size.
   Repeat until zero bytes are returned or error.
   If size is zero, read an arbitrary amount.
   */
  FileContent read(OpID opID, int offset, int size);

  /**
   Append content to opened file.
   May be repeated until OpID is closed.
   */
  void write(OpID opID, int offset, bytes content);

  /**
   Remove file or directory from filesystem
   */
  void remove(OpID opID, KBFSPath path);

  /**
   Get info about file
   */
  Dirent stat(KBFSPath path);

  /**
   Convenience helper for generating new random value
   */
  OpID makeOpID();

  /**
   Close OpID, cancels any pending operation.
   Must be called after list/copy/remove
   */
  void close(OpID opID);

  /**
   Check progress of pending operation
   */
  Progress check(OpID opID);

  /**
   Get all the outstanding operations
   */
  array<OpDescription> getOps();

  /**
   Blocking wait for the pending operation to finish
   */
  void wait(OpID opID);
}

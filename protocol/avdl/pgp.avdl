@namespace("keybase.1")

protocol pgp {
	import idl "common.avdl";

	enum SignMode {
		ATTACHED_0,
		DETACHED_1,
		CLEAR_2
	}

	record PgpSignOptions {
		string keyQuery;
		SignMode mode;
		boolean binaryIn;
		boolean binaryOut;
	}

	// Return a source that we should be writing to.
	void pgpSign(int sessionID, Stream source, Stream sink, PgpSignOptions opts);

	// Download PGP keys for tracked users and update the local GPG keyring.
	// If usernames is nonempty, update only those users.
	void pgpPull(int sessionID, array<string> userAsserts);

	record PgpEncryptOptions {
		array<string> recipients; // user assertions
		boolean noSign;
		boolean noSelf;
		boolean binaryOut;
		string keyQuery;
		boolean localOnly; // store track locally only
		boolean approveRemote;  // approve remote track without prompt
	}

	void pgpEncrypt(int sessionID, Stream source, Stream sink, PgpEncryptOptions opts);

	// PgpSigVerification is returned by pgpDecrypt and pgpVerify with information
	// about a the signature verification.  If isSigned is false, there was no
	// signature, and the rest of the fields should be ignored.
	record PgpSigVerification {
		boolean isSigned; // true if message was signed
		boolean verified; // true if signature verified
		User signer; // who signed it
		PublicKey signKey; // the pub key that signed it
	}

	record PgpDecryptOptions {
		boolean assertSigned;
		string signedBy; // assert that signature made by this user
		boolean localOnly; // store track locally only
		boolean approveRemote;  // approve remote track without prompt
	}

	PgpSigVerification pgpDecrypt(int sessionID, Stream source, Stream sink, PgpDecryptOptions opts);

	record PgpVerifyOptions {
		string signedBy; // assert that signature made by this user
		boolean localOnly; // store track locally only
		boolean approveRemote;  // approve remote track without prompt
		bytes signature; // detached signature data (binary or armored), can be empty
	}

	PgpSigVerification pgpVerify(int sessionID, Stream source, PgpVerifyOptions opts);

	void pgpImport(int sessionID, bytes key, boolean pushSecret);

	record KeyInfo {
		string fingerprint;
		string key;
		string desc;
	}

	// If 'secret' is true, you get at most one key back.
	record PgpQuery {
		boolean secret;
		string query;
		boolean exactMatch;
	}

	// Exports active PGP keys. Only allows armored export.
	array<KeyInfo> pgpExport(int sessionID, PgpQuery options);
	array<KeyInfo> pgpExportByFingerprint(int sessionID, PgpQuery options);
	array<KeyInfo> pgpExportByKID(int sessionID, PgpQuery options);

	record PgpCreateUids {
		boolean useDefault;
		array<PgpIdentity> ids;
	}

	void pgpKeyGen(int sessionID, int primaryBits, int subkeyBits, PgpCreateUids createUids, boolean allowMulti, boolean doExport);

	void pgpKeyGenDefault(int sessionID, PgpCreateUids createUids);

	void pgpDeletePrimary(int sessionID);

	// select an existing key and add to kb
	void pgpSelect(int sessionID, string fingerprintQuery, boolean allowMulti, boolean skipImport);

	// push updated key(s) to the server
	void pgpUpdate(int sessionID, boolean all, array<string> fingerprints);
}

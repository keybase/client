require "json"

begin
  require "active_support/inflector"
rescue LoadError
  puts "You need to install active support: gem install activesupport"
  exit 1
end

script_path = File.expand_path(File.dirname(__FILE__))

paths = Dir["#{script_path}/../json/*.json"]

def gtype(type)
	case type
	when "boolean" then "bool"
	end
end

Conversions = {"btc" => "BTC"}

def convert_word(word)
	return nil if word.nil?
	return Conversions[word] if Conversions.has_key?(word)
	word
end

def titleize(name)
	return "" if name.nil?
	name[0].capitalize + name[1..-1]
end

def convert_classname(command, subcommand)
	command = convert_word(command)
	subcommand = convert_word(subcommand)
	return titleize(command) + titleize(subcommand)
end

def convert_methodname(name)
	return titleize(name)
end

def first_sentence(doc)
	doc.split(/\.\s/).first
end

go = []
paths.each do |path|
	file = File.read(path)
	h = JSON.parse(file)

	protocol = h["protocol"]
	namespace = h["namespace"]

	h["messages"].each do |message_name, message_param|
		request = message_param["request"]
		response = message_param["response"]

		next if message_param["command"].nil?

		# If protocol and command are the same we don't have sub commands,
		# so clear
		command = protocol.downcase
		subcommand = message_param["command"]["name"]
		command = nil if command == subcommand
		desc = first_sentence(message_param["doc"])

		class_name = convert_classname(command, subcommand)
		method_name = convert_methodname(message_name)
		client_name = convert_classname(protocol, nil)

		# Parse method signature
		flags = []
		flagdefs = []
		args = []
		properties = []
		assigns = []
		struct_assigns = []
		request.each do |param|
			name = param["name"]
			type = param["type"]
			gtype = gtype(type)

			# Ignore sessionID arguments
			if name == "sessionID"
				properties << "sessionID int"
				next
			end

			if param.has_key?("default") then
				# Flag
				properties << "#{name} #{gtype}"
				flags << name
				if type == "boolean"
					flagdefs << "cli.BoolFlag{Name: \"#{name}\", Usage: \"\"},"
					assigns << "c.#{name} = ctx.Bool(\"#{name}\")"
				else
					raise "Unhandled type"
				end
				struct_assigns << "#{name.capitalize}: c.#{name},"
			else
				# Arg
				properties << "#{name} #{type}"
				assigns << "c.#{name} = ctx.Args()[#{assigns.length}]"
				struct_assigns << "#{titleize(name)}: c.#{name},"
				args << name
			end
		end

		flags_desc = " [" + flags.collect{|f| "--#{f}"}.join(" ") + "]" if flags.length > 0
		args_desc = " " + args.collect{|a| "<#{a}>"}.join(" ") if args.length > 0
		command_desc = [command, subcommand].compact.join(" ")

		usage = "keybase #{command_desc}#{flags_desc}#{args_desc}"

		cli_args = struct_assigns.length > 0 ? "keybase1.#{method_name}Arg{#{struct_assigns.join("\n")}}" : "c.sessionID"

		# Generate GO
		go << <<-EOS
		type Cmd#{class_name} struct {
			#{properties.join("\n")}
		}

		func (c *Cmd#{class_name}) ParseArgv(ctx *cli.Context) error {
			if len(ctx.Args()) != #{args.length} {
				return fmt.Errorf("Invalid arguments.")
			}
			#{assigns.join("\n")}
			return nil
		}

		func NewCmd#{class_name}(cmd libcmdline.Command, cl *libcmdline.CommandLine) cli.Command {
			return cli.Command{
				Name:        "#{subcommand}",
				Usage:       "#{usage}",
				Description: "#{desc}",
				Flags: []cli.Flag{
					#{flagdefs.join("\n")}
				},
				Action: func(c *cli.Context) {
					cl.ChooseCommand(cmd, "#{subcommand}", c)
				},
			}
		}

		func (c *Cmd#{class_name}) Run() (err error) {
			c.sessionID, err = libkb.RandInt()
			if err != nil {
				return err
			}
			cli, err := Get#{client_name}Client()
			if err != nil {
				return err
			}

			protocols := []rpc2.Protocol{
				NewLogUIProtocol(),
				NewSecretUIProtocol(),
				NewLocksmithUIProtocol(),
			}
			if err = RegisterProtocols(protocols); err != nil {
				return
			}


			#{response == "null" ? "err" : "_, err"} = cli.#{method_name}(#{cli_args})
			return
		}

		func (c *Cmd#{class_name}) GetUsage() libkb.Usage {
			return libkb.Usage{
				Config:     true,
				GpgKeyring: true,
				KbKeyring:  true,
				API:        true,
			}
		}
		EOS

	end

	File.open("#{script_path}/../../go/client/cmds.go", "w") { |f|
		f.write <<-EOS
		// This file is autogenerated.
		package client

		import (
			"fmt"
			"github.com/keybase/cli"
			"github.com/keybase/client/go/libcmdline"
			"github.com/keybase/client/go/libkb"
			keybase1 "github.com/keybase/client/protocol/go"
			"github.com/maxtaco/go-framed-msgpack-rpc/rpc2"
		)

		EOS

		f.write(go.join("\n"))
	}

end

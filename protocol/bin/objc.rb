require "json"

begin
  require "active_support/inflector"
rescue LoadError
  puts "You need to install active support: gem install activesupport"
  exit 1
end

script_path = File.expand_path(File.dirname(__FILE__))

paths = Dir["#{script_path}/../json/*.json"]

defined_types = []
enums = []

def classname(n)
  "KBR#{n}"
end

def objc_class_for_type(type)
  case type
  when "string" then "NSString"
  when "array" then "NSArray"
  when "bytes" then "NSData"
  else
    "NSObject"
  end
end

def objc_for_type(type, enums, space)
  type = type["type"] if type.kind_of?(Hash) # Subtype (for arrays)
  type = type.find { |t| t != "null" } if type.kind_of?(Array) # Union

  ptr = false
  name, ptr = case type
  when "string" then ["NSString *", true]
  when "int" then ["NSInteger", false]
  when "long" then ["long", false]
  when "array" then ["NSArray *", true]
  when "boolean" then ["BOOL", false]
  when "bytes" then ["NSData *", true]
  when "null" then ["void", false]
  else
    if type.start_with?("void")
      [type, false]
    elsif enums.include?(type)
      [classname(type), false]
    else
      [classname("#{type} *"), true]
    end
  end

  name = "#{name} " if space and !ptr
  name
end

def is_native_type(type)
  is_primitive_type(type) || ["string", "array", "bytes"].include?(type)
end

def is_primitive_type(type)
  type = type.find { |t| t != "null" } if type.kind_of?(Array) # Union
  ["int", "long", "boolean", "null"].include?(type)
end

def alias_name(name)
  case name
  when "id" then "idKb"
  when "self" then "selfKb"
  else
    name
  end
end

def default_name_for_type(type)
  type = type["type"] if type.kind_of?(Hash) # Subtype (for arrays)

  case type
  when "string" then "str"
  when "int" then "n"
  when "long" then "l"
  when "array" then "items"
  when "boolean" then "b"
  when "binary" then "data"
  when "null" then "void"
  else type.camelize(:lower)
  end
end

def value_for_type(type, name, enums)
  type = type.find { |t| t != "null" } if type.kind_of?(Array) # Union
  varname = "params[0][@\"#{name}\"]"

  if type.kind_of?(Hash) # (for arrays)
    array_class = type["items"]
    if is_native_type(array_class)
      return varname
    else
      return "[MTLJSONAdapter modelsOfClass:#{classname(array_class)}.class fromJSONArray:#{varname} error:nil]"
    end
  end

  if enums.include?(type)
    return "[#{varname} integerValue]"
  end

  case type
  when "int" then "[#{varname} integerValue]"
  when "boolean" then "[#{varname} boolValue]"

  when "string" then varname
  when "array" then varname
  when "bytes" then varname
  else
    "[MTLJSONAdapter modelOfClass:#{classname(type)}.class fromJSONDictionary:#{varname} error:nil]"
  end
end

def generate_subclass(name, type)
  ["@interface #{classname(name)} : #{objc_class_for_type(type)}\n@end\n", "@implementation #{classname(name)}\n@end\n"]
end

header = []
header << "// This file is autogenerated"
header << "#import \"KBRObject.h\""
header << "#import \"KBRRequest.h\""
header << "#import \"KBRRequestParams.h\""
header << ""
impl = []
impl << "// This file is autogenerated"
impl << "#import \"KBRPC.h\"\n"

header_handlers = []
impl_handlers = []

paths.each do |path|
  file = File.read(path)
  h = JSON.parse(file)

  protocol = h["protocol"]
  namespace = h["namespace"]
  #puts "\nProtocol: #{protocol}"

  h["types"].each do |type|
    if (defined_types.include?(type["name"]))
      #puts "Skipping: #{type["name"]}. Already defined."
      next
    end
    defined_types << type["name"]
    #puts "Type: #{type["name"]}"

    if type["type"] == "enum"
      enum_name = type["name"]
      enums << enum_name
      enum_name_objc = "#{classname(enum_name)}"
      header << "typedef NS_ENUM (NSInteger, #{enum_name_objc}) {"
      type["symbols"].each do |symbol|
        sym, _, sym_val = symbol.rpartition('_')

        raise "Enums must specify value: #{enum_name} #{symbol}" if sym.length == 0
        raise "Enums must specify an integer value: #{enum_name} #{symbol}" if not /\A\d+\z/.match(sym_val)

        header << "\t#{enum_name_objc}#{sym.capitalize.camelize} = #{sym_val},"
      end
      header << "};\n"
    elsif type["type"] == "fixed"
      ch, ci = generate_subclass(type["name"], "bytes")
      header << ch
      impl << ci
    elsif type["type"] == "record" and type["typedef"]
      ch, ci = generate_subclass(type["name"], "string")
      header << ch
      impl << ci
    elsif type["type"] == "record"
      transformers = []
      header << "@interface #{classname(type["name"])} : KBRObject"
      type["fields"].each do |field|
        if field["type"].kind_of?(Hash)
          subtype = field["type"]
          if subtype["type"] == "array"

            if is_native_type(subtype["items"])
              header << "@property NSArray *#{field["name"]}; /*of #{subtype["items"]}*/"
            else
              header << "@property NSArray *#{field["name"]}; /*of #{classname(subtype["items"])}*/"
              transformers << "+ (NSValueTransformer *)#{field["name"]}JSONTransformer { return [MTLJSONAdapter arrayTransformerWithModelClass:#{classname(subtype["items"])}.class]; }"
            end
          end
        else
          header << "@property #{objc_for_type(field["type"], enums, true)}#{field["name"]};"
        end
      end
      header << "@end\n"
      impl << "@implementation #{classname(type["name"])}"
      impl += transformers if transformers
      impl << "@end\n"
    else
      puts "Undefined type: #{type["type"]}"
    end
  end


  header << "@interface #{classname(protocol.camelize)}Request : KBRRequest"
  impl << "@implementation #{classname(protocol.camelize)}Request\n"

  h["messages"].each do |method, mparam|
    request_params = mparam["request"].dup
    response_type = mparam["response"]

    request_params_items = request_params.map do |p|
      if is_primitive_type(p["type"]) || enums.include?(p["type"])
        "@\"#{p["name"]}\": @(#{alias_name(p["name"])})"
      else
        "@\"#{p["name"]}\": KBRValue(#{alias_name(p["name"])})"
      end
    end

    response_completion = if response_type == "null" then
      "void (^)(NSError *error)"
    else
      "void (^)(NSError *error, #{objc_for_type(response_type, enums, true)}#{default_name_for_type(response_type)})"
    end

    request_params << {"name" => "completion", "type" => response_completion}

    params_str = request_params.each_with_index.collect do |param, index|
      name = alias_name(param["name"])
      name = "With#{name.camelize}" if index == 0
      name = "" if request_params.length == 1

      "#{name}:(#{objc_for_type(param["type"], enums, false)})#{alias_name(param["name"])}"
    end

    rpc_method = "#{namespace}.#{protocol}.#{method}"
    dc_method = method.camelize(:lower)
    objc_method = "- (void)#{dc_method}#{params_str.join(" ")}"

    #puts "Method: #{objc_method}"
    header << "#{objc_method};\n"
    impl << "#{objc_method} {"

    callback = if response_type == "null" then # No result
      "completion(error);"
    elsif is_native_type(response_type) # Native type result
      "completion(error, 0);" # TODO
    elsif response_type.kind_of?(Hash) # Array result
      item_type = response_type["items"]
      item_clsname = classname(item_type)
      "if (error) {
        completion(error, nil);
        return;
      }
      NSArray *results = retval ? [MTLJSONAdapter modelsOfClass:#{item_clsname}.class fromJSONArray:retval error:&error] : nil;
      completion(error, results);"
    else # Dictionary result
      clsname = classname(response_type)
      "if (error) {
        completion(error, nil);
        return;
      }
      #{clsname} *result = retval ? [MTLJSONAdapter modelOfClass:#{clsname}.class fromJSONDictionary:retval error:&error] : nil;
      completion(error, result);"
    end

    impl << "  NSArray *params = @[@{#{request_params_items.join(", ")}}];
  [self.client sendRequestWithMethod:@\"#{rpc_method}\" params:params sessionId:self.sessionId completion:^(NSError *error, id retval) {
    #{callback}
  }];"

    impl << "}\n"


    # Request handlers
    if mparam["request"].length > 0
      header_handlers << "@interface KBR#{method.camelize}RequestParams : KBRRequestParams"
      mparam["request"].each do |param|
        header_handlers << "@property #{objc_for_type(param["type"], enums, true)}#{param["name"]};"
      end
      header_handlers << "@end"

      impl_handlers << "@implementation KBR#{method.camelize}RequestParams\n"

      impl_handlers << "- (instancetype)initWithParams:(NSArray *)params {"
      impl_handlers << "  if ((self = [super initWithParams:params])) {"
      mparam["request"].each do |param|
        value = value_for_type(param["type"], param["name"], enums)
        impl_handlers << "    self.#{param["name"]} = #{value};"
      end
      impl_handlers << "  }"
      impl_handlers << "  return self;"
      impl_handlers << "}\n"
      impl_handlers << "@end\n"
    end

  end
  header << "@end\n"
  impl << "@end\n"

end


File.open("#{script_path}/../objc/KBRPC.h", "w") { |f|
  f.write(header.join("\n"))
  f.write(header_handlers.join("\n"))
}

File.open("#{script_path}/../objc/KBRPC.m", "w") { |f|
  f.write(impl.join("\n"))
  f.write(impl_handlers.join("\n"))
}


/* @flow */

// This file is auto-generated by client/protocol/Makefile.
import * as gregor1 from './flow-types-gregor'

import type {$Exact} from './more'
export type int = number
export type int64 = number
export type long = number
export type double = number
export type bytes = any
export type RPCError = {
  code: number,
  desc: string
}

export type APIRes = {
  status: string;
  body: string;
  httpStatus: int;
  appStatus: string;
}

export type BTCRegisterBTCResult = void

export type BTCRegisterBTCRpc = $Exact<{
  method: 'BTC.registerBTC',
  param: {
    address: string,
    force: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type BlockIdCombo = {
  blockHash: string;
  chargedTo: UID;
}

export type BlockRefNonce = any

export type BlockReference = {
  bid: BlockIdCombo;
  nonce: BlockRefNonce;
  chargedTo: UID;
}

export type BlockReferenceCount = {
  ref: BlockReference;
  liveCount: int;
}

export type BoxNonce = any

export type BoxPublicKey = any

export type Bytes32 = any

export type ChallengeInfo = {
  now: long;
  challenge: string;
}

export type CheckProofStatus = {
  found: boolean;
  status: ProofStatus;
  proofText: string;
}

export type CheckResult = {
  proofResult: ProofResult;
  time: Time;
  freshness: CheckResultFreshness;
}

export type CheckResultFreshness =
    0 // FRESH_0
  | 1 // AGED_1
  | 2 // RANCID_2

export type ChooseType =
    0 // EXISTING_DEVICE_0
  | 1 // NEW_DEVICE_1

export type CiphertextBundle = {
  kid: KID;
  ciphertext: EncryptedBytes32;
  nonce: BoxNonce;
  publicKey: BoxPublicKey;
}

export type ClientDetails = {
  pid: int;
  clientType: ClientType;
  argv?: ?Array<string>;
  desc: string;
  version: string;
}

export type ClientType = 2 // FORCE GUI ONLY

export type ComponentResult = {
  name: string;
  status: Status;
}

export type Config = {
  serverURI: string;
  socketFile: string;
  label: string;
  runMode: string;
  gpgExists: boolean;
  gpgPath: string;
  version: string;
  path: string;
  configPath: string;
  versionShort: string;
  versionFull: string;
  isAutoForked: boolean;
  forkType: ForkType;
}

export type ConfigValue = {
  isNull: boolean;
  b?: ?boolean;
  i?: ?int;
  s?: ?string;
  o?: ?string;
}

export type ConfiguredAccount = {
  username: string;
  hasStoredSecret: boolean;
}

export type ConfirmResult = {
  identityConfirmed: boolean;
  remoteConfirmed: boolean;
  expiringLocal: boolean;
}

export type Cryptocurrency = {
  rowId: int;
  pkhash: bytes;
  address: string;
}

export type CsrfToken = string

export type Device = {
  type: string;
  name: string;
  deviceID: DeviceID;
  cTime: Time;
  mTime: Time;
  lastUsedTime: Time;
  encryptKey: KID;
  verifyKey: KID;
  status: int;
}

export type DeviceDetail = {
  device: Device;
  eldest: boolean;
  provisioner?: ?Device;
  provisionedAt?: ?Time;
  revokedAt?: ?Time;
  revokedBy: KID;
  currentDevice: boolean;
}

export type DeviceID = string

export type DeviceType =
    0 // DESKTOP_0
  | 1 // MOBILE_1

export type DismissReason = {
  type: DismissReasonType;
  reason: string;
  resource: string;
}

export type DismissReasonType =
    0 // NONE_0
  | 1 // HANDLED_ELSEWHERE_1

export type DowngradeReferenceRes = {
  completed?: ?Array<BlockReferenceCount>;
  failed: BlockReference;
}

export type ED25519PublicKey = any

export type ED25519Signature = any

export type ED25519SignatureInfo = {
  sig: ED25519Signature;
  publicKey: ED25519PublicKey;
}

export type EncryptedBytes32 = any

export type ExitCode =
    0 // OK_0
  | 2 // NOTOK_2
  | 4 // RESTART_4

export type ExtendedStatus = {
  standalone: boolean;
  passphraseStreamCached: boolean;
  tsecCached: boolean;
  deviceSigKeyCached: boolean;
  deviceEncKeyCached: boolean;
  paperSigKeyCached: boolean;
  paperEncKeyCached: boolean;
  storedSecret: boolean;
  secretPromptSkip: boolean;
  device?: ?Device;
  logDir: string;
  session?: ?SessionStatus;
  defaultUsername: string;
  provisionedUsernames?: ?Array<string>;
  Clients?: ?Array<ClientDetails>;
  platformInfo: PlatformInfo;
}

export type FSErrorType =
    0 // ACCESS_DENIED_0
  | 1 // USER_NOT_FOUND_1
  | 2 // REVOKED_DATA_DETECTED_2
  | 3 // NOT_LOGGED_IN_3
  | 4 // TIMEOUT_4
  | 5 // REKEY_NEEDED_5
  | 6 // BAD_FOLDER_6
  | 7 // NOT_IMPLEMENTED_7
  | 8 // OLD_VERSION_8
  | 9 // OVER_QUOTA_9

export type FSNotification = {
  publicTopLevelFolder: boolean;
  filename: string;
  status: string;
  statusCode: FSStatusCode;
  notificationType: FSNotificationType;
  errorType: FSErrorType;
  params: {[key: string]: string};
}

export type FSNotificationType =
    0 // ENCRYPTING_0
  | 1 // DECRYPTING_1
  | 2 // SIGNING_2
  | 3 // VERIFYING_3
  | 4 // REKEYING_4
  | 5 // CONNECTION_5
  | 6 // MD_READ_SUCCESS_6

export type FSStatusCode =
    0 // START_0
  | 1 // FINISH_1
  | 2 // ERROR_2

export type FavoritesResult = {
  favoriteFolders?: ?Array<Folder>;
  ignoredFolders?: ?Array<Folder>;
  newFolders?: ?Array<Folder>;
}

export type Feature = {
  allow: boolean;
  defaultValue: boolean;
  readonly: boolean;
  label: string;
}

export type File = {
  path: string;
}

export type FileDescriptor = {
  name: string;
  type: FileType;
}

export type FileType =
    0 // UNKNOWN_0
  | 1 // DIRECTORY_1
  | 2 // FILE_2

export type FirstStepResult = {
  valPlusTwo: int;
}

export type Folder = {
  name: string;
  private: boolean;
  notificationsOn: boolean;
  created: boolean;
}

export type ForkType =
    0 // NONE_0
  | 1 // AUTO_1
  | 2 // WATCHDOG_2
  | 3 // LAUNCHD_3

export type FuseMountInfo = {
  path: string;
  fstype: string;
  output: string;
}

export type FuseStatus = {
  version: string;
  bundleVersion: string;
  kextID: string;
  path: string;
  kextStarted: boolean;
  installStatus: InstallStatus;
  installAction: InstallAction;
  mountInfos?: ?Array<FuseMountInfo>;
  status: Status;
}

export type GPGKey = {
  algorithm: string;
  keyID: string;
  creation: string;
  expiration: string;
  identities?: ?Array<PGPIdentity>;
}

export type GPGMethod =
    0 // GPG_NONE_0
  | 1 // GPG_IMPORT_1
  | 2 // GPG_SIGN_2

export type GUIEntryArg = {
  windowTitle: string;
  prompt: string;
  username: string;
  submitLabel: string;
  cancelLabel: string;
  retryLabel: string;
  type: PassphraseType;
  features: GUIEntryFeatures;
}

export type GUIEntryFeatures = {
  storeSecret: Feature;
  showTyping: Feature;
}

export type GetBlockRes = {
  blockKey: string;
  buf: bytes;
}

export type GetCurrentStatusRes = {
  configured: boolean;
  registered: boolean;
  loggedIn: boolean;
  sessionIsValid: boolean;
  user?: ?User;
}

export type GetPassphraseRes = {
  passphrase: string;
  storeSecret: boolean;
}

export type HelloRes = string

export type Identify2Res = {
  upk: UserPlusKeys;
}

export type IdentifyKey = {
  pgpFingerprint: bytes;
  KID: KID;
  trackDiff?: ?TrackDiff;
  breaksTracking: boolean;
}

export type IdentifyOutcome = {
  username: string;
  status?: ?Status;
  warnings?: ?Array<string>;
  trackUsed?: ?TrackSummary;
  trackStatus: TrackStatus;
  numTrackFailures: int;
  numTrackChanges: int;
  numProofFailures: int;
  numRevoked: int;
  numProofSuccesses: int;
  revoked?: ?Array<TrackDiff>;
  trackOptions: TrackOptions;
  forPGPPull: boolean;
  reason: IdentifyReason;
}

export type IdentifyReason = {
  type: IdentifyReasonType;
  reason: string;
  resource: string;
}

export type IdentifyReasonType =
    0 // NONE_0
  | 1 // ID_1
  | 2 // TRACK_2
  | 3 // ENCRYPT_3
  | 4 // DECRYPT_4
  | 5 // VERIFY_5
  | 6 // RESOURCE_6

export type IdentifyRes = {
  user?: ?User;
  publicKeys?: ?Array<PublicKey>;
  outcome: IdentifyOutcome;
  trackToken: TrackToken;
}

export type IdentifyRow = {
  rowId: int;
  proof: RemoteProof;
  trackDiff?: ?TrackDiff;
}

export type Identity = {
  status?: ?Status;
  whenLastTracked: Time;
  proofs?: ?Array<IdentifyRow>;
  cryptocurrency?: ?Array<Cryptocurrency>;
  revoked?: ?Array<TrackDiff>;
  revokedDetails?: ?Array<RevokedProof>;
  breaksTracking: boolean;
}

export type InstallAction =
    0 // UNKNOWN_0
  | 1 // NONE_1
  | 2 // UPGRADE_2
  | 3 // REINSTALL_3
  | 4 // INSTALL_4

export type InstallResult = {
  componentResults?: ?Array<ComponentResult>;
  status: Status;
  fatal: boolean;
}

export type InstallStatus =
    0 // UNKNOWN_0
  | 1 // ERROR_1
  | 2 // NOT_INSTALLED_2
  | 4 // INSTALLED_4

export type KID = string

export type Kex2ProvisioneeDidCounterSignResult = void

export type Kex2ProvisioneeDidCounterSignRpc = $Exact<{
  method: 'Kex2Provisionee.didCounterSign',
  param: {
    sig: bytes
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type Kex2ProvisioneeHelloResult = HelloRes

export type Kex2ProvisioneeHelloRpc = $Exact<{
  method: 'Kex2Provisionee.hello',
  param: {
    uid: UID,
    token: SessionToken,
    csrf: CsrfToken,
    pps: PassphraseStream,
    sigBody: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: Kex2ProvisioneeHelloResult) => void)
}>

export type Kex2ProvisionerKexStartResult = void

export type Kex2ProvisionerKexStartRpc = $Exact<{
  method: 'Kex2Provisioner.kexStart',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type KeyHalf = {
  user: UID;
  deviceKID: KID;
  key: bytes;
}

export type KeyInfo = {
  fingerprint: string;
  key: string;
  desc: string;
}

export type KeybaseTime = {
  unix: Time;
  chain: int;
}

export type LinkCheckResult = {
  proofId: int;
  proofResult: ProofResult;
  snoozedResult: ProofResult;
  torWarning: boolean;
  tmpTrackExpireTime: Time;
  cached?: ?CheckResult;
  diff?: ?TrackDiff;
  remoteDiff?: ?TrackDiff;
  hint?: ?SigHint;
  breaksTracking: boolean;
}

export type ListResult = {
  files?: ?Array<File>;
}

export type LogLevel =
    0 // NONE_0
  | 1 // DEBUG_1
  | 2 // INFO_2
  | 3 // NOTICE_3
  | 4 // WARN_4
  | 5 // ERROR_5
  | 6 // CRITICAL_6
  | 7 // FATAL_7

export type MDBlock = {
  version: int;
  timestamp: Time;
  block: bytes;
}

export type MerkleRoot = {
  version: int;
  root: bytes;
}

export type MerkleTreeID =
    0 // MASTER_0
  | 1 // KBFS_PUBLIC_1
  | 2 // KBFS_PRIVATE_2

export type MetadataResponse = {
  folderID: string;
  mdBlocks?: ?Array<MDBlock>;
}

export type NaclDHKeyPrivate = any

export type NaclDHKeyPublic = any

export type NaclSigningKeyPrivate = any

export type NaclSigningKeyPublic = any

export type NotificationChannels = {
  session: boolean;
  users: boolean;
  kbfs: boolean;
  tracking: boolean;
  favorites: boolean;
  paperkeys: boolean;
  keyfamily: boolean;
  service: boolean;
}

export type NotifyFSFSActivityResult = void

export type NotifyFSFSActivityRpc = $Exact<{
  method: 'NotifyFS.FSActivity',
  param: {
    notification: FSNotification
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifyFavoritesFavoritesChangedResult = void

export type NotifyFavoritesFavoritesChangedRpc = $Exact<{
  method: 'NotifyFavorites.favoritesChanged',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifyKeyfamilyKeyfamilyChangedResult = void

export type NotifyKeyfamilyKeyfamilyChangedRpc = $Exact<{
  method: 'NotifyKeyfamily.keyfamilyChanged',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifyPaperKeyPaperKeyCachedResult = void

export type NotifyPaperKeyPaperKeyCachedRpc = $Exact<{
  method: 'NotifyPaperKey.paperKeyCached',
  param: {
    uid: UID,
    encKID: KID,
    sigKID: KID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifyServiceShutdownResult = void

export type NotifyServiceShutdownRpc = $Exact<{
  method: 'NotifyService.shutdown',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifySessionClientOutOfDateResult = void

export type NotifySessionClientOutOfDateRpc = $Exact<{
  method: 'NotifySession.clientOutOfDate',
  param: {
    upgradeTo: string,
    upgradeURI: string,
    upgradeMsg: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifySessionLoggedInResult = void

export type NotifySessionLoggedInRpc = $Exact<{
  method: 'NotifySession.loggedIn',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifySessionLoggedOutResult = void

export type NotifySessionLoggedOutRpc = $Exact<{
  method: 'NotifySession.loggedOut',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifyTrackingTrackingChangedResult = void

export type NotifyTrackingTrackingChangedRpc = $Exact<{
  method: 'NotifyTracking.trackingChanged',
  param: {
    uid: UID,
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type NotifyUsersUserChangedResult = void

export type NotifyUsersUserChangedRpc = $Exact<{
  method: 'NotifyUsers.userChanged',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type OutOfDateInfo = {
  upgradeTo: string;
  upgradeURI: string;
  customMessage: string;
}

export type Outcome =
    0 // NONE_0
  | 1 // FIXED_1
  | 2 // IGNORED_2

export type PGPCreateUids = {
  useDefault: boolean;
  ids?: ?Array<PGPIdentity>;
}

export type PGPDecryptOptions = {
  assertSigned: boolean;
  signedBy: string;
}

export type PGPEncryptOptions = {
  recipients?: ?Array<string>;
  noSign: boolean;
  noSelf: boolean;
  binaryOut: boolean;
  keyQuery: string;
}

export type PGPIdentity = {
  username: string;
  comment: string;
  email: string;
}

export type PGPQuery = {
  secret: boolean;
  query: string;
  exactMatch: boolean;
}

export type PGPSigVerification = {
  isSigned: boolean;
  verified: boolean;
  signer: User;
  signKey: PublicKey;
}

export type PGPSignOptions = {
  keyQuery: string;
  mode: SignMode;
  binaryIn: boolean;
  binaryOut: boolean;
}

export type PGPVerifyOptions = {
  signedBy: string;
  signature: bytes;
}

export type PassphraseStream = {
  passphraseStream: bytes;
  generation: int;
}

export type PassphraseType =
    0 // NONE_0
  | 1 // PAPER_KEY_1
  | 2 // PASS_PHRASE_2
  | 3 // VERIFY_PASS_PHRASE_3

export type PlatformInfo = {
  os: string;
  arch: string;
  goVersion: string;
}

export type ProblemSet = {
  user: User;
  kid: KID;
  tlfs?: ?Array<ProblemTLF>;
}

export type ProblemSetDevices = {
  problemSet: ProblemSet;
  devices?: ?Array<Device>;
}

export type ProblemTLF = {
  tlf: TLF;
  score: int;
  solution_kids?: ?Array<KID>;
}

export type Process = {
  pid: string;
  command: string;
  fileDescriptors?: ?Array<FileDescriptor>;
}

export type PromptDefault =
    0 // NONE_0
  | 1 // YES_1
  | 2 // NO_2

export type PromptOverwriteType =
    0 // SOCIAL_0
  | 1 // SITE_1

export type ProofResult = {
  state: ProofState;
  status: ProofStatus;
  desc: string;
}

export type ProofState =
    0 // NONE_0
  | 1 // OK_1
  | 2 // TEMP_FAILURE_2
  | 3 // PERM_FAILURE_3
  | 4 // LOOKING_4
  | 5 // SUPERSEDED_5
  | 6 // POSTED_6
  | 7 // REVOKED_7

export type ProofStatus =
    0 // NONE_0
  | 1 // OK_1
  | 2 // LOCAL_2
  | 3 // FOUND_3
  | 100 // BASE_ERROR_100
  | 101 // HOST_UNREACHABLE_101
  | 103 // PERMISSION_DENIED_103
  | 106 // FAILED_PARSE_106
  | 107 // DNS_ERROR_107
  | 108 // AUTH_FAILED_108
  | 129 // HTTP_429_129
  | 150 // HTTP_500_150
  | 160 // TIMEOUT_160
  | 170 // INTERNAL_ERROR_170
  | 200 // BASE_HARD_ERROR_200
  | 201 // NOT_FOUND_201
  | 202 // CONTENT_FAILURE_202
  | 203 // BAD_USERNAME_203
  | 204 // BAD_REMOTE_ID_204
  | 205 // TEXT_NOT_FOUND_205
  | 206 // BAD_ARGS_206
  | 207 // CONTENT_MISSING_207
  | 208 // TITLE_NOT_FOUND_208
  | 209 // SERVICE_ERROR_209
  | 210 // TOR_SKIPPED_210
  | 211 // TOR_INCOMPATIBLE_211
  | 230 // HTTP_300_230
  | 240 // HTTP_400_240
  | 260 // HTTP_OTHER_260
  | 270 // EMPTY_JSON_270
  | 301 // DELETED_301
  | 302 // SERVICE_DEAD_302
  | 303 // BAD_SIGNATURE_303
  | 304 // BAD_API_URL_304
  | 305 // UNKNOWN_TYPE_305
  | 306 // NO_HINT_306
  | 307 // BAD_HINT_TEXT_307

export type ProofType =
    0 // NONE_0
  | 1 // KEYBASE_1
  | 2 // TWITTER_2
  | 3 // GITHUB_3
  | 4 // REDDIT_4
  | 5 // COINBASE_5
  | 6 // HACKERNEWS_6
  | 1000 // GENERIC_WEB_SITE_1000
  | 1001 // DNS_1001
  | 1002 // PGP_1002
  | 100001 // ROOTER_100001

export type Proofs = {
  social?: ?Array<TrackProof>;
  web?: ?Array<WebProof>;
  publicKeys?: ?Array<PublicKey>;
}

export type ProvisionMethod =
    0 // DEVICE_0
  | 1 // PAPER_KEY_1
  | 2 // PASSPHRASE_2
  | 3 // GPG_IMPORT_3
  | 4 // GPG_SIGN_4

export type PublicKey = {
  KID: KID;
  PGPFingerprint: string;
  PGPIdentities?: ?Array<PGPIdentity>;
  isSibkey: boolean;
  isEldest: boolean;
  parentID: string;
  deviceID: DeviceID;
  deviceDescription: string;
  deviceType: string;
  cTime: Time;
  eTime: Time;
}

export type PushReason =
    0 // NONE_0
  | 1 // RECONNECTED_1
  | 2 // NEW_DATA_2

export type RemoteProof = {
  proofType: ProofType;
  key: string;
  value: string;
  displayMarkup: string;
  sigID: SigID;
  mTime: Time;
}

export type RevokedKey = {
  key: PublicKey;
  time: KeybaseTime;
  by: KID;
}

export type RevokedProof = {
  proof: RemoteProof;
  diff: TrackDiff;
}

export type SaltpackDecryptOptions = {
  interactive: boolean;
  forceRemoteCheck: boolean;
  usePaperKey: boolean;
}

export type SaltpackEncryptOptions = {
  recipients?: ?Array<string>;
  hideSelf: boolean;
  noSelfEncrypt: boolean;
  binary: boolean;
  hideRecipients: boolean;
}

export type SaltpackEncryptedMessageInfo = {
  devices?: ?Array<Device>;
  numAnonReceivers: int;
  receiverIsAnon: boolean;
  sender: SaltpackSender;
}

export type SaltpackSender = {
  uid: UID;
  username: string;
  senderType: SaltpackSenderType;
}

export type SaltpackSenderType =
    0 // NOT_TRACKED_0
  | 1 // UNKNOWN_1
  | 2 // ANONYMOUS_2
  | 3 // TRACKING_BROKE_3
  | 4 // TRACKING_OK_4
  | 5 // SELF_5

export type SaltpackSignOptions = {
  detached: boolean;
  binary: boolean;
}

export type SaltpackVerifyOptions = {
  signedBy: string;
  signature: bytes;
}

export type SearchComponent = {
  key: string;
  value: string;
  score: double;
}

export type SearchResult = {
  uid: UID;
  username: string;
  components?: ?Array<SearchComponent>;
  score: double;
}

export type SecretEntryArg = {
  desc: string;
  prompt: string;
  err: string;
  cancel: string;
  ok: string;
  reason: string;
  useSecretStore: boolean;
  showTyping: boolean;
}

export type SecretEntryRes = {
  text: string;
  canceled: boolean;
  storeSecret: boolean;
}

export type SecretKeys = {
  signing: NaclSigningKeyPrivate;
  encryption: NaclDHKeyPrivate;
}

export type SecretKeysGetSecretKeysResult = SecretKeys

export type SecretKeysGetSecretKeysRpc = $Exact<{
  method: 'SecretKeys.getSecretKeys',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: SecretKeysGetSecretKeysResult) => void)
}>

export type SecretResponse = {
  secret: bytes;
  phrase: string;
}

export type SelectKeyRes = {
  keyID: string;
  doSecretPush: boolean;
}

export type ServiceStatus = {
  version: string;
  label: string;
  pid: string;
  lastExitStatus: string;
  bundleVersion: string;
  installStatus: InstallStatus;
  installAction: InstallAction;
  status: Status;
}

export type ServicesStatus = {
  service?: ?Array<ServiceStatus>;
  kbfs?: ?Array<ServiceStatus>;
  updater?: ?Array<ServiceStatus>;
}

export type Session = {
  uid: UID;
  username: string;
  token: string;
  deviceSubkeyKid: KID;
  deviceSibkeyKid: KID;
}

export type SessionStatus = {
  SessionFor: string;
  Loaded: boolean;
  Cleared: boolean;
  SaltOnly: boolean;
  Expired: boolean;
}

export type SessionToken = string

export type Sig = {
  seqno: int;
  sigID: SigID;
  sigIDDisplay: string;
  type: string;
  cTime: Time;
  revoked: boolean;
  active: boolean;
  key: string;
  body: string;
}

export type SigHint = {
  remoteId: string;
  humanUrl: string;
  apiUrl: string;
  checkText: string;
}

export type SigID = string

export type SigListArgs = {
  sessionID: int;
  username: string;
  allKeys: boolean;
  types?: ?SigTypes;
  filterx: string;
  verbose: boolean;
  revoked: boolean;
}

export type SigTypes = {
  track: boolean;
  proof: boolean;
  cryptocurrency: boolean;
  isSelf: boolean;
}

export type SignMode =
    0 // ATTACHED_0
  | 1 // DETACHED_1
  | 2 // CLEAR_2

export type SignupRes = {
  passphraseOk: boolean;
  postOk: boolean;
  writeOk: boolean;
}

export type SocialAssertion = {
  user: string;
  service: SocialAssertionService;
}

export type SocialAssertionService = string

export type StartProofResult = {
  sigID: SigID;
}

export type Status = {
  code: int;
  name: string;
  desc: string;
  fields?: ?Array<StringKVPair>;
}

export type StatusCode =
    0 // SCOk_0
  | 201 // SCLoginRequired_201
  | 202 // SCBadSession_202
  | 203 // SCBadLoginUserNotFound_203
  | 204 // SCBadLoginPassword_204
  | 205 // SCNotFound_205
  | 210 // SCThrottleControl_210
  | 218 // SCGeneric_218
  | 235 // SCAlreadyLoggedIn_235
  | 237 // SCCanceled_237
  | 239 // SCInputCanceled_239
  | 274 // SCReloginRequired_274
  | 275 // SCResolutionFailed_275
  | 276 // SCProfileNotPublic_276
  | 277 // SCIdentifyFailed_277
  | 278 // SCTrackingBroke_278
  | 279 // SCWrongCryptoFormat_279
  | 280 // SCDecryptionError_280
  | 701 // SCBadSignupUsernameTaken_701
  | 707 // SCBadInvitationCode_707
  | 801 // SCMissingResult_801
  | 901 // SCKeyNotFound_901
  | 907 // SCKeyInUse_907
  | 913 // SCKeyBadGen_913
  | 914 // SCKeyNoSecret_914
  | 915 // SCKeyBadUIDs_915
  | 916 // SCKeyNoActive_916
  | 917 // SCKeyNoSig_917
  | 918 // SCKeyBadSig_918
  | 919 // SCKeyBadEldest_919
  | 920 // SCKeyNoEldest_920
  | 921 // SCKeyDuplicateUpdate_921
  | 922 // SCSibkeyAlreadyExists_922
  | 924 // SCDecryptionKeyNotFound_924
  | 927 // SCKeyNoPGPEncryption_927
  | 928 // SCKeyNoNaClEncryption_928
  | 929 // SCKeySyncedPGPNotFound_929
  | 930 // SCKeyNoMatchingGPG_930
  | 931 // SCKeyRevoked_931
  | 1301 // SCBadTrackSession_1301
  | 1409 // SCDeviceNotFound_1409
  | 1410 // SCDeviceMismatch_1410
  | 1411 // SCDeviceRequired_1411
  | 1413 // SCDevicePrevProvisioned_1413
  | 1414 // SCDeviceNoProvision_1414
  | 1501 // SCStreamExists_1501
  | 1502 // SCStreamNotFound_1502
  | 1503 // SCStreamWrongKind_1503
  | 1504 // SCStreamEOF_1504
  | 1600 // SCGenericAPIError_1600
  | 1601 // SCAPINetworkError_1601
  | 1602 // SCTimeout_1602
  | 1701 // SCProofError_1701
  | 1702 // SCIdentificationExpired_1702
  | 1703 // SCSelfNotFound_1703
  | 1704 // SCBadKexPhrase_1704
  | 1705 // SCNoUIDelegation_1705
  | 1706 // SCNoUI_1706
  | 1707 // SCGPGUnavailable_1707
  | 1800 // SCInvalidVersionError_1800
  | 1801 // SCOldVersionError_1801
  | 1802 // SCInvalidLocationError_1802
  | 1803 // SCServiceStatusError_1803
  | 1804 // SCInstallError_1804

export type Stream = {
  fd: int;
}

export type StringKVPair = {
  key: string;
  value: string;
}

export type TLF = {
  id: TLFID;
  name: string;
  writers?: ?Array<string>;
  readers?: ?Array<string>;
  isPrivate: boolean;
}

export type TLFID = string

export type Test = {
  reply: string;
}

export type Text = {
  data: string;
  markup: boolean;
}

export type Time = long

export type TrackDiff = {
  type: TrackDiffType;
  displayMarkup: string;
}

export type TrackDiffType =
    0 // NONE_0
  | 1 // ERROR_1
  | 2 // CLASH_2
  | 3 // REVOKED_3
  | 4 // UPGRADED_4
  | 5 // NEW_5
  | 6 // REMOTE_FAIL_6
  | 7 // REMOTE_WORKING_7
  | 8 // REMOTE_CHANGED_8
  | 9 // NEW_ELDEST_9
  | 10 // NONE_VIA_TEMPORARY_10

export type TrackOptions = {
  localOnly: boolean;
  bypassConfirm: boolean;
  forceRetrack: boolean;
  expiringLocal: boolean;
}

export type TrackProof = {
  proofType: string;
  proofName: string;
  idString: string;
}

export type TrackStatus =
    1 // NEW_OK_1
  | 2 // NEW_ZERO_PROOFS_2
  | 3 // NEW_FAIL_PROOFS_3
  | 4 // UPDATE_BROKEN_FAILED_PROOFS_4
  | 5 // UPDATE_NEW_PROOFS_5
  | 6 // UPDATE_OK_6
  | 7 // UPDATE_BROKEN_REVOKED_7

export type TrackSummary = {
  username: string;
  time: Time;
  isRemote: boolean;
}

export type TrackToken = string

export type Tracker = {
  tracker: UID;
  status: int;
  mTime: Time;
}

export type UID = string

export type UnboxAnyRes = {
  kid: KID;
  plaintext: Bytes32;
  index: int;
}

export type UninstallResult = {
  componentResults?: ?Array<ComponentResult>;
  status: Status;
}

export type User = {
  uid: UID;
  username: string;
}

export type UserCard = {
  following: int;
  followers: int;
  uid: UID;
  fullName: string;
  location: string;
  bio: string;
  website: string;
  twitter: string;
  youFollowThem: boolean;
  theyFollowYou: boolean;
}

export type UserPlusKeys = {
  uid: UID;
  username: string;
  deviceKeys?: ?Array<PublicKey>;
  revokedDeviceKeys?: ?Array<RevokedKey>;
  pgpKeyCount: int;
  uvv: UserVersionVector;
}

export type UserResolution = {
  assertion: SocialAssertion;
  userID: UID;
}

export type UserSummary = {
  uid: UID;
  username: string;
  thumbnail: string;
  idVersion: int;
  fullName: string;
  bio: string;
  proofs: Proofs;
  sigIDDisplay: string;
  trackTime: Time;
}

export type UserVersionVector = {
  id: long;
  sigHints: int;
  sigChain: long;
  cachedAt: Time;
  lastIdentifiedAt: Time;
}

export type VerifySessionRes = {
  uid: UID;
  sid: string;
  generated: int;
  lifetime: int;
}

export type WebProof = {
  hostname: string;
  protocols?: ?Array<string>;
}

export type accountPassphraseChangeResult = void

export type accountPassphraseChangeRpc = $Exact<{
  method: 'account.passphraseChange',
  param: {
    oldPassphrase: string,
    passphrase: string,
    force: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type accountPassphrasePromptResult = GetPassphraseRes

export type accountPassphrasePromptRpc = $Exact<{
  method: 'account.passphrasePrompt',
  param: {
    guiArg: GUIEntryArg
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: accountPassphrasePromptResult) => void)
}>

export type apiserverGetResult = APIRes

export type apiserverGetRpc = $Exact<{
  method: 'apiserver.Get',
  param: {
    endpoint: string,
    args?: ?Array<StringKVPair>,
    httpStatus?: ?Array<int>,
    appStatusCode?: ?Array<int>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: apiserverGetResult) => void)
}>

export type apiserverPostJSONResult = APIRes

export type apiserverPostJSONRpc = $Exact<{
  method: 'apiserver.PostJSON',
  param: {
    endpoint: string,
    args?: ?Array<StringKVPair>,
    JSONPayload?: ?Array<StringKVPair>,
    httpStatus?: ?Array<int>,
    appStatusCode?: ?Array<int>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: apiserverPostJSONResult) => void)
}>

export type apiserverPostResult = APIRes

export type apiserverPostRpc = $Exact<{
  method: 'apiserver.Post',
  param: {
    endpoint: string,
    args?: ?Array<StringKVPair>,
    httpStatus?: ?Array<int>,
    appStatusCode?: ?Array<int>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: apiserverPostResult) => void)
}>

export type blockAddReferenceResult = void

export type blockAddReferenceRpc = $Exact<{
  method: 'block.addReference',
  param: {
    folder: string,
    ref: BlockReference
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type blockArchiveReferenceResult = ?Array<BlockReference>

export type blockArchiveReferenceRpc = $Exact<{
  method: 'block.archiveReference',
  param: {
    folder: string,
    refs?: ?Array<BlockReference>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: blockArchiveReferenceResult) => void)
}>

export type blockArchiveReferenceWithCountResult = DowngradeReferenceRes

export type blockArchiveReferenceWithCountRpc = $Exact<{
  method: 'block.archiveReferenceWithCount',
  param: {
    folder: string,
    refs?: ?Array<BlockReference>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: blockArchiveReferenceWithCountResult) => void)
}>

export type blockAuthenticateSessionResult = void

export type blockAuthenticateSessionRpc = $Exact<{
  method: 'block.authenticateSession',
  param: {
    signature: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type blockDelReferenceResult = void

export type blockDelReferenceRpc = $Exact<{
  method: 'block.delReference',
  param: {
    folder: string,
    ref: BlockReference
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type blockDelReferenceWithCountResult = DowngradeReferenceRes

export type blockDelReferenceWithCountRpc = $Exact<{
  method: 'block.delReferenceWithCount',
  param: {
    folder: string,
    refs?: ?Array<BlockReference>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: blockDelReferenceWithCountResult) => void)
}>

export type blockGetBlockResult = GetBlockRes

export type blockGetBlockRpc = $Exact<{
  method: 'block.getBlock',
  param: {
    bid: BlockIdCombo,
    folder: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: blockGetBlockResult) => void)
}>

export type blockGetSessionChallengeResult = ChallengeInfo

export type blockGetSessionChallengeRpc = $Exact<{
  method: 'block.getSessionChallenge',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: blockGetSessionChallengeResult) => void)
}>

export type blockGetUserQuotaInfoResult = bytes

export type blockGetUserQuotaInfoRpc = $Exact<{
  method: 'block.getUserQuotaInfo',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: blockGetUserQuotaInfoResult) => void)
}>

export type blockPutBlockResult = void

export type blockPutBlockRpc = $Exact<{
  method: 'block.putBlock',
  param: {
    bid: BlockIdCombo,
    folder: string,
    blockKey: string,
    buf: bytes
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type configCheckAPIServerOutOfDateWarningResult = OutOfDateInfo

export type configCheckAPIServerOutOfDateWarningRpc = $Exact<{
  method: 'config.checkAPIServerOutOfDateWarning',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: configCheckAPIServerOutOfDateWarningResult) => void)
}>

export type configClearValueResult = void

export type configClearValueRpc = $Exact<{
  method: 'config.clearValue',
  param: {
    path: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type configGetConfigResult = Config

export type configGetConfigRpc = $Exact<{
  method: 'config.getConfig',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: configGetConfigResult) => void)
}>

export type configGetCurrentStatusResult = GetCurrentStatusRes

export type configGetCurrentStatusRpc = $Exact<{
  method: 'config.getCurrentStatus',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: configGetCurrentStatusResult) => void)
}>

export type configGetExtendedStatusResult = ExtendedStatus

export type configGetExtendedStatusRpc = $Exact<{
  method: 'config.getExtendedStatus',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: configGetExtendedStatusResult) => void)
}>

export type configGetValueResult = ConfigValue

export type configGetValueRpc = $Exact<{
  method: 'config.getValue',
  param: {
    path: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: configGetValueResult) => void)
}>

export type configHelloIAmResult = void

export type configHelloIAmRpc = $Exact<{
  method: 'config.helloIAm',
  param: {
    details: ClientDetails
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type configSetPathResult = void

export type configSetPathRpc = $Exact<{
  method: 'config.setPath',
  param: {
    path: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type configSetUserConfigResult = void

export type configSetUserConfigRpc = $Exact<{
  method: 'config.setUserConfig',
  param: {
    username: string,
    key: string,
    value: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type configSetValueResult = void

export type configSetValueRpc = $Exact<{
  method: 'config.setValue',
  param: {
    path: string,
    value: ConfigValue
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type cryptoSignED25519Result = ED25519SignatureInfo

export type cryptoSignED25519Rpc = $Exact<{
  method: 'crypto.signED25519',
  param: {
    msg: bytes,
    reason: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: cryptoSignED25519Result) => void)
}>

export type cryptoSignToStringResult = string

export type cryptoSignToStringRpc = $Exact<{
  method: 'crypto.signToString',
  param: {
    msg: bytes,
    reason: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: cryptoSignToStringResult) => void)
}>

export type cryptoUnboxBytes32AnyResult = UnboxAnyRes

export type cryptoUnboxBytes32AnyRpc = $Exact<{
  method: 'crypto.unboxBytes32Any',
  param: {
    bundles?: ?Array<CiphertextBundle>,
    reason: string,
    promptPaper: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: cryptoUnboxBytes32AnyResult) => void)
}>

export type cryptoUnboxBytes32Result = Bytes32

export type cryptoUnboxBytes32Rpc = $Exact<{
  method: 'crypto.unboxBytes32',
  param: {
    encryptedBytes32: EncryptedBytes32,
    nonce: BoxNonce,
    peersPublicKey: BoxPublicKey,
    reason: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: cryptoUnboxBytes32Result) => void)
}>

export type ctlDbNukeResult = void

export type ctlDbNukeRpc = $Exact<{
  method: 'ctl.dbNuke',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type ctlLogRotateResult = void

export type ctlLogRotateRpc = $Exact<{
  method: 'ctl.logRotate',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type ctlReloadResult = void

export type ctlReloadRpc = $Exact<{
  method: 'ctl.reload',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type ctlStopResult = void

export type ctlStopRpc = $Exact<{
  method: 'ctl.stop',
  param: {
    exitCode: ExitCode
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type debuggingFirstStepResult = FirstStepResult

export type debuggingFirstStepRpc = $Exact<{
  method: 'debugging.firstStep',
  param: {
    val: int
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: debuggingFirstStepResult) => void)
}>

export type debuggingIncrementResult = int

export type debuggingIncrementRpc = $Exact<{
  method: 'debugging.increment',
  param: {
    val: int
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: debuggingIncrementResult) => void)
}>

export type debuggingSecondStepResult = int

export type debuggingSecondStepRpc = $Exact<{
  method: 'debugging.secondStep',
  param: {
    val: int
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: debuggingSecondStepResult) => void)
}>

export type delegateUiCtlRegisterGregorFirehoseResult = void

export type delegateUiCtlRegisterGregorFirehoseRpc = $Exact<{
  method: 'delegateUiCtl.registerGregorFirehose',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type delegateUiCtlRegisterIdentifyUIResult = void

export type delegateUiCtlRegisterIdentifyUIRpc = $Exact<{
  method: 'delegateUiCtl.registerIdentifyUI',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type delegateUiCtlRegisterRekeyUIResult = void

export type delegateUiCtlRegisterRekeyUIRpc = $Exact<{
  method: 'delegateUiCtl.registerRekeyUI',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type delegateUiCtlRegisterSecretUIResult = void

export type delegateUiCtlRegisterSecretUIRpc = $Exact<{
  method: 'delegateUiCtl.registerSecretUI',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type delegateUiCtlRegisterUpdateUIResult = void

export type delegateUiCtlRegisterUpdateUIRpc = $Exact<{
  method: 'delegateUiCtl.registerUpdateUI',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type deviceCheckDeviceNameFormatResult = boolean

export type deviceCheckDeviceNameFormatRpc = $Exact<{
  method: 'device.checkDeviceNameFormat',
  param: {
    name: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: deviceCheckDeviceNameFormatResult) => void)
}>

export type deviceDeviceAddResult = void

export type deviceDeviceAddRpc = $Exact<{
  method: 'device.deviceAdd',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type deviceDeviceHistoryListResult = ?Array<DeviceDetail>

export type deviceDeviceHistoryListRpc = $Exact<{
  method: 'device.deviceHistoryList',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: deviceDeviceHistoryListResult) => void)
}>

export type deviceDeviceListResult = ?Array<Device>

export type deviceDeviceListRpc = $Exact<{
  method: 'device.deviceList',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: deviceDeviceListResult) => void)
}>

export type favoriteFavoriteAddResult = void

export type favoriteFavoriteAddRpc = $Exact<{
  method: 'favorite.favoriteAdd',
  param: {
    folder: Folder
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type favoriteFavoriteIgnoreResult = void

export type favoriteFavoriteIgnoreRpc = $Exact<{
  method: 'favorite.favoriteIgnore',
  param: {
    folder: Folder
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type favoriteGetFavoritesResult = FavoritesResult

export type favoriteGetFavoritesRpc = $Exact<{
  method: 'favorite.getFavorites',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: favoriteGetFavoritesResult) => void)
}>

export type fsListResult = ListResult

export type fsListRpc = $Exact<{
  method: 'fs.List',
  param: {
    path: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: fsListResult) => void)
}>

export type gpgUiConfirmDuplicateKeyChosenResult = boolean

export type gpgUiConfirmDuplicateKeyChosenRpc = $Exact<{
  method: 'gpgUi.confirmDuplicateKeyChosen',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: gpgUiConfirmDuplicateKeyChosenResult) => void)
}>

export type gpgUiSelectKeyAndPushOptionResult = SelectKeyRes

export type gpgUiSelectKeyAndPushOptionRpc = $Exact<{
  method: 'gpgUi.selectKeyAndPushOption',
  param: {
    keys?: ?Array<GPGKey>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: gpgUiSelectKeyAndPushOptionResult) => void)
}>

export type gpgUiSelectKeyResult = string

export type gpgUiSelectKeyRpc = $Exact<{
  method: 'gpgUi.selectKey',
  param: {
    keys?: ?Array<GPGKey>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: gpgUiSelectKeyResult) => void)
}>

export type gpgUiSignResult = string

export type gpgUiSignRpc = $Exact<{
  method: 'gpgUi.sign',
  param: {
    msg: bytes,
    fingerprint: bytes
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: gpgUiSignResult) => void)
}>

export type gpgUiWantToAddGPGKeyResult = boolean

export type gpgUiWantToAddGPGKeyRpc = $Exact<{
  method: 'gpgUi.wantToAddGPGKey',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: gpgUiWantToAddGPGKeyResult) => void)
}>

export type gregorGetStateResult = gregor1.State

export type gregorGetStateRpc = $Exact<{
  method: 'gregor.getState',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: gregorGetStateResult) => void)
}>

export type gregorUIPushOutOfBandMessagesResult = void

export type gregorUIPushOutOfBandMessagesRpc = $Exact<{
  method: 'gregorUI.pushOutOfBandMessages',
  param: {
    oobm?: ?Array<gregor1.OutOfBandMessage>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type gregorUIPushStateResult = void

export type gregorUIPushStateRpc = $Exact<{
  method: 'gregorUI.pushState',
  param: {
    state: gregor1.State,
    reason: PushReason
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyIdentify2Result = Identify2Res

export type identifyIdentify2Rpc = $Exact<{
  method: 'identify.identify2',
  param: {
    uid: UID,
    userAssertion: string,
    reason: IdentifyReason,
    useDelegateUI?: boolean,
    alwaysBlock?: boolean,
    noErrorOnTrackFailure?: boolean,
    forceRemoteCheck?: boolean,
    needProofSet?: boolean,
    allowEmptySelfID?: boolean,
    noSkipSelf?: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: identifyIdentify2Result) => void)
}>

export type identifyIdentifyResult = IdentifyRes

export type identifyIdentifyRpc = $Exact<{
  method: 'identify.identify',
  param: {
    userAssertion: string,
    forceRemoteCheck?: boolean,
    useDelegateUI?: boolean,
    reason: IdentifyReason,
    source: ClientType
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: identifyIdentifyResult) => void)
}>

export type identifyResolve2Result = User

export type identifyResolve2Rpc = $Exact<{
  method: 'identify.Resolve2',
  param: {
    assertion: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: identifyResolve2Result) => void)
}>

export type identifyResolveResult = UID

export type identifyResolveRpc = $Exact<{
  method: 'identify.Resolve',
  param: {
    assertion: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: identifyResolveResult) => void)
}>

export type identifyUiConfirmResult = ConfirmResult

export type identifyUiConfirmRpc = $Exact<{
  method: 'identifyUi.confirm',
  param: {
    outcome: IdentifyOutcome
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: identifyUiConfirmResult) => void)
}>

export type identifyUiDelegateIdentifyUIResult = int

export type identifyUiDelegateIdentifyUIRpc = $Exact<{
  method: 'identifyUi.delegateIdentifyUI',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: identifyUiDelegateIdentifyUIResult) => void)
}>

export type identifyUiDismissResult = void

export type identifyUiDismissRpc = $Exact<{
  method: 'identifyUi.dismiss',
  param: {
    username: string,
    reason: DismissReason
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiDisplayCryptocurrencyResult = void

export type identifyUiDisplayCryptocurrencyRpc = $Exact<{
  method: 'identifyUi.displayCryptocurrency',
  param: {
    c: Cryptocurrency
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiDisplayKeyResult = void

export type identifyUiDisplayKeyRpc = $Exact<{
  method: 'identifyUi.displayKey',
  param: {
    key: IdentifyKey
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiDisplayTLFCreateWithInviteResult = void

export type identifyUiDisplayTLFCreateWithInviteRpc = $Exact<{
  method: 'identifyUi.displayTLFCreateWithInvite',
  param: {
    folderName: string,
    isPrivate: boolean,
    assertion: string,
    socialAssertion: SocialAssertion,
    inviteLink: string,
    throttled: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiDisplayTrackStatementResult = void

export type identifyUiDisplayTrackStatementRpc = $Exact<{
  method: 'identifyUi.displayTrackStatement',
  param: {
    stmt: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiDisplayUserCardResult = void

export type identifyUiDisplayUserCardRpc = $Exact<{
  method: 'identifyUi.displayUserCard',
  param: {
    card: UserCard
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiFinishResult = void

export type identifyUiFinishRpc = $Exact<{
  method: 'identifyUi.finish',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiFinishSocialProofCheckResult = void

export type identifyUiFinishSocialProofCheckRpc = $Exact<{
  method: 'identifyUi.finishSocialProofCheck',
  param: {
    rp: RemoteProof,
    lcr: LinkCheckResult
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiFinishWebProofCheckResult = void

export type identifyUiFinishWebProofCheckRpc = $Exact<{
  method: 'identifyUi.finishWebProofCheck',
  param: {
    rp: RemoteProof,
    lcr: LinkCheckResult
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiLaunchNetworkChecksResult = void

export type identifyUiLaunchNetworkChecksRpc = $Exact<{
  method: 'identifyUi.launchNetworkChecks',
  param: {
    identity: Identity,
    user: User
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiReportLastTrackResult = void

export type identifyUiReportLastTrackRpc = $Exact<{
  method: 'identifyUi.reportLastTrack',
  param: {
    track: (null | TrackSummary)
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiReportTrackTokenResult = void

export type identifyUiReportTrackTokenRpc = $Exact<{
  method: 'identifyUi.reportTrackToken',
  param: {
    trackToken: TrackToken
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type identifyUiStartResult = void

export type identifyUiStartRpc = $Exact<{
  method: 'identifyUi.start',
  param: {
    username: string,
    reason: IdentifyReason
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type kbfsFSEventResult = void

export type kbfsFSEventRpc = $Exact<{
  method: 'kbfs.FSEvent',
  param: {
    event: FSNotification
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type logRegisterLoggerResult = void

export type logRegisterLoggerRpc = $Exact<{
  method: 'log.registerLogger',
  param: {
    name: string,
    level: LogLevel
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type logUiLogResult = void

export type logUiLogRpc = $Exact<{
  method: 'logUi.log',
  param: {
    level: LogLevel,
    text: Text
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginClearStoredSecretResult = void

export type loginClearStoredSecretRpc = $Exact<{
  method: 'login.clearStoredSecret',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginDeprovisionResult = void

export type loginDeprovisionRpc = $Exact<{
  method: 'login.deprovision',
  param: {
    username: string,
    doRevoke: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginGetConfiguredAccountsResult = ?Array<ConfiguredAccount>

export type loginGetConfiguredAccountsRpc = $Exact<{
  method: 'login.getConfiguredAccounts',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: loginGetConfiguredAccountsResult) => void)
}>

export type loginLoginResult = void

export type loginLoginRpc = $Exact<{
  method: 'login.login',
  param: {
    deviceType: string,
    usernameOrEmail: string,
    clientType: ClientType
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginLogoutResult = void

export type loginLogoutRpc = $Exact<{
  method: 'login.logout',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginPaperKeyResult = void

export type loginPaperKeyRpc = $Exact<{
  method: 'login.paperKey',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginPaperKeySubmitResult = void

export type loginPaperKeySubmitRpc = $Exact<{
  method: 'login.paperKeySubmit',
  param: {
    paperPhrase: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginPgpProvisionResult = void

export type loginPgpProvisionRpc = $Exact<{
  method: 'login.pgpProvision',
  param: {
    username: string,
    passphrase: string,
    deviceName: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginRecoverAccountFromEmailAddressResult = void

export type loginRecoverAccountFromEmailAddressRpc = $Exact<{
  method: 'login.recoverAccountFromEmailAddress',
  param: {
    email: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginUiDisplayPaperKeyPhraseResult = void

export type loginUiDisplayPaperKeyPhraseRpc = $Exact<{
  method: 'loginUi.displayPaperKeyPhrase',
  param: {
    phrase: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginUiDisplayPrimaryPaperKeyResult = void

export type loginUiDisplayPrimaryPaperKeyRpc = $Exact<{
  method: 'loginUi.displayPrimaryPaperKey',
  param: {
    phrase: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginUiGetEmailOrUsernameResult = string

export type loginUiGetEmailOrUsernameRpc = $Exact<{
  method: 'loginUi.getEmailOrUsername',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: loginUiGetEmailOrUsernameResult) => void)
}>

export type loginUiPromptRevokePaperKeysResult = boolean

export type loginUiPromptRevokePaperKeysRpc = $Exact<{
  method: 'loginUi.promptRevokePaperKeys',
  param: {
    device: Device,
    index: int
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: loginUiPromptRevokePaperKeysResult) => void)
}>

export type loginUnlockResult = void

export type loginUnlockRpc = $Exact<{
  method: 'login.unlock',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type loginUnlockWithPassphraseResult = void

export type loginUnlockWithPassphraseRpc = $Exact<{
  method: 'login.unlockWithPassphrase',
  param: {
    passphrase: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataAuthenticateResult = int

export type metadataAuthenticateRpc = $Exact<{
  method: 'metadata.authenticate',
  param: {
    signature: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataAuthenticateResult) => void)
}>

export type metadataDeleteKeyResult = void

export type metadataDeleteKeyRpc = $Exact<{
  method: 'metadata.deleteKey',
  param: {
    uid: UID,
    deviceKID: KID,
    keyHalfID: bytes,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataGetChallengeResult = ChallengeInfo

export type metadataGetChallengeRpc = $Exact<{
  method: 'metadata.getChallenge',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetChallengeResult) => void)
}>

export type metadataGetFolderHandleResult = bytes

export type metadataGetFolderHandleRpc = $Exact<{
  method: 'metadata.getFolderHandle',
  param: {
    folderID: string,
    signature: string,
    challenge: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetFolderHandleResult) => void)
}>

export type metadataGetFoldersForRekeyResult = void

export type metadataGetFoldersForRekeyRpc = $Exact<{
  method: 'metadata.getFoldersForRekey',
  param: {
    deviceKID: KID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataGetKeyResult = bytes

export type metadataGetKeyRpc = $Exact<{
  method: 'metadata.getKey',
  param: {
    keyHalfID: bytes,
    deviceKID: string,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetKeyResult) => void)
}>

export type metadataGetLatestFolderHandleResult = bytes

export type metadataGetLatestFolderHandleRpc = $Exact<{
  method: 'metadata.getLatestFolderHandle',
  param: {
    folderID: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetLatestFolderHandleResult) => void)
}>

export type metadataGetMerkleNodeResult = bytes

export type metadataGetMerkleNodeRpc = $Exact<{
  method: 'metadata.getMerkleNode',
  param: {
    hash: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetMerkleNodeResult) => void)
}>

export type metadataGetMerkleRootLatestResult = MerkleRoot

export type metadataGetMerkleRootLatestRpc = $Exact<{
  method: 'metadata.getMerkleRootLatest',
  param: {
    treeID: MerkleTreeID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetMerkleRootLatestResult) => void)
}>

export type metadataGetMerkleRootResult = MerkleRoot

export type metadataGetMerkleRootRpc = $Exact<{
  method: 'metadata.getMerkleRoot',
  param: {
    treeID: MerkleTreeID,
    seqNo: long
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetMerkleRootResult) => void)
}>

export type metadataGetMerkleRootSinceResult = MerkleRoot

export type metadataGetMerkleRootSinceRpc = $Exact<{
  method: 'metadata.getMerkleRootSince',
  param: {
    treeID: MerkleTreeID,
    when: Time
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetMerkleRootSinceResult) => void)
}>

export type metadataGetMetadataResult = MetadataResponse

export type metadataGetMetadataRpc = $Exact<{
  method: 'metadata.getMetadata',
  param: {
    folderID: string,
    folderHandle: bytes,
    branchID: string,
    unmerged: boolean,
    startRevision: long,
    stopRevision: long,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataGetMetadataResult) => void)
}>

export type metadataPingResult = void

export type metadataPingRpc = $Exact<{
  method: 'metadata.ping',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataPruneBranchResult = void

export type metadataPruneBranchRpc = $Exact<{
  method: 'metadata.pruneBranch',
  param: {
    folderID: string,
    branchID: string,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataPutKeysResult = void

export type metadataPutKeysRpc = $Exact<{
  method: 'metadata.putKeys',
  param: {
    keyHalves?: ?Array<KeyHalf>,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataPutMetadataResult = void

export type metadataPutMetadataRpc = $Exact<{
  method: 'metadata.putMetadata',
  param: {
    mdBlock: MDBlock,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataRegisterForUpdatesResult = void

export type metadataRegisterForUpdatesRpc = $Exact<{
  method: 'metadata.registerForUpdates',
  param: {
    folderID: string,
    currRevision: long,
    logTags: {[key: string]: string}
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataTruncateLockResult = boolean

export type metadataTruncateLockRpc = $Exact<{
  method: 'metadata.truncateLock',
  param: {
    folderID: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataTruncateLockResult) => void)
}>

export type metadataTruncateUnlockResult = boolean

export type metadataTruncateUnlockRpc = $Exact<{
  method: 'metadata.truncateUnlock',
  param: {
    folderID: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: metadataTruncateUnlockResult) => void)
}>

export type metadataUpdateFolderNeedsRekeyResult = void

export type metadataUpdateFolderNeedsRekeyRpc = $Exact<{
  method: 'metadataUpdate.folderNeedsRekey',
  param: {
    folderID: string,
    revision: long
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type metadataUpdateMetadataUpdateResult = void

export type metadataUpdateMetadataUpdateRpc = $Exact<{
  method: 'metadataUpdate.metadataUpdate',
  param: {
    folderID: string,
    revision: long
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type notifyCtlSetNotificationsResult = void

export type notifyCtlSetNotificationsRpc = $Exact<{
  method: 'notifyCtl.setNotifications',
  param: {
    channels: NotificationChannels
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type paperprovisionPaperProvisionResult = void

export type paperprovisionPaperProvisionRpc = $Exact<{
  method: 'paperprovision.paperProvision',
  param: {
    username: string,
    deviceName: string,
    paperKey: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpDecryptResult = PGPSigVerification

export type pgpPgpDecryptRpc = $Exact<{
  method: 'pgp.pgpDecrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: PGPDecryptOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: pgpPgpDecryptResult) => void)
}>

export type pgpPgpDeletePrimaryResult = void

export type pgpPgpDeletePrimaryRpc = $Exact<{
  method: 'pgp.pgpDeletePrimary',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpEncryptResult = void

export type pgpPgpEncryptRpc = $Exact<{
  method: 'pgp.pgpEncrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: PGPEncryptOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpExportByFingerprintResult = ?Array<KeyInfo>

export type pgpPgpExportByFingerprintRpc = $Exact<{
  method: 'pgp.pgpExportByFingerprint',
  param: {
    options: PGPQuery
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: pgpPgpExportByFingerprintResult) => void)
}>

export type pgpPgpExportByKIDResult = ?Array<KeyInfo>

export type pgpPgpExportByKIDRpc = $Exact<{
  method: 'pgp.pgpExportByKID',
  param: {
    options: PGPQuery
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: pgpPgpExportByKIDResult) => void)
}>

export type pgpPgpExportResult = ?Array<KeyInfo>

export type pgpPgpExportRpc = $Exact<{
  method: 'pgp.pgpExport',
  param: {
    options: PGPQuery
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: pgpPgpExportResult) => void)
}>

export type pgpPgpImportResult = void

export type pgpPgpImportRpc = $Exact<{
  method: 'pgp.pgpImport',
  param: {
    key: bytes,
    pushSecret: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpKeyGenResult = void

export type pgpPgpKeyGenRpc = $Exact<{
  method: 'pgp.pgpKeyGen',
  param: {
    primaryBits: int,
    subkeyBits: int,
    createUids: PGPCreateUids,
    allowMulti: boolean,
    doExport: boolean,
    pushSecret: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpPullResult = void

export type pgpPgpPullRpc = $Exact<{
  method: 'pgp.pgpPull',
  param: {
    userAsserts?: ?Array<string>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpSelectResult = void

export type pgpPgpSelectRpc = $Exact<{
  method: 'pgp.pgpSelect',
  param: {
    fingerprintQuery: string,
    allowMulti: boolean,
    skipImport: boolean,
    onlyImport: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpSignResult = void

export type pgpPgpSignRpc = $Exact<{
  method: 'pgp.pgpSign',
  param: {
    source: Stream,
    sink: Stream,
    opts: PGPSignOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpUpdateResult = void

export type pgpPgpUpdateRpc = $Exact<{
  method: 'pgp.pgpUpdate',
  param: {
    all: boolean,
    fingerprints?: ?Array<string>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type pgpPgpVerifyResult = PGPSigVerification

export type pgpPgpVerifyRpc = $Exact<{
  method: 'pgp.pgpVerify',
  param: {
    source: Stream,
    opts: PGPVerifyOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: pgpPgpVerifyResult) => void)
}>

export type pgpUiOutputSignatureSuccessResult = void

export type pgpUiOutputSignatureSuccessRpc = $Exact<{
  method: 'pgpUi.outputSignatureSuccess',
  param: {
    fingerprint: string,
    username: string,
    signedAt: Time
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type proveCheckProofResult = CheckProofStatus

export type proveCheckProofRpc = $Exact<{
  method: 'prove.checkProof',
  param: {
    sigID: SigID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: proveCheckProofResult) => void)
}>

export type proveStartProofResult = StartProofResult

export type proveStartProofRpc = $Exact<{
  method: 'prove.startProof',
  param: {
    service: string,
    username: string,
    force: boolean,
    promptPosted: boolean,
    auto: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: proveStartProofResult) => void)
}>

export type proveUiDisplayRecheckWarningResult = void

export type proveUiDisplayRecheckWarningRpc = $Exact<{
  method: 'proveUi.displayRecheckWarning',
  param: {
    text: Text
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type proveUiOkToCheckResult = boolean

export type proveUiOkToCheckRpc = $Exact<{
  method: 'proveUi.okToCheck',
  param: {
    name: string,
    attempt: int
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: proveUiOkToCheckResult) => void)
}>

export type proveUiOutputInstructionsResult = void

export type proveUiOutputInstructionsRpc = $Exact<{
  method: 'proveUi.outputInstructions',
  param: {
    instructions: Text,
    proof: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type proveUiOutputPrechecksResult = void

export type proveUiOutputPrechecksRpc = $Exact<{
  method: 'proveUi.outputPrechecks',
  param: {
    text: Text
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type proveUiPreProofWarningResult = boolean

export type proveUiPreProofWarningRpc = $Exact<{
  method: 'proveUi.preProofWarning',
  param: {
    text: Text
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: proveUiPreProofWarningResult) => void)
}>

export type proveUiPromptOverwriteResult = boolean

export type proveUiPromptOverwriteRpc = $Exact<{
  method: 'proveUi.promptOverwrite',
  param: {
    account: string,
    typ: PromptOverwriteType
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: proveUiPromptOverwriteResult) => void)
}>

export type proveUiPromptUsernameResult = string

export type proveUiPromptUsernameRpc = $Exact<{
  method: 'proveUi.promptUsername',
  param: {
    prompt: string,
    prevError: (null | Status)
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: proveUiPromptUsernameResult) => void)
}>

export type provisionUiChooseDeviceResult = DeviceID

export type provisionUiChooseDeviceRpc = $Exact<{
  method: 'provisionUi.chooseDevice',
  param: {
    devices?: ?Array<Device>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiChooseDeviceResult) => void)
}>

export type provisionUiChooseDeviceTypeResult = DeviceType

export type provisionUiChooseDeviceTypeRpc = $Exact<{
  method: 'provisionUi.chooseDeviceType',
  param: {
    kind: ChooseType
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiChooseDeviceTypeResult) => void)
}>

export type provisionUiChooseGPGMethodResult = GPGMethod

export type provisionUiChooseGPGMethodRpc = $Exact<{
  method: 'provisionUi.chooseGPGMethod',
  param: {
    keys?: ?Array<GPGKey>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiChooseGPGMethodResult) => void)
}>

export type provisionUiChooseProvisioningMethodResult = ProvisionMethod

export type provisionUiChooseProvisioningMethodRpc = $Exact<{
  method: 'provisionUi.chooseProvisioningMethod',
  param: {
    gpgOption: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiChooseProvisioningMethodResult) => void)
}>

export type provisionUiDisplayAndPromptSecretResult = SecretResponse

export type provisionUiDisplayAndPromptSecretRpc = $Exact<{
  method: 'provisionUi.DisplayAndPromptSecret',
  param: {
    secret: bytes,
    phrase: string,
    otherDeviceType: DeviceType
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiDisplayAndPromptSecretResult) => void)
}>

export type provisionUiDisplaySecretExchangedResult = void

export type provisionUiDisplaySecretExchangedRpc = $Exact<{
  method: 'provisionUi.DisplaySecretExchanged',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type provisionUiPromptNewDeviceNameResult = string

export type provisionUiPromptNewDeviceNameRpc = $Exact<{
  method: 'provisionUi.PromptNewDeviceName',
  param: {
    existingDevices?: ?Array<string>,
    errorMessage: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiPromptNewDeviceNameResult) => void)
}>

export type provisionUiProvisioneeSuccessResult = void

export type provisionUiProvisioneeSuccessRpc = $Exact<{
  method: 'provisionUi.ProvisioneeSuccess',
  param: {
    username: string,
    deviceName: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type provisionUiProvisionerSuccessResult = void

export type provisionUiProvisionerSuccessRpc = $Exact<{
  method: 'provisionUi.ProvisionerSuccess',
  param: {
    deviceName: string,
    deviceType: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type provisionUiSwitchToGPGSignOKResult = boolean

export type provisionUiSwitchToGPGSignOKRpc = $Exact<{
  method: 'provisionUi.switchToGPGSignOK',
  param: {
    key: GPGKey,
    importError: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: provisionUiSwitchToGPGSignOKResult) => void)
}>

export type quotaVerifySessionResult = VerifySessionRes

export type quotaVerifySessionRpc = $Exact<{
  method: 'quota.verifySession',
  param: {
    session: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: quotaVerifySessionResult) => void)
}>

export type rekeyDebugShowRekeyStatusResult = void

export type rekeyDebugShowRekeyStatusRpc = $Exact<{
  method: 'rekey.debugShowRekeyStatus',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type rekeyGetPendingRekeyStatusResult = ProblemSetDevices

export type rekeyGetPendingRekeyStatusRpc = $Exact<{
  method: 'rekey.getPendingRekeyStatus',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: rekeyGetPendingRekeyStatusResult) => void)
}>

export type rekeyRekeyStatusFinishResult = Outcome

export type rekeyRekeyStatusFinishRpc = $Exact<{
  method: 'rekey.rekeyStatusFinish',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: rekeyRekeyStatusFinishResult) => void)
}>

export type rekeyShowPendingRekeyStatusResult = void

export type rekeyShowPendingRekeyStatusRpc = $Exact<{
  method: 'rekey.showPendingRekeyStatus',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type rekeyUIDelegateRekeyUIResult = int

export type rekeyUIDelegateRekeyUIRpc = $Exact<{
  method: 'rekeyUI.delegateRekeyUI',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: rekeyUIDelegateRekeyUIResult) => void)
}>

export type rekeyUIRefreshResult = void

export type rekeyUIRefreshRpc = $Exact<{
  method: 'rekeyUI.refresh',
  param: {
    problemSetDevices: ProblemSetDevices
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type revokeRevokeDeviceResult = void

export type revokeRevokeDeviceRpc = $Exact<{
  method: 'revoke.revokeDevice',
  param: {
    deviceID: DeviceID,
    force: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type revokeRevokeKeyResult = void

export type revokeRevokeKeyRpc = $Exact<{
  method: 'revoke.revokeKey',
  param: {
    keyID: KID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type revokeRevokeSigsResult = void

export type revokeRevokeSigsRpc = $Exact<{
  method: 'revoke.revokeSigs',
  param: {
    sigIDQueries?: ?Array<string>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type saltpackSaltpackDecryptResult = SaltpackEncryptedMessageInfo

export type saltpackSaltpackDecryptRpc = $Exact<{
  method: 'saltpack.saltpackDecrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackDecryptOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: saltpackSaltpackDecryptResult) => void)
}>

export type saltpackSaltpackEncryptResult = void

export type saltpackSaltpackEncryptRpc = $Exact<{
  method: 'saltpack.saltpackEncrypt',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackEncryptOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type saltpackSaltpackSignResult = void

export type saltpackSaltpackSignRpc = $Exact<{
  method: 'saltpack.saltpackSign',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackSignOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type saltpackSaltpackVerifyResult = void

export type saltpackSaltpackVerifyRpc = $Exact<{
  method: 'saltpack.saltpackVerify',
  param: {
    source: Stream,
    sink: Stream,
    opts: SaltpackVerifyOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type saltpackUiSaltpackPromptForDecryptResult = void

export type saltpackUiSaltpackPromptForDecryptRpc = $Exact<{
  method: 'saltpackUi.saltpackPromptForDecrypt',
  param: {
    sender: SaltpackSender,
    usedDelegateUI: bool
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type saltpackUiSaltpackVerifySuccessResult = void

export type saltpackUiSaltpackVerifySuccessRpc = $Exact<{
  method: 'saltpackUi.saltpackVerifySuccess',
  param: {
    signingKID: KID,
    sender: SaltpackSender
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type secretUiGetPassphraseResult = GetPassphraseRes

export type secretUiGetPassphraseRpc = $Exact<{
  method: 'secretUi.getPassphrase',
  param: {
    pinentry: GUIEntryArg,
    terminal: (null | SecretEntryArg)
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: secretUiGetPassphraseResult) => void)
}>

export type sessionCurrentSessionResult = Session

export type sessionCurrentSessionRpc = $Exact<{
  method: 'session.currentSession',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: sessionCurrentSessionResult) => void)
}>

export type signupCheckInvitationCodeResult = void

export type signupCheckInvitationCodeRpc = $Exact<{
  method: 'signup.checkInvitationCode',
  param: {
    invitationCode: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type signupCheckUsernameAvailableResult = void

export type signupCheckUsernameAvailableRpc = $Exact<{
  method: 'signup.checkUsernameAvailable',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type signupInviteRequestResult = void

export type signupInviteRequestRpc = $Exact<{
  method: 'signup.inviteRequest',
  param: {
    email: string,
    fullname: string,
    notes: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type signupSignupResult = SignupRes

export type signupSignupRpc = $Exact<{
  method: 'signup.signup',
  param: {
    email: string,
    inviteCode: string,
    passphrase: string,
    username: string,
    deviceName: string,
    storeSecret: boolean,
    skipMail: boolean,
    genPGPBatch: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: signupSignupResult) => void)
}>

export type sigsSigListJSONResult = string

export type sigsSigListJSONRpc = $Exact<{
  method: 'sigs.sigListJSON',
  param: {
    arg: SigListArgs
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: sigsSigListJSONResult) => void)
}>

export type sigsSigListResult = ?Array<Sig>

export type sigsSigListRpc = $Exact<{
  method: 'sigs.sigList',
  param: {
    arg: SigListArgs
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: sigsSigListResult) => void)
}>

export type streamUiCloseResult = void

export type streamUiCloseRpc = $Exact<{
  method: 'streamUi.close',
  param: {
    s: Stream
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type streamUiReadResult = bytes

export type streamUiReadRpc = $Exact<{
  method: 'streamUi.read',
  param: {
    s: Stream,
    sz: int
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: streamUiReadResult) => void)
}>

export type streamUiWriteResult = int

export type streamUiWriteRpc = $Exact<{
  method: 'streamUi.write',
  param: {
    s: Stream,
    buf: bytes
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: streamUiWriteResult) => void)
}>

export type testPanicResult = void

export type testPanicRpc = $Exact<{
  method: 'test.panic',
  param: {
    message: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type testTestCallbackResult = string

export type testTestCallbackRpc = $Exact<{
  method: 'test.testCallback',
  param: {
    name: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: testTestCallbackResult) => void)
}>

export type testTestResult = Test

export type testTestRpc = $Exact<{
  method: 'test.test',
  param: {
    name: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: testTestResult) => void)
}>

export type trackCheckTrackingResult = void

export type trackCheckTrackingRpc = $Exact<{
  method: 'track.checkTracking',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type trackDismissWithTokenResult = void

export type trackDismissWithTokenRpc = $Exact<{
  method: 'track.dismissWithToken',
  param: {
    trackToken: TrackToken
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type trackFakeTrackingChangedResult = void

export type trackFakeTrackingChangedRpc = $Exact<{
  method: 'track.fakeTrackingChanged',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type trackTrackResult = void

export type trackTrackRpc = $Exact<{
  method: 'track.track',
  param: {
    userAssertion: string,
    options: TrackOptions,
    forceRemoteCheck: boolean
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type trackTrackWithTokenResult = void

export type trackTrackWithTokenRpc = $Exact<{
  method: 'track.trackWithToken',
  param: {
    trackToken: TrackToken,
    options: TrackOptions
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type trackUntrackResult = void

export type trackUntrackRpc = $Exact<{
  method: 'track.untrack',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any) => void)
}>

export type uiPromptYesNoResult = boolean

export type uiPromptYesNoRpc = $Exact<{
  method: 'ui.promptYesNo',
  param: {
    text: Text,
    promptDefault: PromptDefault
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: uiPromptYesNoResult) => void)
}>

export type userListTrackersByNameResult = ?Array<Tracker>

export type userListTrackersByNameRpc = $Exact<{
  method: 'user.listTrackersByName',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userListTrackersByNameResult) => void)
}>

export type userListTrackersResult = ?Array<Tracker>

export type userListTrackersRpc = $Exact<{
  method: 'user.listTrackers',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userListTrackersResult) => void)
}>

export type userListTrackersSelfResult = ?Array<Tracker>

export type userListTrackersSelfRpc = $Exact<{
  method: 'user.listTrackersSelf',
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userListTrackersSelfResult) => void)
}>

export type userListTrackingJSONResult = string

export type userListTrackingJSONRpc = $Exact<{
  method: 'user.listTrackingJSON',
  param: {
    filter: string,
    verbose: boolean,
    assertion: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userListTrackingJSONResult) => void)
}>

export type userListTrackingResult = ?Array<UserSummary>

export type userListTrackingRpc = $Exact<{
  method: 'user.listTracking',
  param: {
    filter: string,
    assertion: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userListTrackingResult) => void)
}>

export type userLoadAllPublicKeysUnverifiedResult = ?Array<PublicKey>

export type userLoadAllPublicKeysUnverifiedRpc = $Exact<{
  method: 'user.loadAllPublicKeysUnverified',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userLoadAllPublicKeysUnverifiedResult) => void)
}>

export type userLoadPublicKeysResult = ?Array<PublicKey>

export type userLoadPublicKeysRpc = $Exact<{
  method: 'user.loadPublicKeys',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userLoadPublicKeysResult) => void)
}>

export type userLoadUncheckedUserSummariesResult = ?Array<UserSummary>

export type userLoadUncheckedUserSummariesRpc = $Exact<{
  method: 'user.loadUncheckedUserSummaries',
  param: {
    uids?: ?Array<UID>
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userLoadUncheckedUserSummariesResult) => void)
}>

export type userLoadUserByNameResult = User

export type userLoadUserByNameRpc = $Exact<{
  method: 'user.loadUserByName',
  param: {
    username: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userLoadUserByNameResult) => void)
}>

export type userLoadUserPlusKeysResult = UserPlusKeys

export type userLoadUserPlusKeysRpc = $Exact<{
  method: 'user.loadUserPlusKeys',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userLoadUserPlusKeysResult) => void)
}>

export type userLoadUserResult = User

export type userLoadUserRpc = $Exact<{
  method: 'user.loadUser',
  param: {
    uid: UID
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userLoadUserResult) => void)
}>

export type userSearchResult = ?Array<SearchResult>

export type userSearchRpc = $Exact<{
  method: 'user.search',
  param: {
    query: string
  },
  waitingHandler?: (waiting: boolean, method: string, sessionID: string) => void,
  incomingCallMap?: incomingCallMapType,
  callback: (null | (err: ?any, response: userSearchResult) => void)
}>

export type rpc =
    BTCRegisterBTCRpc
  | Kex2ProvisioneeDidCounterSignRpc
  | Kex2ProvisioneeHelloRpc
  | Kex2ProvisionerKexStartRpc
  | NotifyFSFSActivityRpc
  | NotifyFavoritesFavoritesChangedRpc
  | NotifyKeyfamilyKeyfamilyChangedRpc
  | NotifyPaperKeyPaperKeyCachedRpc
  | NotifyServiceShutdownRpc
  | NotifySessionClientOutOfDateRpc
  | NotifySessionLoggedInRpc
  | NotifySessionLoggedOutRpc
  | NotifyTrackingTrackingChangedRpc
  | NotifyUsersUserChangedRpc
  | SecretKeysGetSecretKeysRpc
  | accountPassphraseChangeRpc
  | accountPassphrasePromptRpc
  | apiserverGetRpc
  | apiserverPostJSONRpc
  | apiserverPostRpc
  | blockAddReferenceRpc
  | blockArchiveReferenceRpc
  | blockArchiveReferenceWithCountRpc
  | blockAuthenticateSessionRpc
  | blockDelReferenceRpc
  | blockDelReferenceWithCountRpc
  | blockGetBlockRpc
  | blockGetSessionChallengeRpc
  | blockGetUserQuotaInfoRpc
  | blockPutBlockRpc
  | configCheckAPIServerOutOfDateWarningRpc
  | configClearValueRpc
  | configGetConfigRpc
  | configGetCurrentStatusRpc
  | configGetExtendedStatusRpc
  | configGetValueRpc
  | configHelloIAmRpc
  | configSetPathRpc
  | configSetUserConfigRpc
  | configSetValueRpc
  | cryptoSignED25519Rpc
  | cryptoSignToStringRpc
  | cryptoUnboxBytes32AnyRpc
  | cryptoUnboxBytes32Rpc
  | ctlDbNukeRpc
  | ctlLogRotateRpc
  | ctlReloadRpc
  | ctlStopRpc
  | debuggingFirstStepRpc
  | debuggingIncrementRpc
  | debuggingSecondStepRpc
  | delegateUiCtlRegisterGregorFirehoseRpc
  | delegateUiCtlRegisterIdentifyUIRpc
  | delegateUiCtlRegisterRekeyUIRpc
  | delegateUiCtlRegisterSecretUIRpc
  | delegateUiCtlRegisterUpdateUIRpc
  | deviceCheckDeviceNameFormatRpc
  | deviceDeviceAddRpc
  | deviceDeviceHistoryListRpc
  | deviceDeviceListRpc
  | favoriteFavoriteAddRpc
  | favoriteFavoriteIgnoreRpc
  | favoriteGetFavoritesRpc
  | fsListRpc
  | gpgUiConfirmDuplicateKeyChosenRpc
  | gpgUiSelectKeyAndPushOptionRpc
  | gpgUiSelectKeyRpc
  | gpgUiSignRpc
  | gpgUiWantToAddGPGKeyRpc
  | gregorGetStateRpc
  | gregorUIPushOutOfBandMessagesRpc
  | gregorUIPushStateRpc
  | identifyIdentify2Rpc
  | identifyIdentifyRpc
  | identifyResolve2Rpc
  | identifyResolveRpc
  | identifyUiConfirmRpc
  | identifyUiDelegateIdentifyUIRpc
  | identifyUiDismissRpc
  | identifyUiDisplayCryptocurrencyRpc
  | identifyUiDisplayKeyRpc
  | identifyUiDisplayTLFCreateWithInviteRpc
  | identifyUiDisplayTrackStatementRpc
  | identifyUiDisplayUserCardRpc
  | identifyUiFinishRpc
  | identifyUiFinishSocialProofCheckRpc
  | identifyUiFinishWebProofCheckRpc
  | identifyUiLaunchNetworkChecksRpc
  | identifyUiReportLastTrackRpc
  | identifyUiReportTrackTokenRpc
  | identifyUiStartRpc
  | kbfsFSEventRpc
  | logRegisterLoggerRpc
  | logUiLogRpc
  | loginClearStoredSecretRpc
  | loginDeprovisionRpc
  | loginGetConfiguredAccountsRpc
  | loginLoginRpc
  | loginLogoutRpc
  | loginPaperKeyRpc
  | loginPaperKeySubmitRpc
  | loginPgpProvisionRpc
  | loginRecoverAccountFromEmailAddressRpc
  | loginUiDisplayPaperKeyPhraseRpc
  | loginUiDisplayPrimaryPaperKeyRpc
  | loginUiGetEmailOrUsernameRpc
  | loginUiPromptRevokePaperKeysRpc
  | loginUnlockRpc
  | loginUnlockWithPassphraseRpc
  | metadataAuthenticateRpc
  | metadataDeleteKeyRpc
  | metadataGetChallengeRpc
  | metadataGetFolderHandleRpc
  | metadataGetFoldersForRekeyRpc
  | metadataGetKeyRpc
  | metadataGetLatestFolderHandleRpc
  | metadataGetMerkleNodeRpc
  | metadataGetMerkleRootLatestRpc
  | metadataGetMerkleRootRpc
  | metadataGetMerkleRootSinceRpc
  | metadataGetMetadataRpc
  | metadataPingRpc
  | metadataPruneBranchRpc
  | metadataPutKeysRpc
  | metadataPutMetadataRpc
  | metadataRegisterForUpdatesRpc
  | metadataTruncateLockRpc
  | metadataTruncateUnlockRpc
  | metadataUpdateFolderNeedsRekeyRpc
  | metadataUpdateMetadataUpdateRpc
  | notifyCtlSetNotificationsRpc
  | paperprovisionPaperProvisionRpc
  | pgpPgpDecryptRpc
  | pgpPgpDeletePrimaryRpc
  | pgpPgpEncryptRpc
  | pgpPgpExportByFingerprintRpc
  | pgpPgpExportByKIDRpc
  | pgpPgpExportRpc
  | pgpPgpImportRpc
  | pgpPgpKeyGenRpc
  | pgpPgpPullRpc
  | pgpPgpSelectRpc
  | pgpPgpSignRpc
  | pgpPgpUpdateRpc
  | pgpPgpVerifyRpc
  | pgpUiOutputSignatureSuccessRpc
  | proveCheckProofRpc
  | proveStartProofRpc
  | proveUiDisplayRecheckWarningRpc
  | proveUiOkToCheckRpc
  | proveUiOutputInstructionsRpc
  | proveUiOutputPrechecksRpc
  | proveUiPreProofWarningRpc
  | proveUiPromptOverwriteRpc
  | proveUiPromptUsernameRpc
  | provisionUiChooseDeviceRpc
  | provisionUiChooseDeviceTypeRpc
  | provisionUiChooseGPGMethodRpc
  | provisionUiChooseProvisioningMethodRpc
  | provisionUiDisplayAndPromptSecretRpc
  | provisionUiDisplaySecretExchangedRpc
  | provisionUiPromptNewDeviceNameRpc
  | provisionUiProvisioneeSuccessRpc
  | provisionUiProvisionerSuccessRpc
  | provisionUiSwitchToGPGSignOKRpc
  | quotaVerifySessionRpc
  | rekeyDebugShowRekeyStatusRpc
  | rekeyGetPendingRekeyStatusRpc
  | rekeyRekeyStatusFinishRpc
  | rekeyShowPendingRekeyStatusRpc
  | rekeyUIDelegateRekeyUIRpc
  | rekeyUIRefreshRpc
  | revokeRevokeDeviceRpc
  | revokeRevokeKeyRpc
  | revokeRevokeSigsRpc
  | saltpackSaltpackDecryptRpc
  | saltpackSaltpackEncryptRpc
  | saltpackSaltpackSignRpc
  | saltpackSaltpackVerifyRpc
  | saltpackUiSaltpackPromptForDecryptRpc
  | saltpackUiSaltpackVerifySuccessRpc
  | secretUiGetPassphraseRpc
  | sessionCurrentSessionRpc
  | signupCheckInvitationCodeRpc
  | signupCheckUsernameAvailableRpc
  | signupInviteRequestRpc
  | signupSignupRpc
  | sigsSigListJSONRpc
  | sigsSigListRpc
  | streamUiCloseRpc
  | streamUiReadRpc
  | streamUiWriteRpc
  | testPanicRpc
  | testTestCallbackRpc
  | testTestRpc
  | trackCheckTrackingRpc
  | trackDismissWithTokenRpc
  | trackFakeTrackingChangedRpc
  | trackTrackRpc
  | trackTrackWithTokenRpc
  | trackUntrackRpc
  | uiPromptYesNoRpc
  | userListTrackersByNameRpc
  | userListTrackersRpc
  | userListTrackersSelfRpc
  | userListTrackingJSONRpc
  | userListTrackingRpc
  | userLoadAllPublicKeysUnverifiedRpc
  | userLoadPublicKeysRpc
  | userLoadUncheckedUserSummariesRpc
  | userLoadUserByNameRpc
  | userLoadUserPlusKeysRpc
  | userLoadUserRpc
  | userSearchRpc

export type incomingCallMapType = {
  'keybase.1.account.passphraseChange'?: (
    params: {
      sessionID: int,
      oldPassphrase: string,
      passphrase: string,
      force: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.account.passphrasePrompt'?: (
    params: {
      sessionID: int,
      guiArg: GUIEntryArg
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: accountPassphrasePromptResult) => void
    }
  ) => void,
  'keybase.1.apiserver.Get'?: (
    params: {
      endpoint: string,
      args?: ?Array<StringKVPair>,
      httpStatus?: ?Array<int>,
      appStatusCode?: ?Array<int>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: apiserverGetResult) => void
    }
  ) => void,
  'keybase.1.apiserver.Post'?: (
    params: {
      endpoint: string,
      args?: ?Array<StringKVPair>,
      httpStatus?: ?Array<int>,
      appStatusCode?: ?Array<int>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: apiserverPostResult) => void
    }
  ) => void,
  'keybase.1.apiserver.PostJSON'?: (
    params: {
      endpoint: string,
      args?: ?Array<StringKVPair>,
      JSONPayload?: ?Array<StringKVPair>,
      httpStatus?: ?Array<int>,
      appStatusCode?: ?Array<int>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: apiserverPostJSONResult) => void
    }
  ) => void,
  'keybase.1.block.getSessionChallenge'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: blockGetSessionChallengeResult) => void
    }
  ) => void,
  'keybase.1.block.authenticateSession'?: (
    params: {
      signature: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.putBlock'?: (
    params: {
      bid: BlockIdCombo,
      folder: string,
      blockKey: string,
      buf: bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.getBlock'?: (
    params: {
      bid: BlockIdCombo,
      folder: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: blockGetBlockResult) => void
    }
  ) => void,
  'keybase.1.block.addReference'?: (
    params: {
      folder: string,
      ref: BlockReference
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.delReference'?: (
    params: {
      folder: string,
      ref: BlockReference
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.block.archiveReference'?: (
    params: {
      folder: string,
      refs?: ?Array<BlockReference>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: blockArchiveReferenceResult) => void
    }
  ) => void,
  'keybase.1.block.delReferenceWithCount'?: (
    params: {
      folder: string,
      refs?: ?Array<BlockReference>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: blockDelReferenceWithCountResult) => void
    }
  ) => void,
  'keybase.1.block.archiveReferenceWithCount'?: (
    params: {
      folder: string,
      refs?: ?Array<BlockReference>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: blockArchiveReferenceWithCountResult) => void
    }
  ) => void,
  'keybase.1.block.getUserQuotaInfo'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: blockGetUserQuotaInfoResult) => void
    }
  ) => void,
  'keybase.1.BTC.registerBTC'?: (
    params: {
      sessionID: int,
      address: string,
      force: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.getCurrentStatus'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: configGetCurrentStatusResult) => void
    }
  ) => void,
  'keybase.1.config.getExtendedStatus'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: configGetExtendedStatusResult) => void
    }
  ) => void,
  'keybase.1.config.getConfig'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: configGetConfigResult) => void
    }
  ) => void,
  'keybase.1.config.setUserConfig'?: (
    params: {
      sessionID: int,
      username: string,
      key: string,
      value: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.setPath'?: (
    params: {
      sessionID: int,
      path: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.helloIAm'?: (
    params: {
      details: ClientDetails
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.setValue'?: (
    params: {
      path: string,
      value: ConfigValue
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.clearValue'?: (
    params: {
      path: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.config.getValue'?: (
    params: {
      path: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: configGetValueResult) => void
    }
  ) => void,
  'keybase.1.config.checkAPIServerOutOfDateWarning'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: configCheckAPIServerOutOfDateWarningResult) => void
    }
  ) => void,
  'keybase.1.crypto.signED25519'?: (
    params: {
      sessionID: int,
      msg: bytes,
      reason: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: cryptoSignED25519Result) => void
    }
  ) => void,
  'keybase.1.crypto.signToString'?: (
    params: {
      sessionID: int,
      msg: bytes,
      reason: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: cryptoSignToStringResult) => void
    }
  ) => void,
  'keybase.1.crypto.unboxBytes32'?: (
    params: {
      sessionID: int,
      encryptedBytes32: EncryptedBytes32,
      nonce: BoxNonce,
      peersPublicKey: BoxPublicKey,
      reason: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: cryptoUnboxBytes32Result) => void
    }
  ) => void,
  'keybase.1.crypto.unboxBytes32Any'?: (
    params: {
      sessionID: int,
      bundles?: ?Array<CiphertextBundle>,
      reason: string,
      promptPaper: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: cryptoUnboxBytes32AnyResult) => void
    }
  ) => void,
  'keybase.1.ctl.stop'?: (
    params: {
      sessionID: int,
      exitCode: ExitCode
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ctl.logRotate'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ctl.reload'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ctl.dbNuke'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.debugging.firstStep'?: (
    params: {
      sessionID: int,
      val: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: debuggingFirstStepResult) => void
    }
  ) => void,
  'keybase.1.debugging.secondStep'?: (
    params: {
      sessionID: int,
      val: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: debuggingSecondStepResult) => void
    }
  ) => void,
  'keybase.1.debugging.increment'?: (
    params: {
      sessionID: int,
      val: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: debuggingIncrementResult) => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerIdentifyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerSecretUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerUpdateUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerRekeyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.delegateUiCtl.registerGregorFirehose'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.device.deviceList'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: deviceDeviceListResult) => void
    }
  ) => void,
  'keybase.1.device.deviceHistoryList'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: deviceDeviceHistoryListResult) => void
    }
  ) => void,
  'keybase.1.device.deviceAdd'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.device.checkDeviceNameFormat'?: (
    params: {
      sessionID: int,
      name: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: deviceCheckDeviceNameFormatResult) => void
    }
  ) => void,
  'keybase.1.favorite.favoriteAdd'?: (
    params: {
      sessionID: int,
      folder: Folder
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.favorite.favoriteIgnore'?: (
    params: {
      sessionID: int,
      folder: Folder
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.favorite.getFavorites'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: favoriteGetFavoritesResult) => void
    }
  ) => void,
  'keybase.1.fs.List'?: (
    params: {
      sessionID: int,
      path: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: fsListResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.wantToAddGPGKey'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: gpgUiWantToAddGPGKeyResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.confirmDuplicateKeyChosen'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: gpgUiConfirmDuplicateKeyChosenResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.selectKeyAndPushOption'?: (
    params: {
      sessionID: int,
      keys?: ?Array<GPGKey>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: gpgUiSelectKeyAndPushOptionResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.selectKey'?: (
    params: {
      sessionID: int,
      keys?: ?Array<GPGKey>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: gpgUiSelectKeyResult) => void
    }
  ) => void,
  'keybase.1.gpgUi.sign'?: (
    params: {
      msg: bytes,
      fingerprint: bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: gpgUiSignResult) => void
    }
  ) => void,
  'keybase.1.gregor.getState'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: gregorGetStateResult) => void
    }
  ) => void,
  'keybase.1.gregorUI.pushState'?: (
    params: {
      state: gregor1.State,
      reason: PushReason
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.gregorUI.pushOutOfBandMessages'?: (
    params: {
      oobm?: ?Array<gregor1.OutOfBandMessage>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identify.Resolve'?: (
    params: {
      assertion: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: identifyResolveResult) => void
    }
  ) => void,
  'keybase.1.identify.Resolve2'?: (
    params: {
      assertion: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: identifyResolve2Result) => void
    }
  ) => void,
  'keybase.1.identify.identify'?: (
    params: {
      sessionID: int,
      userAssertion: string,
      forceRemoteCheck?: boolean,
      useDelegateUI?: boolean,
      reason: IdentifyReason,
      source: ClientType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: identifyIdentifyResult) => void
    }
  ) => void,
  'keybase.1.identify.identify2'?: (
    params: {
      sessionID: int,
      uid: UID,
      userAssertion: string,
      reason: IdentifyReason,
      useDelegateUI?: boolean,
      alwaysBlock?: boolean,
      noErrorOnTrackFailure?: boolean,
      forceRemoteCheck?: boolean,
      needProofSet?: boolean,
      allowEmptySelfID?: boolean,
      noSkipSelf?: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: identifyIdentify2Result) => void
    }
  ) => void,
  'keybase.1.identifyUi.displayTLFCreateWithInvite'?: (
    params: {
      sessionID: int,
      folderName: string,
      isPrivate: boolean,
      assertion: string,
      socialAssertion: SocialAssertion,
      inviteLink: string,
      throttled: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.delegateIdentifyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: identifyUiDelegateIdentifyUIResult) => void
    }
  ) => void,
  'keybase.1.identifyUi.start'?: (
    params: {
      sessionID: int,
      username: string,
      reason: IdentifyReason
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayKey'?: (
    params: {
      sessionID: int,
      key: IdentifyKey
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.reportLastTrack'?: (
    params: {
      sessionID: int,
      track: (null | TrackSummary)
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.launchNetworkChecks'?: (
    params: {
      sessionID: int,
      identity: Identity,
      user: User
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayTrackStatement'?: (
    params: {
      sessionID: int,
      stmt: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.finishWebProofCheck'?: (
    params: {
      sessionID: int,
      rp: RemoteProof,
      lcr: LinkCheckResult
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.finishSocialProofCheck'?: (
    params: {
      sessionID: int,
      rp: RemoteProof,
      lcr: LinkCheckResult
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayCryptocurrency'?: (
    params: {
      sessionID: int,
      c: Cryptocurrency
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.reportTrackToken'?: (
    params: {
      sessionID: int,
      trackToken: TrackToken
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.displayUserCard'?: (
    params: {
      sessionID: int,
      card: UserCard
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.confirm'?: (
    params: {
      sessionID: int,
      outcome: IdentifyOutcome
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: identifyUiConfirmResult) => void
    }
  ) => void,
  'keybase.1.identifyUi.finish'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.identifyUi.dismiss'?: (
    params: {
      sessionID: int,
      username: string,
      reason: DismissReason
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.kbfs.FSEvent'?: (
    params: {
      event: FSNotification
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.Kex2Provisionee.hello'?: (
    params: {
      uid: UID,
      token: SessionToken,
      csrf: CsrfToken,
      pps: PassphraseStream,
      sigBody: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: Kex2ProvisioneeHelloResult) => void
    }
  ) => void,
  'keybase.1.Kex2Provisionee.didCounterSign'?: (
    params: {
      sig: bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.Kex2Provisioner.kexStart'?: (
    params: {} /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.log.registerLogger'?: (
    params: {
      sessionID: int,
      name: string,
      level: LogLevel
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.logUi.log'?: (
    params: {
      sessionID: int,
      level: LogLevel,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.getConfiguredAccounts'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: loginGetConfiguredAccountsResult) => void
    }
  ) => void,
  'keybase.1.login.login'?: (
    params: {
      sessionID: int,
      deviceType: string,
      usernameOrEmail: string,
      clientType: ClientType
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.clearStoredSecret'?: (
    params: {
      sessionID: int,
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.logout'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.deprovision'?: (
    params: {
      sessionID: int,
      username: string,
      doRevoke: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.recoverAccountFromEmailAddress'?: (
    params: {
      email: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.paperKey'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.paperKeySubmit'?: (
    params: {
      sessionID: int,
      paperPhrase: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.unlock'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.unlockWithPassphrase'?: (
    params: {
      sessionID: int,
      passphrase: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.login.pgpProvision'?: (
    params: {
      sessionID: int,
      username: string,
      passphrase: string,
      deviceName: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.loginUi.getEmailOrUsername'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: loginUiGetEmailOrUsernameResult) => void
    }
  ) => void,
  'keybase.1.loginUi.promptRevokePaperKeys'?: (
    params: {
      sessionID: int,
      device: Device,
      index: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: loginUiPromptRevokePaperKeysResult) => void
    }
  ) => void,
  'keybase.1.loginUi.displayPaperKeyPhrase'?: (
    params: {
      sessionID: int,
      phrase: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.loginUi.displayPrimaryPaperKey'?: (
    params: {
      sessionID: int,
      phrase: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getChallenge'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetChallengeResult) => void
    }
  ) => void,
  'keybase.1.metadata.authenticate'?: (
    params: {
      signature: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataAuthenticateResult) => void
    }
  ) => void,
  'keybase.1.metadata.putMetadata'?: (
    params: {
      mdBlock: MDBlock,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getMetadata'?: (
    params: {
      folderID: string,
      folderHandle: bytes,
      branchID: string,
      unmerged: boolean,
      startRevision: long,
      stopRevision: long,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetMetadataResult) => void
    }
  ) => void,
  'keybase.1.metadata.registerForUpdates'?: (
    params: {
      folderID: string,
      currRevision: long,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.pruneBranch'?: (
    params: {
      folderID: string,
      branchID: string,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.putKeys'?: (
    params: {
      keyHalves?: ?Array<KeyHalf>,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getKey'?: (
    params: {
      keyHalfID: bytes,
      deviceKID: string,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetKeyResult) => void
    }
  ) => void,
  'keybase.1.metadata.deleteKey'?: (
    params: {
      uid: UID,
      deviceKID: KID,
      keyHalfID: bytes,
      logTags: {[key: string]: string}
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.truncateLock'?: (
    params: {
      folderID: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataTruncateLockResult) => void
    }
  ) => void,
  'keybase.1.metadata.truncateUnlock'?: (
    params: {
      folderID: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataTruncateUnlockResult) => void
    }
  ) => void,
  'keybase.1.metadata.getFolderHandle'?: (
    params: {
      folderID: string,
      signature: string,
      challenge: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetFolderHandleResult) => void
    }
  ) => void,
  'keybase.1.metadata.getFoldersForRekey'?: (
    params: {
      deviceKID: KID
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.ping'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadata.getLatestFolderHandle'?: (
    params: {
      folderID: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetLatestFolderHandleResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleRoot'?: (
    params: {
      treeID: MerkleTreeID,
      seqNo: long
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetMerkleRootResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleRootLatest'?: (
    params: {
      treeID: MerkleTreeID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetMerkleRootLatestResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleRootSince'?: (
    params: {
      treeID: MerkleTreeID,
      when: Time
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetMerkleRootSinceResult) => void
    }
  ) => void,
  'keybase.1.metadata.getMerkleNode'?: (
    params: {
      hash: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: metadataGetMerkleNodeResult) => void
    }
  ) => void,
  'keybase.1.metadataUpdate.metadataUpdate'?: (
    params: {
      folderID: string,
      revision: long
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.metadataUpdate.folderNeedsRekey'?: (
    params: {
      folderID: string,
      revision: long
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.notifyCtl.setNotifications'?: (
    params: {
      channels: NotificationChannels
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifyFavorites.favoritesChanged'?: (
    params: {
      uid: UID
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyFS.FSActivity'?: (
    params: {
      notification: FSNotification
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyKeyfamily.keyfamilyChanged'?: (
    params: {
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifyPaperKey.paperKeyCached'?: (
    params: {
      uid: UID,
      encKID: KID,
      sigKID: KID
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifyService.shutdown'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifySession.loggedOut'?: (
    params: {} /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifySession.loggedIn'?: (
    params: {
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifySession.clientOutOfDate'?: (
    params: {
      upgradeTo: string,
      upgradeURI: string,
      upgradeMsg: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.NotifyTracking.trackingChanged'?: (
    params: {
      uid: UID,
      username: string
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.NotifyUsers.userChanged'?: (
    params: {
      uid: UID
    } /* ,
    response: {} // Notify call
    */
  ) => void,
  'keybase.1.paperprovision.paperProvision'?: (
    params: {
      sessionID: int,
      username: string,
      deviceName: string,
      paperKey: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpSign'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: PGPSignOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpPull'?: (
    params: {
      sessionID: int,
      userAsserts?: ?Array<string>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpEncrypt'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: PGPEncryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpDecrypt'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: PGPDecryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: pgpPgpDecryptResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpVerify'?: (
    params: {
      sessionID: int,
      source: Stream,
      opts: PGPVerifyOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: pgpPgpVerifyResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpImport'?: (
    params: {
      sessionID: int,
      key: bytes,
      pushSecret: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpExport'?: (
    params: {
      sessionID: int,
      options: PGPQuery
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: pgpPgpExportResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpExportByFingerprint'?: (
    params: {
      sessionID: int,
      options: PGPQuery
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: pgpPgpExportByFingerprintResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpExportByKID'?: (
    params: {
      sessionID: int,
      options: PGPQuery
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: pgpPgpExportByKIDResult) => void
    }
  ) => void,
  'keybase.1.pgp.pgpKeyGen'?: (
    params: {
      sessionID: int,
      primaryBits: int,
      subkeyBits: int,
      createUids: PGPCreateUids,
      allowMulti: boolean,
      doExport: boolean,
      pushSecret: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpDeletePrimary'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpSelect'?: (
    params: {
      sessionID: int,
      fingerprintQuery: string,
      allowMulti: boolean,
      skipImport: boolean,
      onlyImport: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgp.pgpUpdate'?: (
    params: {
      sessionID: int,
      all: boolean,
      fingerprints?: ?Array<string>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.pgpUi.outputSignatureSuccess'?: (
    params: {
      sessionID: int,
      fingerprint: string,
      username: string,
      signedAt: Time
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.prove.startProof'?: (
    params: {
      sessionID: int,
      service: string,
      username: string,
      force: boolean,
      promptPosted: boolean,
      auto: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: proveStartProofResult) => void
    }
  ) => void,
  'keybase.1.prove.checkProof'?: (
    params: {
      sessionID: int,
      sigID: SigID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: proveCheckProofResult) => void
    }
  ) => void,
  'keybase.1.proveUi.promptOverwrite'?: (
    params: {
      sessionID: int,
      account: string,
      typ: PromptOverwriteType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: proveUiPromptOverwriteResult) => void
    }
  ) => void,
  'keybase.1.proveUi.promptUsername'?: (
    params: {
      sessionID: int,
      prompt: string,
      prevError: (null | Status)
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: proveUiPromptUsernameResult) => void
    }
  ) => void,
  'keybase.1.proveUi.outputPrechecks'?: (
    params: {
      sessionID: int,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.proveUi.preProofWarning'?: (
    params: {
      sessionID: int,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: proveUiPreProofWarningResult) => void
    }
  ) => void,
  'keybase.1.proveUi.outputInstructions'?: (
    params: {
      sessionID: int,
      instructions: Text,
      proof: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.proveUi.okToCheck'?: (
    params: {
      sessionID: int,
      name: string,
      attempt: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: proveUiOkToCheckResult) => void
    }
  ) => void,
  'keybase.1.proveUi.displayRecheckWarning'?: (
    params: {
      sessionID: int,
      text: Text
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseProvisioningMethod'?: (
    params: {
      sessionID: int,
      gpgOption: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiChooseProvisioningMethodResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseGPGMethod'?: (
    params: {
      sessionID: int,
      keys?: ?Array<GPGKey>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiChooseGPGMethodResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.switchToGPGSignOK'?: (
    params: {
      sessionID: int,
      key: GPGKey,
      importError: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiSwitchToGPGSignOKResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseDevice'?: (
    params: {
      sessionID: int,
      devices?: ?Array<Device>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiChooseDeviceResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.chooseDeviceType'?: (
    params: {
      sessionID: int,
      kind: ChooseType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiChooseDeviceTypeResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.DisplayAndPromptSecret'?: (
    params: {
      sessionID: int,
      secret: bytes,
      phrase: string,
      otherDeviceType: DeviceType
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiDisplayAndPromptSecretResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.DisplaySecretExchanged'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.provisionUi.PromptNewDeviceName'?: (
    params: {
      sessionID: int,
      existingDevices?: ?Array<string>,
      errorMessage: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: provisionUiPromptNewDeviceNameResult) => void
    }
  ) => void,
  'keybase.1.provisionUi.ProvisioneeSuccess'?: (
    params: {
      sessionID: int,
      username: string,
      deviceName: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.provisionUi.ProvisionerSuccess'?: (
    params: {
      sessionID: int,
      deviceName: string,
      deviceType: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.quota.verifySession'?: (
    params: {
      session: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: quotaVerifySessionResult) => void
    }
  ) => void,
  'keybase.1.rekey.showPendingRekeyStatus'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.rekey.getPendingRekeyStatus'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: rekeyGetPendingRekeyStatusResult) => void
    }
  ) => void,
  'keybase.1.rekey.debugShowRekeyStatus'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.rekey.rekeyStatusFinish'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: rekeyRekeyStatusFinishResult) => void
    }
  ) => void,
  'keybase.1.rekeyUI.delegateRekeyUI'?: (
    params: {},
    response: {
      error: (err: RPCError) => void,
      result: (result: rekeyUIDelegateRekeyUIResult) => void
    }
  ) => void,
  'keybase.1.rekeyUI.refresh'?: (
    params: {
      sessionID: int,
      problemSetDevices: ProblemSetDevices
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.revoke.revokeKey'?: (
    params: {
      sessionID: int,
      keyID: KID
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.revoke.revokeDevice'?: (
    params: {
      sessionID: int,
      deviceID: DeviceID,
      force: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.revoke.revokeSigs'?: (
    params: {
      sessionID: int,
      sigIDQueries?: ?Array<string>
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackEncrypt'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: SaltpackEncryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackDecrypt'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: SaltpackDecryptOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: saltpackSaltpackDecryptResult) => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackSign'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: SaltpackSignOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpack.saltpackVerify'?: (
    params: {
      sessionID: int,
      source: Stream,
      sink: Stream,
      opts: SaltpackVerifyOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpackUi.saltpackPromptForDecrypt'?: (
    params: {
      sessionID: int,
      sender: SaltpackSender,
      usedDelegateUI: bool
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.saltpackUi.saltpackVerifySuccess'?: (
    params: {
      sessionID: int,
      signingKID: KID,
      sender: SaltpackSender
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.secretUi.getPassphrase'?: (
    params: {
      sessionID: int,
      pinentry: GUIEntryArg,
      terminal: (null | SecretEntryArg)
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: secretUiGetPassphraseResult) => void
    }
  ) => void,
  'keybase.1.SecretKeys.getSecretKeys'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: SecretKeysGetSecretKeysResult) => void
    }
  ) => void,
  'keybase.1.session.currentSession'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: sessionCurrentSessionResult) => void
    }
  ) => void,
  'keybase.1.signup.checkUsernameAvailable'?: (
    params: {
      sessionID: int,
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.signup.signup'?: (
    params: {
      sessionID: int,
      email: string,
      inviteCode: string,
      passphrase: string,
      username: string,
      deviceName: string,
      storeSecret: boolean,
      skipMail: boolean,
      genPGPBatch: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: signupSignupResult) => void
    }
  ) => void,
  'keybase.1.signup.inviteRequest'?: (
    params: {
      sessionID: int,
      email: string,
      fullname: string,
      notes: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.signup.checkInvitationCode'?: (
    params: {
      sessionID: int,
      invitationCode: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.sigs.sigList'?: (
    params: {
      sessionID: int,
      arg: SigListArgs
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: sigsSigListResult) => void
    }
  ) => void,
  'keybase.1.sigs.sigListJSON'?: (
    params: {
      sessionID: int,
      arg: SigListArgs
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: sigsSigListJSONResult) => void
    }
  ) => void,
  'keybase.1.streamUi.close'?: (
    params: {
      sessionID: int,
      s: Stream
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.streamUi.read'?: (
    params: {
      sessionID: int,
      s: Stream,
      sz: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: streamUiReadResult) => void
    }
  ) => void,
  'keybase.1.streamUi.write'?: (
    params: {
      sessionID: int,
      s: Stream,
      buf: bytes
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: streamUiWriteResult) => void
    }
  ) => void,
  'keybase.1.test.test'?: (
    params: {
      sessionID: int,
      name: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: testTestResult) => void
    }
  ) => void,
  'keybase.1.test.testCallback'?: (
    params: {
      sessionID: int,
      name: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: testTestCallbackResult) => void
    }
  ) => void,
  'keybase.1.test.panic'?: (
    params: {
      message: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.track'?: (
    params: {
      sessionID: int,
      userAssertion: string,
      options: TrackOptions,
      forceRemoteCheck: boolean
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.trackWithToken'?: (
    params: {
      sessionID: int,
      trackToken: TrackToken,
      options: TrackOptions
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.dismissWithToken'?: (
    params: {
      sessionID: int,
      trackToken: TrackToken
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.untrack'?: (
    params: {
      sessionID: int,
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.checkTracking'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.track.fakeTrackingChanged'?: (
    params: {
      sessionID: int,
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: () => void
    }
  ) => void,
  'keybase.1.ui.promptYesNo'?: (
    params: {
      sessionID: int,
      text: Text,
      promptDefault: PromptDefault
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: uiPromptYesNoResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackers'?: (
    params: {
      sessionID: int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userListTrackersResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackersByName'?: (
    params: {
      sessionID: int,
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userListTrackersByNameResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackersSelf'?: (
    params: {
      sessionID: int
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userListTrackersSelfResult) => void
    }
  ) => void,
  'keybase.1.user.loadUncheckedUserSummaries'?: (
    params: {
      sessionID: int,
      uids?: ?Array<UID>
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userLoadUncheckedUserSummariesResult) => void
    }
  ) => void,
  'keybase.1.user.loadUser'?: (
    params: {
      sessionID: int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userLoadUserResult) => void
    }
  ) => void,
  'keybase.1.user.loadUserByName'?: (
    params: {
      sessionID: int,
      username: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userLoadUserByNameResult) => void
    }
  ) => void,
  'keybase.1.user.loadUserPlusKeys'?: (
    params: {
      sessionID: int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userLoadUserPlusKeysResult) => void
    }
  ) => void,
  'keybase.1.user.loadPublicKeys'?: (
    params: {
      sessionID: int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userLoadPublicKeysResult) => void
    }
  ) => void,
  'keybase.1.user.listTracking'?: (
    params: {
      sessionID: int,
      filter: string,
      assertion: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userListTrackingResult) => void
    }
  ) => void,
  'keybase.1.user.listTrackingJSON'?: (
    params: {
      sessionID: int,
      filter: string,
      verbose: boolean,
      assertion: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userListTrackingJSONResult) => void
    }
  ) => void,
  'keybase.1.user.search'?: (
    params: {
      sessionID: int,
      query: string
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userSearchResult) => void
    }
  ) => void,
  'keybase.1.user.loadAllPublicKeysUnverified'?: (
    params: {
      sessionID: int,
      uid: UID
    },
    response: {
      error: (err: RPCError) => void,
      result: (result: userLoadAllPublicKeysUnverifiedResult) => void
    }
  ) => void
}


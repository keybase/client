// @flow
/* eslint-disable */

// This file is auto-generated by client/protocol/Makefile.
import * as Gregor1 from './rpc-gregor-gen'

import engine, {EngineChannel} from '../../engine'
import type {Boolean, Bool, Bytes, Double, Int, Int64, Long, String, Uint, Uint64, WaitingHandlerType, RPCErrorHandler, CommonResponseHandler, RPCError} from '../../engine/types'

export const BTCRegisterBTCRpcChannelMap = (configKeys: Array<string>, request: BTCRegisterBTCRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.BTC.registerBTC', request)

export const BTCRegisterBTCRpcPromise = (request: BTCRegisterBTCRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.BTC.registerBTC', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const KBFSGitCreateRepoRpcChannelMap = (configKeys: Array<string>, request: KBFSGitCreateRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.KBFSGit.createRepo', request)

export const KBFSGitCreateRepoRpcPromise = (request: KBFSGitCreateRepoRpcParam): Promise<KBFSGitCreateRepoResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.KBFSGit.createRepo', request, (error: RPCError, result: KBFSGitCreateRepoResult) => (error ? reject(error) : resolve(result))))

export const KBFSGitDeleteRepoRpcChannelMap = (configKeys: Array<string>, request: KBFSGitDeleteRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.KBFSGit.deleteRepo', request)

export const KBFSGitDeleteRepoRpcPromise = (request: KBFSGitDeleteRepoRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.KBFSGit.deleteRepo', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const KBFSGitGcRpcChannelMap = (configKeys: Array<string>, request: KBFSGitGcRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.KBFSGit.gc', request)

export const KBFSGitGcRpcPromise = (request: KBFSGitGcRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.KBFSGit.gc', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const Kex2Provisionee2DidCounterSign2RpcChannelMap = (configKeys: Array<string>, request: Kex2Provisionee2DidCounterSign2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.Kex2Provisionee2.didCounterSign2', request)

export const Kex2Provisionee2DidCounterSign2RpcPromise = (request: Kex2Provisionee2DidCounterSign2RpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.Kex2Provisionee2.didCounterSign2', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const Kex2Provisionee2Hello2RpcChannelMap = (configKeys: Array<string>, request: Kex2Provisionee2Hello2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.Kex2Provisionee2.hello2', request)

export const Kex2Provisionee2Hello2RpcPromise = (request: Kex2Provisionee2Hello2RpcParam): Promise<Kex2Provisionee2Hello2Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.Kex2Provisionee2.hello2', request, (error: RPCError, result: Kex2Provisionee2Hello2Result) => (error ? reject(error) : resolve(result))))

export const Kex2ProvisioneeDidCounterSignRpcChannelMap = (configKeys: Array<string>, request: Kex2ProvisioneeDidCounterSignRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.Kex2Provisionee.didCounterSign', request)

export const Kex2ProvisioneeDidCounterSignRpcPromise = (request: Kex2ProvisioneeDidCounterSignRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.Kex2Provisionee.didCounterSign', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const Kex2ProvisioneeHelloRpcChannelMap = (configKeys: Array<string>, request: Kex2ProvisioneeHelloRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.Kex2Provisionee.hello', request)

export const Kex2ProvisioneeHelloRpcPromise = (request: Kex2ProvisioneeHelloRpcParam): Promise<Kex2ProvisioneeHelloResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.Kex2Provisionee.hello', request, (error: RPCError, result: Kex2ProvisioneeHelloResult) => (error ? reject(error) : resolve(result))))

export const Kex2ProvisionerKexStartRpcChannelMap = (configKeys: Array<string>, request: Kex2ProvisionerKexStartRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.Kex2Provisioner.kexStart', request)

export const Kex2ProvisionerKexStartRpcPromise = (request: Kex2ProvisionerKexStartRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.Kex2Provisioner.kexStart', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const NotifyFSRequestFSEditListRequestRpcChannelMap = (configKeys: Array<string>, request: NotifyFSRequestFSEditListRequestRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.NotifyFSRequest.FSEditListRequest', request)

export const NotifyFSRequestFSEditListRequestRpcPromise = (request: NotifyFSRequestFSEditListRequestRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.NotifyFSRequest.FSEditListRequest', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const NotifyFSRequestFSSyncStatusRequestRpcChannelMap = (configKeys: Array<string>, request: NotifyFSRequestFSSyncStatusRequestRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.NotifyFSRequest.FSSyncStatusRequest', request)

export const NotifyFSRequestFSSyncStatusRequestRpcPromise = (request: NotifyFSRequestFSSyncStatusRequestRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.NotifyFSRequest.FSSyncStatusRequest', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ScanProofsScanProofsRpcChannelMap = (configKeys: Array<string>, request: ScanProofsScanProofsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ScanProofs.scanProofs', request)

export const ScanProofsScanProofsRpcPromise = (request: ScanProofsScanProofsRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ScanProofs.scanProofs', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SecretKeysGetSecretKeysRpcChannelMap = (configKeys: Array<string>, request: SecretKeysGetSecretKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SecretKeys.getSecretKeys', request)

export const SecretKeysGetSecretKeysRpcPromise = (request: SecretKeysGetSecretKeysRpcParam): Promise<SecretKeysGetSecretKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SecretKeys.getSecretKeys', request, (error: RPCError, result: SecretKeysGetSecretKeysResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSCancelRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSCancelRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSCancel', request)

export const SimpleFSSimpleFSCancelRpcPromise = (request: SimpleFSSimpleFSCancelRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSCancel', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSCheckRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSCheckRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSCheck', request)

export const SimpleFSSimpleFSCheckRpcPromise = (request: SimpleFSSimpleFSCheckRpcParam): Promise<SimpleFSSimpleFSCheckResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSCheck', request, (error: RPCError, result: SimpleFSSimpleFSCheckResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSCloseRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSCloseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSClose', request)

export const SimpleFSSimpleFSCloseRpcPromise = (request: SimpleFSSimpleFSCloseRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSClose', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSCopyRecursiveRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSCopyRecursiveRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSCopyRecursive', request)

export const SimpleFSSimpleFSCopyRecursiveRpcPromise = (request: SimpleFSSimpleFSCopyRecursiveRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSCopyRecursive', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSCopyRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSCopyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSCopy', request)

export const SimpleFSSimpleFSCopyRpcPromise = (request: SimpleFSSimpleFSCopyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSCopy', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSDumpDebuggingInfoRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSDumpDebuggingInfoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSDumpDebuggingInfo', request)

export const SimpleFSSimpleFSDumpDebuggingInfoRpcPromise = (request: SimpleFSSimpleFSDumpDebuggingInfoRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSDumpDebuggingInfo', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSGetOpsRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSGetOpsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSGetOps', request)

export const SimpleFSSimpleFSGetOpsRpcPromise = (request: SimpleFSSimpleFSGetOpsRpcParam): Promise<SimpleFSSimpleFSGetOpsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSGetOps', request, (error: RPCError, result: SimpleFSSimpleFSGetOpsResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSListRecursiveRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSListRecursiveRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSListRecursive', request)

export const SimpleFSSimpleFSListRecursiveRpcPromise = (request: SimpleFSSimpleFSListRecursiveRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSListRecursive', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSListRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSList', request)

export const SimpleFSSimpleFSListRpcPromise = (request: SimpleFSSimpleFSListRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSList', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSMakeOpidRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSMakeOpidRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSMakeOpid', request)

export const SimpleFSSimpleFSMakeOpidRpcPromise = (request: SimpleFSSimpleFSMakeOpidRpcParam): Promise<SimpleFSSimpleFSMakeOpidResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSMakeOpid', request, (error: RPCError, result: SimpleFSSimpleFSMakeOpidResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSMoveRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSMoveRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSMove', request)

export const SimpleFSSimpleFSMoveRpcPromise = (request: SimpleFSSimpleFSMoveRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSMove', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSOpenRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSOpenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSOpen', request)

export const SimpleFSSimpleFSOpenRpcPromise = (request: SimpleFSSimpleFSOpenRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSOpen', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSReadListRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSReadListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSReadList', request)

export const SimpleFSSimpleFSReadListRpcPromise = (request: SimpleFSSimpleFSReadListRpcParam): Promise<SimpleFSSimpleFSReadListResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSReadList', request, (error: RPCError, result: SimpleFSSimpleFSReadListResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSReadRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSReadRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSRead', request)

export const SimpleFSSimpleFSReadRpcPromise = (request: SimpleFSSimpleFSReadRpcParam): Promise<SimpleFSSimpleFSReadResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSRead', request, (error: RPCError, result: SimpleFSSimpleFSReadResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSRemoveRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSRemoveRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSRemove', request)

export const SimpleFSSimpleFSRemoveRpcPromise = (request: SimpleFSSimpleFSRemoveRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSRemove', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSRenameRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSRenameRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSRename', request)

export const SimpleFSSimpleFSRenameRpcPromise = (request: SimpleFSSimpleFSRenameRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSRename', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSSetStatRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSSetStatRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSSetStat', request)

export const SimpleFSSimpleFSSetStatRpcPromise = (request: SimpleFSSimpleFSSetStatRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSSetStat', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSStatRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSStatRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSStat', request)

export const SimpleFSSimpleFSStatRpcPromise = (request: SimpleFSSimpleFSStatRpcParam): Promise<SimpleFSSimpleFSStatResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSStat', request, (error: RPCError, result: SimpleFSSimpleFSStatResult) => (error ? reject(error) : resolve(result))))

export const SimpleFSSimpleFSWaitRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSWaitRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSWait', request)

export const SimpleFSSimpleFSWaitRpcPromise = (request: SimpleFSSimpleFSWaitRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSWait', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const SimpleFSSimpleFSWriteRpcChannelMap = (configKeys: Array<string>, request: SimpleFSSimpleFSWriteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.SimpleFS.simpleFSWrite', request)

export const SimpleFSSimpleFSWriteRpcPromise = (request: SimpleFSSimpleFSWriteRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.SimpleFS.simpleFSWrite', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const accountEmailChangeRpcChannelMap = (configKeys: Array<string>, request: AccountEmailChangeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.account.emailChange', request)

export const accountEmailChangeRpcPromise = (request: AccountEmailChangeRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.account.emailChange', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const accountHasServerKeysRpcChannelMap = (configKeys: Array<string>, request: AccountHasServerKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.account.hasServerKeys', request)

export const accountHasServerKeysRpcPromise = (request: AccountHasServerKeysRpcParam): Promise<AccountHasServerKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.account.hasServerKeys', request, (error: RPCError, result: AccountHasServerKeysResult) => (error ? reject(error) : resolve(result))))

export const accountPassphraseChangeRpcChannelMap = (configKeys: Array<string>, request: AccountPassphraseChangeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.account.passphraseChange', request)

export const accountPassphraseChangeRpcPromise = (request: AccountPassphraseChangeRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.account.passphraseChange', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const accountPassphrasePromptRpcChannelMap = (configKeys: Array<string>, request: AccountPassphrasePromptRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.account.passphrasePrompt', request)

export const accountPassphrasePromptRpcPromise = (request: AccountPassphrasePromptRpcParam): Promise<AccountPassphrasePromptResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.account.passphrasePrompt', request, (error: RPCError, result: AccountPassphrasePromptResult) => (error ? reject(error) : resolve(result))))

export const accountResetAccountRpcChannelMap = (configKeys: Array<string>, request: AccountResetAccountRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.account.resetAccount', request)

export const accountResetAccountRpcPromise = (request: AccountResetAccountRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.account.resetAccount', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const apiserverDeleteRpcChannelMap = (configKeys: Array<string>, request: ApiserverDeleteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.apiserver.Delete', request)

export const apiserverDeleteRpcPromise = (request: ApiserverDeleteRpcParam): Promise<ApiserverDeleteResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.apiserver.Delete', request, (error: RPCError, result: ApiserverDeleteResult) => (error ? reject(error) : resolve(result))))

export const apiserverGetRpcChannelMap = (configKeys: Array<string>, request: ApiserverGetRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.apiserver.Get', request)

export const apiserverGetRpcPromise = (request: ApiserverGetRpcParam): Promise<ApiserverGetResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.apiserver.Get', request, (error: RPCError, result: ApiserverGetResult) => (error ? reject(error) : resolve(result))))

export const apiserverGetWithSessionRpcChannelMap = (configKeys: Array<string>, request: ApiserverGetWithSessionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.apiserver.GetWithSession', request)

export const apiserverGetWithSessionRpcPromise = (request: ApiserverGetWithSessionRpcParam): Promise<ApiserverGetWithSessionResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.apiserver.GetWithSession', request, (error: RPCError, result: ApiserverGetWithSessionResult) => (error ? reject(error) : resolve(result))))

export const apiserverPostJSONRpcChannelMap = (configKeys: Array<string>, request: ApiserverPostJSONRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.apiserver.PostJSON', request)

export const apiserverPostJSONRpcPromise = (request: ApiserverPostJSONRpcParam): Promise<ApiserverPostJSONResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.apiserver.PostJSON', request, (error: RPCError, result: ApiserverPostJSONResult) => (error ? reject(error) : resolve(result))))

export const apiserverPostRpcChannelMap = (configKeys: Array<string>, request: ApiserverPostRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.apiserver.Post', request)

export const apiserverPostRpcPromise = (request: ApiserverPostRpcParam): Promise<ApiserverPostResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.apiserver.Post', request, (error: RPCError, result: ApiserverPostResult) => (error ? reject(error) : resolve(result))))

export const appStateAppState = {
  foreground: 0,
  background: 1,
  inactive: 2,
  backgroundactive: 3,
}

export const appStateUpdateAppStateRpcChannelMap = (configKeys: Array<string>, request: AppStateUpdateAppStateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.appState.updateAppState', request)

export const appStateUpdateAppStateRpcPromise = (request: AppStateUpdateAppStateRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.appState.updateAppState', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const avatarsLoadTeamAvatarsRpcChannelMap = (configKeys: Array<string>, request: AvatarsLoadTeamAvatarsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.avatars.loadTeamAvatars', request)

export const avatarsLoadTeamAvatarsRpcPromise = (request: AvatarsLoadTeamAvatarsRpcParam): Promise<AvatarsLoadTeamAvatarsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.avatars.loadTeamAvatars', request, (error: RPCError, result: AvatarsLoadTeamAvatarsResult) => (error ? reject(error) : resolve(result))))

export const avatarsLoadUserAvatarsRpcChannelMap = (configKeys: Array<string>, request: AvatarsLoadUserAvatarsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.avatars.loadUserAvatars', request)

export const avatarsLoadUserAvatarsRpcPromise = (request: AvatarsLoadUserAvatarsRpcParam): Promise<AvatarsLoadUserAvatarsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.avatars.loadUserAvatars', request, (error: RPCError, result: AvatarsLoadUserAvatarsResult) => (error ? reject(error) : resolve(result))))

export const backendCommonBlockType = {
  data: 0,
  md: 1,
  git: 2,
}

export const badgerGetBadgeStateRpcChannelMap = (configKeys: Array<string>, request: BadgerGetBadgeStateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.badger.getBadgeState', request)

export const badgerGetBadgeStateRpcPromise = (request: BadgerGetBadgeStateRpcParam): Promise<BadgerGetBadgeStateResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.badger.getBadgeState', request, (error: RPCError, result: BadgerGetBadgeStateResult) => (error ? reject(error) : resolve(result))))

export const blockAddReferenceRpcChannelMap = (configKeys: Array<string>, request: BlockAddReferenceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.addReference', request)

export const blockAddReferenceRpcPromise = (request: BlockAddReferenceRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.addReference', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const blockArchiveReferenceRpcChannelMap = (configKeys: Array<string>, request: BlockArchiveReferenceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.archiveReference', request)

export const blockArchiveReferenceRpcPromise = (request: BlockArchiveReferenceRpcParam): Promise<BlockArchiveReferenceResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.archiveReference', request, (error: RPCError, result: BlockArchiveReferenceResult) => (error ? reject(error) : resolve(result))))

export const blockArchiveReferenceWithCountRpcChannelMap = (configKeys: Array<string>, request: BlockArchiveReferenceWithCountRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.archiveReferenceWithCount', request)

export const blockArchiveReferenceWithCountRpcPromise = (request: BlockArchiveReferenceWithCountRpcParam): Promise<BlockArchiveReferenceWithCountResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.archiveReferenceWithCount', request, (error: RPCError, result: BlockArchiveReferenceWithCountResult) => (error ? reject(error) : resolve(result))))

export const blockAuthenticateSessionRpcChannelMap = (configKeys: Array<string>, request: BlockAuthenticateSessionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.authenticateSession', request)

export const blockAuthenticateSessionRpcPromise = (request: BlockAuthenticateSessionRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.authenticateSession', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const blockBlockPingRpcChannelMap = (configKeys: Array<string>, request: BlockBlockPingRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.blockPing', request)

export const blockBlockPingRpcPromise = (request: BlockBlockPingRpcParam): Promise<BlockBlockPingResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.blockPing', request, (error: RPCError, result: BlockBlockPingResult) => (error ? reject(error) : resolve(result))))

export const blockDelReferenceRpcChannelMap = (configKeys: Array<string>, request: BlockDelReferenceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.delReference', request)

export const blockDelReferenceRpcPromise = (request: BlockDelReferenceRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.delReference', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const blockDelReferenceWithCountRpcChannelMap = (configKeys: Array<string>, request: BlockDelReferenceWithCountRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.delReferenceWithCount', request)

export const blockDelReferenceWithCountRpcPromise = (request: BlockDelReferenceWithCountRpcParam): Promise<BlockDelReferenceWithCountResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.delReferenceWithCount', request, (error: RPCError, result: BlockDelReferenceWithCountResult) => (error ? reject(error) : resolve(result))))

export const blockGetBlockRpcChannelMap = (configKeys: Array<string>, request: BlockGetBlockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.getBlock', request)

export const blockGetBlockRpcPromise = (request: BlockGetBlockRpcParam): Promise<BlockGetBlockResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.getBlock', request, (error: RPCError, result: BlockGetBlockResult) => (error ? reject(error) : resolve(result))))

export const blockGetSessionChallengeRpcChannelMap = (configKeys: Array<string>, request: BlockGetSessionChallengeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.getSessionChallenge', request)

export const blockGetSessionChallengeRpcPromise = (request: BlockGetSessionChallengeRpcParam): Promise<BlockGetSessionChallengeResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.getSessionChallenge', request, (error: RPCError, result: BlockGetSessionChallengeResult) => (error ? reject(error) : resolve(result))))

export const blockGetTeamQuotaInfoRpcChannelMap = (configKeys: Array<string>, request: BlockGetTeamQuotaInfoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.getTeamQuotaInfo', request)

export const blockGetTeamQuotaInfoRpcPromise = (request: BlockGetTeamQuotaInfoRpcParam): Promise<BlockGetTeamQuotaInfoResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.getTeamQuotaInfo', request, (error: RPCError, result: BlockGetTeamQuotaInfoResult) => (error ? reject(error) : resolve(result))))

export const blockGetUserQuotaInfoRpcChannelMap = (configKeys: Array<string>, request: BlockGetUserQuotaInfoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.getUserQuotaInfo', request)

export const blockGetUserQuotaInfoRpcPromise = (request: BlockGetUserQuotaInfoRpcParam): Promise<BlockGetUserQuotaInfoResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.getUserQuotaInfo', request, (error: RPCError, result: BlockGetUserQuotaInfoResult) => (error ? reject(error) : resolve(result))))

export const blockPutBlockAgainRpcChannelMap = (configKeys: Array<string>, request: BlockPutBlockAgainRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.putBlockAgain', request)

export const blockPutBlockAgainRpcPromise = (request: BlockPutBlockAgainRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.putBlockAgain', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const blockPutBlockRpcChannelMap = (configKeys: Array<string>, request: BlockPutBlockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.block.putBlock', request)

export const blockPutBlockRpcPromise = (request: BlockPutBlockRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.block.putBlock', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const commonClientType = {
  none: 0,
  cli: 1,
  guiMain: 2,
  kbfs: 3,
  guiHelper: 4,
}

export const commonDeviceType = {
  desktop: 0,
  mobile: 1,
}

export const commonFullNamePackageVersion = {
  v0: 0,
  v1: 1,
}

export const commonLogLevel = {
  none: 0,
  debug: 1,
  info: 2,
  notice: 3,
  warn: 4,
  error: 5,
  critical: 6,
  fatal: 7,
}

export const commonMerkleTreeID = {
  master: 0,
  kbfsPublic: 1,
  kbfsPrivate: 2,
  kbfsPrivateteam: 3,
}

export const commonSeqType = {
  public: 1,
  private: 2,
  semiprivate: 3,
}

export const commonTLFVisibility = {
  any: 0,
  public: 1,
  private: 2,
}

export const commonTeamType = {
  none: 0,
  legacy: 1,
  modern: 2,
}

export const commonUserOrTeamResult = {
  user: 1,
  team: 2,
}

export const configCheckAPIServerOutOfDateWarningRpcChannelMap = (configKeys: Array<string>, request: ConfigCheckAPIServerOutOfDateWarningRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.checkAPIServerOutOfDateWarning', request)

export const configCheckAPIServerOutOfDateWarningRpcPromise = (request: ConfigCheckAPIServerOutOfDateWarningRpcParam): Promise<ConfigCheckAPIServerOutOfDateWarningResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.checkAPIServerOutOfDateWarning', request, (error: RPCError, result: ConfigCheckAPIServerOutOfDateWarningResult) => (error ? reject(error) : resolve(result))))

export const configClearValueRpcChannelMap = (configKeys: Array<string>, request: ConfigClearValueRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.clearValue', request)

export const configClearValueRpcPromise = (request: ConfigClearValueRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.clearValue', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const configForkType = {
  none: 0,
  auto: 1,
  watchdog: 2,
  launchd: 3,
  systemd: 4,
}

export const configGetBootstrapStatusRpcChannelMap = (configKeys: Array<string>, request: ConfigGetBootstrapStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.getBootstrapStatus', request)

export const configGetBootstrapStatusRpcPromise = (request: ConfigGetBootstrapStatusRpcParam): Promise<ConfigGetBootstrapStatusResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.getBootstrapStatus', request, (error: RPCError, result: ConfigGetBootstrapStatusResult) => (error ? reject(error) : resolve(result))))

export const configGetConfigRpcChannelMap = (configKeys: Array<string>, request: ConfigGetConfigRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.getConfig', request)

export const configGetConfigRpcPromise = (request: ConfigGetConfigRpcParam): Promise<ConfigGetConfigResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.getConfig', request, (error: RPCError, result: ConfigGetConfigResult) => (error ? reject(error) : resolve(result))))

export const configGetCurrentStatusRpcChannelMap = (configKeys: Array<string>, request: ConfigGetCurrentStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.getCurrentStatus', request)

export const configGetCurrentStatusRpcPromise = (request: ConfigGetCurrentStatusRpcParam): Promise<ConfigGetCurrentStatusResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.getCurrentStatus', request, (error: RPCError, result: ConfigGetCurrentStatusResult) => (error ? reject(error) : resolve(result))))

export const configGetExtendedStatusRpcChannelMap = (configKeys: Array<string>, request: ConfigGetExtendedStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.getExtendedStatus', request)

export const configGetExtendedStatusRpcPromise = (request: ConfigGetExtendedStatusRpcParam): Promise<ConfigGetExtendedStatusResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.getExtendedStatus', request, (error: RPCError, result: ConfigGetExtendedStatusResult) => (error ? reject(error) : resolve(result))))

export const configGetRememberPassphraseRpcChannelMap = (configKeys: Array<string>, request: ConfigGetRememberPassphraseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.getRememberPassphrase', request)

export const configGetRememberPassphraseRpcPromise = (request: ConfigGetRememberPassphraseRpcParam): Promise<ConfigGetRememberPassphraseResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.getRememberPassphrase', request, (error: RPCError, result: ConfigGetRememberPassphraseResult) => (error ? reject(error) : resolve(result))))

export const configGetValueRpcChannelMap = (configKeys: Array<string>, request: ConfigGetValueRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.getValue', request)

export const configGetValueRpcPromise = (request: ConfigGetValueRpcParam): Promise<ConfigGetValueResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.getValue', request, (error: RPCError, result: ConfigGetValueResult) => (error ? reject(error) : resolve(result))))

export const configHelloIAmRpcChannelMap = (configKeys: Array<string>, request: ConfigHelloIAmRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.helloIAm', request)

export const configHelloIAmRpcPromise = (request: ConfigHelloIAmRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.helloIAm', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const configSetPathRpcChannelMap = (configKeys: Array<string>, request: ConfigSetPathRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.setPath', request)

export const configSetPathRpcPromise = (request: ConfigSetPathRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.setPath', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const configSetRememberPassphraseRpcChannelMap = (configKeys: Array<string>, request: ConfigSetRememberPassphraseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.setRememberPassphrase', request)

export const configSetRememberPassphraseRpcPromise = (request: ConfigSetRememberPassphraseRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.setRememberPassphrase', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const configSetUserConfigRpcChannelMap = (configKeys: Array<string>, request: ConfigSetUserConfigRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.setUserConfig', request)

export const configSetUserConfigRpcPromise = (request: ConfigSetUserConfigRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.setUserConfig', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const configSetValueRpcChannelMap = (configKeys: Array<string>, request: ConfigSetValueRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.setValue', request)

export const configSetValueRpcPromise = (request: ConfigSetValueRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.setValue', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const configWaitForClientRpcChannelMap = (configKeys: Array<string>, request: ConfigWaitForClientRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.config.waitForClient', request)

export const configWaitForClientRpcPromise = (request: ConfigWaitForClientRpcParam): Promise<ConfigWaitForClientResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.config.waitForClient', request, (error: RPCError, result: ConfigWaitForClientResult) => (error ? reject(error) : resolve(result))))

export const constantsStatusCode = {
  scok: 0,
  scinputerror: 100,
  scloginrequired: 201,
  scbadsession: 202,
  scbadloginusernotfound: 203,
  scbadloginpassword: 204,
  scnotfound: 205,
  scthrottlecontrol: 210,
  scdeleted: 216,
  scgeneric: 218,
  scalreadyloggedin: 235,
  scexists: 230,
  sccanceled: 237,
  scinputcanceled: 239,
  screloginrequired: 274,
  scresolutionfailed: 275,
  scprofilenotpublic: 276,
  scidentifyfailed: 277,
  sctrackingbroke: 278,
  scwrongcryptoformat: 279,
  scdecryptionerror: 280,
  scinvalidaddress: 281,
  scnosession: 283,
  scaccountreset: 290,
  scidentifiesfailed: 295,
  scnospaceondevice: 297,
  scbademail: 472,
  scbadsignupusernametaken: 701,
  scbadinvitationcode: 707,
  scmissingresult: 801,
  sckeynotfound: 901,
  sckeycorrupted: 905,
  sckeyinuse: 907,
  sckeybadgen: 913,
  sckeynosecret: 914,
  sckeybaduids: 915,
  sckeynoactive: 916,
  sckeynosig: 917,
  sckeybadsig: 918,
  sckeybadeldest: 919,
  sckeynoeldest: 920,
  sckeyduplicateupdate: 921,
  scsibkeyalreadyexists: 922,
  scdecryptionkeynotfound: 924,
  sckeynopgpencryption: 927,
  sckeynonaclencryption: 928,
  sckeysyncedpgpnotfound: 929,
  sckeynomatchinggpg: 930,
  sckeyrevoked: 931,
  scsigoldseqno: 1010,
  scbadtracksession: 1301,
  scdevicebadname: 1404,
  scdevicenameinuse: 1408,
  scdevicenotfound: 1409,
  scdevicemismatch: 1410,
  scdevicerequired: 1411,
  scdeviceprevprovisioned: 1413,
  scdevicenoprovision: 1414,
  scdeviceprovisionviadevice: 1415,
  screvokecurrentdevice: 1416,
  screvokelastdevice: 1417,
  scdeviceprovisionoffline: 1418,
  screvokelastdevicepgp: 1419,
  scstreamexists: 1501,
  scstreamnotfound: 1502,
  scstreamwrongkind: 1503,
  scstreameof: 1504,
  scgenericapierror: 1600,
  scapinetworkerror: 1601,
  sctimeout: 1602,
  scprooferror: 1701,
  scidentificationexpired: 1702,
  scselfnotfound: 1703,
  scbadkexphrase: 1704,
  scnouidelegation: 1705,
  scnoui: 1706,
  scgpgunavailable: 1707,
  scinvalidversionerror: 1800,
  scoldversionerror: 1801,
  scinvalidlocationerror: 1802,
  scservicestatuserror: 1803,
  scinstallerror: 1804,
  scloadkexterror: 1810,
  scloadkextpermerror: 1811,
  scgitinternal: 2300,
  scgitrepoalreadyexists: 2301,
  scgitinvalidreponame: 2302,
  scgitcannotdelete: 2303,
  scgitrepodoesntexist: 2304,
  scloginstatetimeout: 2400,
  scchatinternal: 2500,
  scchatratelimit: 2501,
  scchatconvexists: 2502,
  scchatunknowntlfid: 2503,
  scchatnotinconv: 2504,
  scchatbadmsg: 2505,
  scchatbroadcast: 2506,
  scchatalreadysuperseded: 2507,
  scchatalreadydeleted: 2508,
  scchattlffinalized: 2509,
  scchatcollision: 2510,
  scidentifysummaryerror: 2511,
  scneedselfrekey: 2512,
  scneedotherrekey: 2513,
  scchatmessagecollision: 2514,
  scchatduplicatemessage: 2515,
  scchatclienterror: 2516,
  scchatnotinteam: 2517,
  scchatstalepreviousstate: 2518,
  scteambadmembership: 2604,
  scteamselfnotowner: 2607,
  scteamnotfound: 2614,
  scteamexists: 2619,
  scteamreaderror: 2623,
  scnoop: 2638,
  scteaminvitebadtoken: 2646,
  scteamtarduplicate: 2663,
  scteamtarnotfound: 2664,
  scteammemberexists: 2665,
  scteamnotreleased: 2666,
  scteampermanentlyleft: 2667,
  scteamneedrootid: 2668,
  scteamhaslivechildren: 2669,
  scteamdeleteerror: 2670,
  scteambadrootteam: 2671,
  scteamnameconflictswithuser: 2672,
  scteamdeletenouppointer: 2673,
  scteamneedowner: 2674,
  scteamnoownerallowed: 2675,
  scteamimplicitnononsbs: 2676,
  scteamimplicitbadhash: 2677,
  scteamimplicitbadname: 2678,
  scteamimplicitclash: 2679,
  scteamimplicitduplicate: 2680,
  scteamimplicitbadop: 2681,
  scteamimplicitbadrole: 2682,
  scteamimplicitnotfound: 2683,
  scteambadadminseqnotype: 2684,
  scteamimplicitbadadd: 2685,
  scteamimplicitbadremove: 2686,
  scteaminvitetokenreused: 2696,
  scteamkeymasknotfound: 2697,
  scteambanned: 2702,
  scteaminvalidban: 2703,
  scteamshowcasepermdenied: 2711,
  scteamprovisionalcankey: 2721,
  scteamprovisionalcannotkey: 2722,
  scstellarerror: 3100,
  scstellarbadinput: 3101,
  scstellarwrongrevision: 3102,
  scstellarmissingbundle: 3103,
  scstellarbadpuk: 3104,
  scstellarmissingaccount: 3105,
  scstellarbadprev: 3106,
}

export const cryptoSignED25519ForKBFSRpcChannelMap = (configKeys: Array<string>, request: CryptoSignED25519ForKBFSRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.crypto.signED25519ForKBFS', request)

export const cryptoSignED25519ForKBFSRpcPromise = (request: CryptoSignED25519ForKBFSRpcParam): Promise<CryptoSignED25519ForKBFSResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.crypto.signED25519ForKBFS', request, (error: RPCError, result: CryptoSignED25519ForKBFSResult) => (error ? reject(error) : resolve(result))))

export const cryptoSignED25519RpcChannelMap = (configKeys: Array<string>, request: CryptoSignED25519RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.crypto.signED25519', request)

export const cryptoSignED25519RpcPromise = (request: CryptoSignED25519RpcParam): Promise<CryptoSignED25519Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.crypto.signED25519', request, (error: RPCError, result: CryptoSignED25519Result) => (error ? reject(error) : resolve(result))))

export const cryptoSignToStringRpcChannelMap = (configKeys: Array<string>, request: CryptoSignToStringRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.crypto.signToString', request)

export const cryptoSignToStringRpcPromise = (request: CryptoSignToStringRpcParam): Promise<CryptoSignToStringResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.crypto.signToString', request, (error: RPCError, result: CryptoSignToStringResult) => (error ? reject(error) : resolve(result))))

export const cryptoUnboxBytes32AnyRpcChannelMap = (configKeys: Array<string>, request: CryptoUnboxBytes32AnyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.crypto.unboxBytes32Any', request)

export const cryptoUnboxBytes32AnyRpcPromise = (request: CryptoUnboxBytes32AnyRpcParam): Promise<CryptoUnboxBytes32AnyResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.crypto.unboxBytes32Any', request, (error: RPCError, result: CryptoUnboxBytes32AnyResult) => (error ? reject(error) : resolve(result))))

export const cryptoUnboxBytes32RpcChannelMap = (configKeys: Array<string>, request: CryptoUnboxBytes32RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.crypto.unboxBytes32', request)

export const cryptoUnboxBytes32RpcPromise = (request: CryptoUnboxBytes32RpcParam): Promise<CryptoUnboxBytes32Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.crypto.unboxBytes32', request, (error: RPCError, result: CryptoUnboxBytes32Result) => (error ? reject(error) : resolve(result))))

export const cryptocurrencyRegisterAddressRpcChannelMap = (configKeys: Array<string>, request: CryptocurrencyRegisterAddressRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.cryptocurrency.registerAddress', request)

export const cryptocurrencyRegisterAddressRpcPromise = (request: CryptocurrencyRegisterAddressRpcParam): Promise<CryptocurrencyRegisterAddressResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.cryptocurrency.registerAddress', request, (error: RPCError, result: CryptocurrencyRegisterAddressResult) => (error ? reject(error) : resolve(result))))

export const ctlAppExitRpcChannelMap = (configKeys: Array<string>, request: CtlAppExitRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.appExit', request)

export const ctlAppExitRpcPromise = (request: CtlAppExitRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.appExit', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ctlDbDeleteRpcChannelMap = (configKeys: Array<string>, request: CtlDbDeleteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.dbDelete', request)

export const ctlDbDeleteRpcPromise = (request: CtlDbDeleteRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.dbDelete', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ctlDbGetRpcChannelMap = (configKeys: Array<string>, request: CtlDbGetRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.dbGet', request)

export const ctlDbGetRpcPromise = (request: CtlDbGetRpcParam): Promise<CtlDbGetResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.dbGet', request, (error: RPCError, result: CtlDbGetResult) => (error ? reject(error) : resolve(result))))

export const ctlDbNukeRpcChannelMap = (configKeys: Array<string>, request: CtlDbNukeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.dbNuke', request)

export const ctlDbNukeRpcPromise = (request: CtlDbNukeRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.dbNuke', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ctlDbPutRpcChannelMap = (configKeys: Array<string>, request: CtlDbPutRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.dbPut', request)

export const ctlDbPutRpcPromise = (request: CtlDbPutRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.dbPut', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ctlDbType = {
  main: 0,
  chat: 1,
}

export const ctlExitCode = {
  ok: 0,
  notok: 2,
  restart: 4,
}

export const ctlLogRotateRpcChannelMap = (configKeys: Array<string>, request: CtlLogRotateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.logRotate', request)

export const ctlLogRotateRpcPromise = (request: CtlLogRotateRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.logRotate', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ctlReloadRpcChannelMap = (configKeys: Array<string>, request: CtlReloadRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.reload', request)

export const ctlReloadRpcPromise = (request: CtlReloadRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.reload', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const ctlStopRpcChannelMap = (configKeys: Array<string>, request: CtlStopRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.ctl.stop', request)

export const ctlStopRpcPromise = (request: CtlStopRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.ctl.stop', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const debuggingFirstStepRpcChannelMap = (configKeys: Array<string>, request: DebuggingFirstStepRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.debugging.firstStep', request)

export const debuggingFirstStepRpcPromise = (request: DebuggingFirstStepRpcParam): Promise<DebuggingFirstStepResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.debugging.firstStep', request, (error: RPCError, result: DebuggingFirstStepResult) => (error ? reject(error) : resolve(result))))

export const debuggingIncrementRpcChannelMap = (configKeys: Array<string>, request: DebuggingIncrementRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.debugging.increment', request)

export const debuggingIncrementRpcPromise = (request: DebuggingIncrementRpcParam): Promise<DebuggingIncrementResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.debugging.increment', request, (error: RPCError, result: DebuggingIncrementResult) => (error ? reject(error) : resolve(result))))

export const debuggingSecondStepRpcChannelMap = (configKeys: Array<string>, request: DebuggingSecondStepRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.debugging.secondStep', request)

export const debuggingSecondStepRpcPromise = (request: DebuggingSecondStepRpcParam): Promise<DebuggingSecondStepResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.debugging.secondStep', request, (error: RPCError, result: DebuggingSecondStepResult) => (error ? reject(error) : resolve(result))))

export const delegateUiCtlRegisterGregorFirehoseRpcChannelMap = (configKeys: Array<string>, request: DelegateUiCtlRegisterGregorFirehoseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.delegateUiCtl.registerGregorFirehose', request)

export const delegateUiCtlRegisterGregorFirehoseRpcPromise = (request: DelegateUiCtlRegisterGregorFirehoseRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.delegateUiCtl.registerGregorFirehose', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const delegateUiCtlRegisterHomeUIRpcChannelMap = (configKeys: Array<string>, request: DelegateUiCtlRegisterHomeUIRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.delegateUiCtl.registerHomeUI', request)

export const delegateUiCtlRegisterHomeUIRpcPromise = (request: DelegateUiCtlRegisterHomeUIRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.delegateUiCtl.registerHomeUI', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const delegateUiCtlRegisterIdentifyUIRpcChannelMap = (configKeys: Array<string>, request: DelegateUiCtlRegisterIdentifyUIRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.delegateUiCtl.registerIdentifyUI', request)

export const delegateUiCtlRegisterIdentifyUIRpcPromise = (request: DelegateUiCtlRegisterIdentifyUIRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.delegateUiCtl.registerIdentifyUI', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const delegateUiCtlRegisterRekeyUIRpcChannelMap = (configKeys: Array<string>, request: DelegateUiCtlRegisterRekeyUIRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.delegateUiCtl.registerRekeyUI', request)

export const delegateUiCtlRegisterRekeyUIRpcPromise = (request: DelegateUiCtlRegisterRekeyUIRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.delegateUiCtl.registerRekeyUI', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const delegateUiCtlRegisterSecretUIRpcChannelMap = (configKeys: Array<string>, request: DelegateUiCtlRegisterSecretUIRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.delegateUiCtl.registerSecretUI', request)

export const delegateUiCtlRegisterSecretUIRpcPromise = (request: DelegateUiCtlRegisterSecretUIRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.delegateUiCtl.registerSecretUI', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const delegateUiCtlRegisterUpdateUIRpcChannelMap = (configKeys: Array<string>, request: DelegateUiCtlRegisterUpdateUIRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.delegateUiCtl.registerUpdateUI', request)

export const delegateUiCtlRegisterUpdateUIRpcPromise = (request: DelegateUiCtlRegisterUpdateUIRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.delegateUiCtl.registerUpdateUI', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const deviceCheckDeviceNameForUserRpcChannelMap = (configKeys: Array<string>, request: DeviceCheckDeviceNameForUserRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.device.checkDeviceNameForUser', request)

export const deviceCheckDeviceNameForUserRpcPromise = (request: DeviceCheckDeviceNameForUserRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.device.checkDeviceNameForUser', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const deviceCheckDeviceNameFormatRpcChannelMap = (configKeys: Array<string>, request: DeviceCheckDeviceNameFormatRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.device.checkDeviceNameFormat', request)

export const deviceCheckDeviceNameFormatRpcPromise = (request: DeviceCheckDeviceNameFormatRpcParam): Promise<DeviceCheckDeviceNameFormatResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.device.checkDeviceNameFormat', request, (error: RPCError, result: DeviceCheckDeviceNameFormatResult) => (error ? reject(error) : resolve(result))))

export const deviceDeviceAddRpcChannelMap = (configKeys: Array<string>, request: DeviceDeviceAddRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.device.deviceAdd', request)

export const deviceDeviceAddRpcPromise = (request: DeviceDeviceAddRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.device.deviceAdd', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const deviceDeviceHistoryListRpcChannelMap = (configKeys: Array<string>, request: DeviceDeviceHistoryListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.device.deviceHistoryList', request)

export const deviceDeviceHistoryListRpcPromise = (request: DeviceDeviceHistoryListRpcParam): Promise<DeviceDeviceHistoryListResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.device.deviceHistoryList', request, (error: RPCError, result: DeviceDeviceHistoryListResult) => (error ? reject(error) : resolve(result))))

export const deviceDeviceListRpcChannelMap = (configKeys: Array<string>, request: DeviceDeviceListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.device.deviceList', request)

export const deviceDeviceListRpcPromise = (request: DeviceDeviceListRpcParam): Promise<DeviceDeviceListResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.device.deviceList', request, (error: RPCError, result: DeviceDeviceListResult) => (error ? reject(error) : resolve(result))))

export const favoriteFavoriteAddRpcChannelMap = (configKeys: Array<string>, request: FavoriteFavoriteAddRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.favorite.favoriteAdd', request)

export const favoriteFavoriteAddRpcPromise = (request: FavoriteFavoriteAddRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.favorite.favoriteAdd', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const favoriteFavoriteIgnoreRpcChannelMap = (configKeys: Array<string>, request: FavoriteFavoriteIgnoreRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.favorite.favoriteIgnore', request)

export const favoriteFavoriteIgnoreRpcPromise = (request: FavoriteFavoriteIgnoreRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.favorite.favoriteIgnore', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const favoriteFolderType = {
  unknown: 0,
  private: 1,
  public: 2,
  team: 3,
}

export const favoriteGetFavoritesRpcChannelMap = (configKeys: Array<string>, request: FavoriteGetFavoritesRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.favorite.getFavorites', request)

export const favoriteGetFavoritesRpcPromise = (request: FavoriteGetFavoritesRpcParam): Promise<FavoriteGetFavoritesResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.favorite.getFavorites', request, (error: RPCError, result: FavoriteGetFavoritesResult) => (error ? reject(error) : resolve(result))))

export const fsListRpcChannelMap = (configKeys: Array<string>, request: FsListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.fs.List', request)

export const fsListRpcPromise = (request: FsListRpcParam): Promise<FsListResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.fs.List', request, (error: RPCError, result: FsListResult) => (error ? reject(error) : resolve(result))))

export const gitCreatePersonalRepoRpcChannelMap = (configKeys: Array<string>, request: GitCreatePersonalRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.createPersonalRepo', request)

export const gitCreatePersonalRepoRpcPromise = (request: GitCreatePersonalRepoRpcParam): Promise<GitCreatePersonalRepoResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.createPersonalRepo', request, (error: RPCError, result: GitCreatePersonalRepoResult) => (error ? reject(error) : resolve(result))))

export const gitCreateTeamRepoRpcChannelMap = (configKeys: Array<string>, request: GitCreateTeamRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.createTeamRepo', request)

export const gitCreateTeamRepoRpcPromise = (request: GitCreateTeamRepoRpcParam): Promise<GitCreateTeamRepoResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.createTeamRepo', request, (error: RPCError, result: GitCreateTeamRepoResult) => (error ? reject(error) : resolve(result))))

export const gitDeleteGitMetadataRpcChannelMap = (configKeys: Array<string>, request: GitDeleteGitMetadataRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.deleteGitMetadata', request)

export const gitDeleteGitMetadataRpcPromise = (request: GitDeleteGitMetadataRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.deleteGitMetadata', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gitDeletePersonalRepoRpcChannelMap = (configKeys: Array<string>, request: GitDeletePersonalRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.deletePersonalRepo', request)

export const gitDeletePersonalRepoRpcPromise = (request: GitDeletePersonalRepoRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.deletePersonalRepo', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gitDeleteTeamRepoRpcChannelMap = (configKeys: Array<string>, request: GitDeleteTeamRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.deleteTeamRepo', request)

export const gitDeleteTeamRepoRpcPromise = (request: GitDeleteTeamRepoRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.deleteTeamRepo', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gitGcPersonalRepoRpcChannelMap = (configKeys: Array<string>, request: GitGcPersonalRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.gcPersonalRepo', request)

export const gitGcPersonalRepoRpcPromise = (request: GitGcPersonalRepoRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.gcPersonalRepo', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gitGcTeamRepoRpcChannelMap = (configKeys: Array<string>, request: GitGcTeamRepoRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.gcTeamRepo', request)

export const gitGcTeamRepoRpcPromise = (request: GitGcTeamRepoRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.gcTeamRepo', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gitGetAllGitMetadataRpcChannelMap = (configKeys: Array<string>, request: GitGetAllGitMetadataRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.getAllGitMetadata', request)

export const gitGetAllGitMetadataRpcPromise = (request: GitGetAllGitMetadataRpcParam): Promise<GitGetAllGitMetadataResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.getAllGitMetadata', request, (error: RPCError, result: GitGetAllGitMetadataResult) => (error ? reject(error) : resolve(result))))

export const gitGetGitMetadataRpcChannelMap = (configKeys: Array<string>, request: GitGetGitMetadataRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.getGitMetadata', request)

export const gitGetGitMetadataRpcPromise = (request: GitGetGitMetadataRpcParam): Promise<GitGetGitMetadataResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.getGitMetadata', request, (error: RPCError, result: GitGetGitMetadataResult) => (error ? reject(error) : resolve(result))))

export const gitGetTeamRepoSettingsRpcChannelMap = (configKeys: Array<string>, request: GitGetTeamRepoSettingsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.getTeamRepoSettings', request)

export const gitGetTeamRepoSettingsRpcPromise = (request: GitGetTeamRepoSettingsRpcParam): Promise<GitGetTeamRepoSettingsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.getTeamRepoSettings', request, (error: RPCError, result: GitGetTeamRepoSettingsResult) => (error ? reject(error) : resolve(result))))

export const gitGitLocalMetadataVersion = {
  v1: 1,
}

export const gitGitPushType = {
  default: 0,
  createrepo: 1,
  renamerepo: 3,
}

export const gitGitRepoResultState = {
  err: 0,
  ok: 1,
}

export const gitPutGitMetadataRpcChannelMap = (configKeys: Array<string>, request: GitPutGitMetadataRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.putGitMetadata', request)

export const gitPutGitMetadataRpcPromise = (request: GitPutGitMetadataRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.putGitMetadata', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gitSetTeamRepoSettingsRpcChannelMap = (configKeys: Array<string>, request: GitSetTeamRepoSettingsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.git.setTeamRepoSettings', request)

export const gitSetTeamRepoSettingsRpcPromise = (request: GitSetTeamRepoSettingsRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.git.setTeamRepoSettings', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gregorDismissCategoryRpcChannelMap = (configKeys: Array<string>, request: GregorDismissCategoryRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.gregor.dismissCategory', request)

export const gregorDismissCategoryRpcPromise = (request: GregorDismissCategoryRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.gregor.dismissCategory', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gregorDismissItemRpcChannelMap = (configKeys: Array<string>, request: GregorDismissItemRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.gregor.dismissItem', request)

export const gregorDismissItemRpcPromise = (request: GregorDismissItemRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.gregor.dismissItem', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const gregorGetStateRpcChannelMap = (configKeys: Array<string>, request: GregorGetStateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.gregor.getState', request)

export const gregorGetStateRpcPromise = (request: GregorGetStateRpcParam): Promise<GregorGetStateResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.gregor.getState', request, (error: RPCError, result: GregorGetStateResult) => (error ? reject(error) : resolve(result))))

export const gregorInjectItemRpcChannelMap = (configKeys: Array<string>, request: GregorInjectItemRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.gregor.injectItem', request)

export const gregorInjectItemRpcPromise = (request: GregorInjectItemRpcParam): Promise<GregorInjectItemResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.gregor.injectItem', request, (error: RPCError, result: GregorInjectItemResult) => (error ? reject(error) : resolve(result))))

export const gregorUIPushReason = {
  none: 0,
  reconnected: 1,
  newData: 2,
}

export const homeHomeActionTakenRpcChannelMap = (configKeys: Array<string>, request: HomeHomeActionTakenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.home.homeActionTaken', request)

export const homeHomeActionTakenRpcPromise = (request: HomeHomeActionTakenRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.home.homeActionTaken', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const homeHomeGetScreenRpcChannelMap = (configKeys: Array<string>, request: HomeHomeGetScreenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.home.homeGetScreen', request)

export const homeHomeGetScreenRpcPromise = (request: HomeHomeGetScreenRpcParam): Promise<HomeHomeGetScreenResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.home.homeGetScreen', request, (error: RPCError, result: HomeHomeGetScreenResult) => (error ? reject(error) : resolve(result))))

export const homeHomeMarkViewedRpcChannelMap = (configKeys: Array<string>, request: HomeHomeMarkViewedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.home.homeMarkViewed', request)

export const homeHomeMarkViewedRpcPromise = (request: HomeHomeMarkViewedRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.home.homeMarkViewed', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const homeHomeScreenItemType = {
  todo: 1,
  people: 2,
}

export const homeHomeScreenPeopleNotificationType = {
  followed: 1,
  followedMulti: 2,
}

export const homeHomeScreenTodoType = {
  none: 0,
  bio: 1,
  proof: 2,
  device: 3,
  follow: 4,
  chat: 5,
  paperkey: 6,
  team: 7,
  folder: 8,
  gitRepo: 9,
  teamShowcase: 10,
}

export const homeHomeSkipTodoTypeRpcChannelMap = (configKeys: Array<string>, request: HomeHomeSkipTodoTypeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.home.homeSkipTodoType', request)

export const homeHomeSkipTodoTypeRpcPromise = (request: HomeHomeSkipTodoTypeRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.home.homeSkipTodoType', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const identifyCommonIdentifyReasonType = {
  none: 0,
  id: 1,
  track: 2,
  encrypt: 3,
  decrypt: 4,
  verify: 5,
  resource: 6,
  background: 7,
}

export const identifyCommonTrackDiffType = {
  none: 0,
  error: 1,
  clash: 2,
  revoked: 3,
  upgraded: 4,
  new: 5,
  remoteFail: 6,
  remoteWorking: 7,
  remoteChanged: 8,
  newEldest: 9,
  noneViaTemporary: 10,
}

export const identifyCommonTrackStatus = {
  newOk: 1,
  newZeroProofs: 2,
  newFailProofs: 3,
  updateBrokenFailedProofs: 4,
  updateNewProofs: 5,
  updateOk: 6,
  updateBrokenRevoked: 7,
}

export const identifyIdentify2RpcChannelMap = (configKeys: Array<string>, request: IdentifyIdentify2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.identify.identify2', request)

export const identifyIdentify2RpcPromise = (request: IdentifyIdentify2RpcParam): Promise<IdentifyIdentify2Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.identify.identify2', request, (error: RPCError, result: IdentifyIdentify2Result) => (error ? reject(error) : resolve(result))))

export const identifyIdentifyLiteRpcChannelMap = (configKeys: Array<string>, request: IdentifyIdentifyLiteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.identify.identifyLite', request)

export const identifyIdentifyLiteRpcPromise = (request: IdentifyIdentifyLiteRpcParam): Promise<IdentifyIdentifyLiteResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.identify.identifyLite', request, (error: RPCError, result: IdentifyIdentifyLiteResult) => (error ? reject(error) : resolve(result))))

export const identifyResolve3RpcChannelMap = (configKeys: Array<string>, request: IdentifyResolve3RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.identify.Resolve3', request)

export const identifyResolve3RpcPromise = (request: IdentifyResolve3RpcParam): Promise<IdentifyResolve3Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.identify.Resolve3', request, (error: RPCError, result: IdentifyResolve3Result) => (error ? reject(error) : resolve(result))))

export const identifyResolveIdentifyImplicitTeamRpcChannelMap = (configKeys: Array<string>, request: IdentifyResolveIdentifyImplicitTeamRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.identify.resolveIdentifyImplicitTeam', request)

export const identifyResolveIdentifyImplicitTeamRpcPromise = (request: IdentifyResolveIdentifyImplicitTeamRpcParam): Promise<IdentifyResolveIdentifyImplicitTeamResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.identify.resolveIdentifyImplicitTeam', request, (error: RPCError, result: IdentifyResolveIdentifyImplicitTeamResult) => (error ? reject(error) : resolve(result))))

export const identifyResolveImplicitTeamRpcChannelMap = (configKeys: Array<string>, request: IdentifyResolveImplicitTeamRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.identify.resolveImplicitTeam', request)

export const identifyResolveImplicitTeamRpcPromise = (request: IdentifyResolveImplicitTeamRpcParam): Promise<IdentifyResolveImplicitTeamResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.identify.resolveImplicitTeam', request, (error: RPCError, result: IdentifyResolveImplicitTeamResult) => (error ? reject(error) : resolve(result))))

export const identifyUiCheckResultFreshness = {
  fresh: 0,
  aged: 1,
  rancid: 2,
}

export const identifyUiDismissReasonType = {
  none: 0,
  handledElsewhere: 1,
}

export const implicitTeamMigrationStartMigrationRpcChannelMap = (configKeys: Array<string>, request: ImplicitTeamMigrationStartMigrationRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.implicitTeamMigration.startMigration', request)

export const implicitTeamMigrationStartMigrationRpcPromise = (request: ImplicitTeamMigrationStartMigrationRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.implicitTeamMigration.startMigration', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const installFuseStatusRpcChannelMap = (configKeys: Array<string>, request: InstallFuseStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.install.fuseStatus', request)

export const installFuseStatusRpcPromise = (request: InstallFuseStatusRpcParam): Promise<InstallFuseStatusResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.install.fuseStatus', request, (error: RPCError, result: InstallFuseStatusResult) => (error ? reject(error) : resolve(result))))

export const installInstallAction = {
  unknown: 0,
  none: 1,
  upgrade: 2,
  reinstall: 3,
  install: 4,
}

export const installInstallCommandLinePrivilegedRpcChannelMap = (configKeys: Array<string>, request: InstallInstallCommandLinePrivilegedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.install.installCommandLinePrivileged', request)

export const installInstallCommandLinePrivilegedRpcPromise = (request: InstallInstallCommandLinePrivilegedRpcParam): Promise<InstallInstallCommandLinePrivilegedResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.install.installCommandLinePrivileged', request, (error: RPCError, result: InstallInstallCommandLinePrivilegedResult) => (error ? reject(error) : resolve(result))))

export const installInstallFuseRpcChannelMap = (configKeys: Array<string>, request: InstallInstallFuseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.install.installFuse', request)

export const installInstallFuseRpcPromise = (request: InstallInstallFuseRpcParam): Promise<InstallInstallFuseResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.install.installFuse', request, (error: RPCError, result: InstallInstallFuseResult) => (error ? reject(error) : resolve(result))))

export const installInstallKBFSRpcChannelMap = (configKeys: Array<string>, request: InstallInstallKBFSRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.install.installKBFS', request)

export const installInstallKBFSRpcPromise = (request: InstallInstallKBFSRpcParam): Promise<InstallInstallKBFSResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.install.installKBFS', request, (error: RPCError, result: InstallInstallKBFSResult) => (error ? reject(error) : resolve(result))))

export const installInstallStatus = {
  unknown: 0,
  error: 1,
  notInstalled: 2,
  installed: 4,
}

export const installUninstallKBFSRpcChannelMap = (configKeys: Array<string>, request: InstallUninstallKBFSRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.install.uninstallKBFS', request)

export const installUninstallKBFSRpcPromise = (request: InstallUninstallKBFSRpcParam): Promise<InstallUninstallKBFSResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.install.uninstallKBFS', request, (error: RPCError, result: InstallUninstallKBFSResult) => (error ? reject(error) : resolve(result))))

export const kbfsCommonFSErrorType = {
  accessDenied: 0,
  userNotFound: 1,
  revokedDataDetected: 2,
  notLoggedIn: 3,
  timeout: 4,
  rekeyNeeded: 5,
  badFolder: 6,
  notImplemented: 7,
  oldVersion: 8,
  overQuota: 9,
  noSigChain: 10,
  tooManyFolders: 11,
  exdevNotSupported: 12,
  diskLimitReached: 13,
  diskCacheErrorLogSend: 14,
}

export const kbfsCommonFSNotificationType = {
  encrypting: 0,
  decrypting: 1,
  signing: 2,
  verifying: 3,
  rekeying: 4,
  connection: 5,
  mdReadSuccess: 6,
  fileCreated: 7,
  fileModified: 8,
  fileDeleted: 9,
  fileRenamed: 10,
  initialized: 11,
}

export const kbfsCommonFSStatusCode = {
  start: 0,
  finish: 1,
  error: 2,
}

export const kbfsCreateTLFRpcChannelMap = (configKeys: Array<string>, request: KbfsCreateTLFRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfs.createTLF', request)

export const kbfsCreateTLFRpcPromise = (request: KbfsCreateTLFRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfs.createTLF', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const kbfsFSEditListRpcChannelMap = (configKeys: Array<string>, request: KbfsFSEditListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfs.FSEditList', request)

export const kbfsFSEditListRpcPromise = (request: KbfsFSEditListRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfs.FSEditList', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const kbfsFSEventRpcChannelMap = (configKeys: Array<string>, request: KbfsFSEventRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfs.FSEvent', request)

export const kbfsFSEventRpcPromise = (request: KbfsFSEventRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfs.FSEvent', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const kbfsFSSyncEventRpcChannelMap = (configKeys: Array<string>, request: KbfsFSSyncEventRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfs.FSSyncEvent', request)

export const kbfsFSSyncEventRpcPromise = (request: KbfsFSSyncEventRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfs.FSSyncEvent', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const kbfsFSSyncStatusRpcChannelMap = (configKeys: Array<string>, request: KbfsFSSyncStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfs.FSSyncStatus', request)

export const kbfsFSSyncStatusRpcPromise = (request: KbfsFSSyncStatusRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfs.FSSyncStatus', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const kbfsGetKBFSTeamSettingsRpcChannelMap = (configKeys: Array<string>, request: KbfsGetKBFSTeamSettingsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfs.getKBFSTeamSettings', request)

export const kbfsGetKBFSTeamSettingsRpcPromise = (request: KbfsGetKBFSTeamSettingsRpcParam): Promise<KbfsGetKBFSTeamSettingsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfs.getKBFSTeamSettings', request, (error: RPCError, result: KbfsGetKBFSTeamSettingsResult) => (error ? reject(error) : resolve(result))))

export const kbfsMountGetAllAvailableMountDirsRpcChannelMap = (configKeys: Array<string>, request: KbfsMountGetAllAvailableMountDirsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfsMount.GetAllAvailableMountDirs', request)

export const kbfsMountGetAllAvailableMountDirsRpcPromise = (request: KbfsMountGetAllAvailableMountDirsRpcParam): Promise<KbfsMountGetAllAvailableMountDirsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfsMount.GetAllAvailableMountDirs', request, (error: RPCError, result: KbfsMountGetAllAvailableMountDirsResult) => (error ? reject(error) : resolve(result))))

export const kbfsMountGetCurrentMountDirRpcChannelMap = (configKeys: Array<string>, request: KbfsMountGetCurrentMountDirRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfsMount.GetCurrentMountDir', request)

export const kbfsMountGetCurrentMountDirRpcPromise = (request: KbfsMountGetCurrentMountDirRpcParam): Promise<KbfsMountGetCurrentMountDirResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfsMount.GetCurrentMountDir', request, (error: RPCError, result: KbfsMountGetCurrentMountDirResult) => (error ? reject(error) : resolve(result))))

export const kbfsMountSetCurrentMountDirRpcChannelMap = (configKeys: Array<string>, request: KbfsMountSetCurrentMountDirRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.kbfsMount.SetCurrentMountDir', request)

export const kbfsMountSetCurrentMountDirRpcPromise = (request: KbfsMountSetCurrentMountDirRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.kbfsMount.SetCurrentMountDir', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const logRegisterLoggerRpcChannelMap = (configKeys: Array<string>, request: LogRegisterLoggerRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.log.registerLogger', request)

export const logRegisterLoggerRpcPromise = (request: LogRegisterLoggerRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.log.registerLogger', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginAccountDeleteRpcChannelMap = (configKeys: Array<string>, request: LoginAccountDeleteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.accountDelete', request)

export const loginAccountDeleteRpcPromise = (request: LoginAccountDeleteRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.accountDelete', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginClearStoredSecretRpcChannelMap = (configKeys: Array<string>, request: LoginClearStoredSecretRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.clearStoredSecret', request)

export const loginClearStoredSecretRpcPromise = (request: LoginClearStoredSecretRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.clearStoredSecret', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginDeprovisionRpcChannelMap = (configKeys: Array<string>, request: LoginDeprovisionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.deprovision', request)

export const loginDeprovisionRpcPromise = (request: LoginDeprovisionRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.deprovision', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginGetConfiguredAccountsRpcChannelMap = (configKeys: Array<string>, request: LoginGetConfiguredAccountsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.getConfiguredAccounts', request)

export const loginGetConfiguredAccountsRpcPromise = (request: LoginGetConfiguredAccountsRpcParam): Promise<LoginGetConfiguredAccountsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.getConfiguredAccounts', request, (error: RPCError, result: LoginGetConfiguredAccountsResult) => (error ? reject(error) : resolve(result))))

export const loginLoginProvisionedDeviceRpcChannelMap = (configKeys: Array<string>, request: LoginLoginProvisionedDeviceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.loginProvisionedDevice', request)

export const loginLoginProvisionedDeviceRpcPromise = (request: LoginLoginProvisionedDeviceRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.loginProvisionedDevice', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginLoginRpcChannelMap = (configKeys: Array<string>, request: LoginLoginRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.login', request)

export const loginLoginRpcPromise = (request: LoginLoginRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.login', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginLoginWithPaperKeyRpcChannelMap = (configKeys: Array<string>, request: LoginLoginWithPaperKeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.loginWithPaperKey', request)

export const loginLoginWithPaperKeyRpcPromise = (request: LoginLoginWithPaperKeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.loginWithPaperKey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginLogoutRpcChannelMap = (configKeys: Array<string>, request: LoginLogoutRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.logout', request)

export const loginLogoutRpcPromise = (request: LoginLogoutRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.logout', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginPaperKeyRpcChannelMap = (configKeys: Array<string>, request: LoginPaperKeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.paperKey', request)

export const loginPaperKeyRpcPromise = (request: LoginPaperKeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.paperKey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginPaperKeySubmitRpcChannelMap = (configKeys: Array<string>, request: LoginPaperKeySubmitRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.paperKeySubmit', request)

export const loginPaperKeySubmitRpcPromise = (request: LoginPaperKeySubmitRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.paperKeySubmit', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginPgpProvisionRpcChannelMap = (configKeys: Array<string>, request: LoginPgpProvisionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.pgpProvision', request)

export const loginPgpProvisionRpcPromise = (request: LoginPgpProvisionRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.pgpProvision', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginRecoverAccountFromEmailAddressRpcChannelMap = (configKeys: Array<string>, request: LoginRecoverAccountFromEmailAddressRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.recoverAccountFromEmailAddress', request)

export const loginRecoverAccountFromEmailAddressRpcPromise = (request: LoginRecoverAccountFromEmailAddressRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.recoverAccountFromEmailAddress', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginUnlockRpcChannelMap = (configKeys: Array<string>, request: LoginUnlockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.unlock', request)

export const loginUnlockRpcPromise = (request: LoginUnlockRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.unlock', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const loginUnlockWithPassphraseRpcChannelMap = (configKeys: Array<string>, request: LoginUnlockWithPassphraseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.login.unlockWithPassphrase', request)

export const loginUnlockWithPassphraseRpcPromise = (request: LoginUnlockWithPassphraseRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.login.unlockWithPassphrase', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const merkleGetCurrentMerkleRootRpcChannelMap = (configKeys: Array<string>, request: MerkleGetCurrentMerkleRootRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.merkle.getCurrentMerkleRoot', request)

export const merkleGetCurrentMerkleRootRpcPromise = (request: MerkleGetCurrentMerkleRootRpcParam): Promise<MerkleGetCurrentMerkleRootResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.merkle.getCurrentMerkleRoot', request, (error: RPCError, result: MerkleGetCurrentMerkleRootResult) => (error ? reject(error) : resolve(result))))

export const metadataAuthenticateRpcChannelMap = (configKeys: Array<string>, request: MetadataAuthenticateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.authenticate', request)

export const metadataAuthenticateRpcPromise = (request: MetadataAuthenticateRpcParam): Promise<MetadataAuthenticateResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.authenticate', request, (error: RPCError, result: MetadataAuthenticateResult) => (error ? reject(error) : resolve(result))))

export const metadataDeleteKeyRpcChannelMap = (configKeys: Array<string>, request: MetadataDeleteKeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.deleteKey', request)

export const metadataDeleteKeyRpcPromise = (request: MetadataDeleteKeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.deleteKey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataGetChallengeRpcChannelMap = (configKeys: Array<string>, request: MetadataGetChallengeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getChallenge', request)

export const metadataGetChallengeRpcPromise = (request: MetadataGetChallengeRpcParam): Promise<MetadataGetChallengeResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getChallenge', request, (error: RPCError, result: MetadataGetChallengeResult) => (error ? reject(error) : resolve(result))))

export const metadataGetFolderHandleRpcChannelMap = (configKeys: Array<string>, request: MetadataGetFolderHandleRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getFolderHandle', request)

export const metadataGetFolderHandleRpcPromise = (request: MetadataGetFolderHandleRpcParam): Promise<MetadataGetFolderHandleResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getFolderHandle', request, (error: RPCError, result: MetadataGetFolderHandleResult) => (error ? reject(error) : resolve(result))))

export const metadataGetFoldersForRekeyRpcChannelMap = (configKeys: Array<string>, request: MetadataGetFoldersForRekeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getFoldersForRekey', request)

export const metadataGetFoldersForRekeyRpcPromise = (request: MetadataGetFoldersForRekeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getFoldersForRekey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataGetKeyBundlesRpcChannelMap = (configKeys: Array<string>, request: MetadataGetKeyBundlesRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getKeyBundles', request)

export const metadataGetKeyBundlesRpcPromise = (request: MetadataGetKeyBundlesRpcParam): Promise<MetadataGetKeyBundlesResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getKeyBundles', request, (error: RPCError, result: MetadataGetKeyBundlesResult) => (error ? reject(error) : resolve(result))))

export const metadataGetKeyRpcChannelMap = (configKeys: Array<string>, request: MetadataGetKeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getKey', request)

export const metadataGetKeyRpcPromise = (request: MetadataGetKeyRpcParam): Promise<MetadataGetKeyResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getKey', request, (error: RPCError, result: MetadataGetKeyResult) => (error ? reject(error) : resolve(result))))

export const metadataGetLatestFolderHandleRpcChannelMap = (configKeys: Array<string>, request: MetadataGetLatestFolderHandleRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getLatestFolderHandle', request)

export const metadataGetLatestFolderHandleRpcPromise = (request: MetadataGetLatestFolderHandleRpcParam): Promise<MetadataGetLatestFolderHandleResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getLatestFolderHandle', request, (error: RPCError, result: MetadataGetLatestFolderHandleResult) => (error ? reject(error) : resolve(result))))

export const metadataGetMerkleNodeRpcChannelMap = (configKeys: Array<string>, request: MetadataGetMerkleNodeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getMerkleNode', request)

export const metadataGetMerkleNodeRpcPromise = (request: MetadataGetMerkleNodeRpcParam): Promise<MetadataGetMerkleNodeResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getMerkleNode', request, (error: RPCError, result: MetadataGetMerkleNodeResult) => (error ? reject(error) : resolve(result))))

export const metadataGetMerkleRootLatestRpcChannelMap = (configKeys: Array<string>, request: MetadataGetMerkleRootLatestRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getMerkleRootLatest', request)

export const metadataGetMerkleRootLatestRpcPromise = (request: MetadataGetMerkleRootLatestRpcParam): Promise<MetadataGetMerkleRootLatestResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getMerkleRootLatest', request, (error: RPCError, result: MetadataGetMerkleRootLatestResult) => (error ? reject(error) : resolve(result))))

export const metadataGetMerkleRootRpcChannelMap = (configKeys: Array<string>, request: MetadataGetMerkleRootRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getMerkleRoot', request)

export const metadataGetMerkleRootRpcPromise = (request: MetadataGetMerkleRootRpcParam): Promise<MetadataGetMerkleRootResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getMerkleRoot', request, (error: RPCError, result: MetadataGetMerkleRootResult) => (error ? reject(error) : resolve(result))))

export const metadataGetMerkleRootSinceRpcChannelMap = (configKeys: Array<string>, request: MetadataGetMerkleRootSinceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getMerkleRootSince', request)

export const metadataGetMerkleRootSinceRpcPromise = (request: MetadataGetMerkleRootSinceRpcParam): Promise<MetadataGetMerkleRootSinceResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getMerkleRootSince', request, (error: RPCError, result: MetadataGetMerkleRootSinceResult) => (error ? reject(error) : resolve(result))))

export const metadataGetMetadataRpcChannelMap = (configKeys: Array<string>, request: MetadataGetMetadataRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.getMetadata', request)

export const metadataGetMetadataRpcPromise = (request: MetadataGetMetadataRpcParam): Promise<MetadataGetMetadataResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.getMetadata', request, (error: RPCError, result: MetadataGetMetadataResult) => (error ? reject(error) : resolve(result))))

export const metadataLockRpcChannelMap = (configKeys: Array<string>, request: MetadataLockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.lock', request)

export const metadataLockRpcPromise = (request: MetadataLockRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.lock', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataPing2RpcChannelMap = (configKeys: Array<string>, request: MetadataPing2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.ping2', request)

export const metadataPing2RpcPromise = (request: MetadataPing2RpcParam): Promise<MetadataPing2Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.ping2', request, (error: RPCError, result: MetadataPing2Result) => (error ? reject(error) : resolve(result))))

export const metadataPingRpcChannelMap = (configKeys: Array<string>, request: MetadataPingRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.ping', request)

export const metadataPingRpcPromise = (request: MetadataPingRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.ping', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataPruneBranchRpcChannelMap = (configKeys: Array<string>, request: MetadataPruneBranchRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.pruneBranch', request)

export const metadataPruneBranchRpcPromise = (request: MetadataPruneBranchRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.pruneBranch', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataPutKeysRpcChannelMap = (configKeys: Array<string>, request: MetadataPutKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.putKeys', request)

export const metadataPutKeysRpcPromise = (request: MetadataPutKeysRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.putKeys', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataPutMetadataRpcChannelMap = (configKeys: Array<string>, request: MetadataPutMetadataRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.putMetadata', request)

export const metadataPutMetadataRpcPromise = (request: MetadataPutMetadataRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.putMetadata', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataRegisterForUpdatesRpcChannelMap = (configKeys: Array<string>, request: MetadataRegisterForUpdatesRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.registerForUpdates', request)

export const metadataRegisterForUpdatesRpcPromise = (request: MetadataRegisterForUpdatesRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.registerForUpdates', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataReleaseLockRpcChannelMap = (configKeys: Array<string>, request: MetadataReleaseLockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.releaseLock', request)

export const metadataReleaseLockRpcPromise = (request: MetadataReleaseLockRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.releaseLock', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataStartImplicitTeamMigrationRpcChannelMap = (configKeys: Array<string>, request: MetadataStartImplicitTeamMigrationRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.startImplicitTeamMigration', request)

export const metadataStartImplicitTeamMigrationRpcPromise = (request: MetadataStartImplicitTeamMigrationRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.startImplicitTeamMigration', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataTruncateLockRpcChannelMap = (configKeys: Array<string>, request: MetadataTruncateLockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.truncateLock', request)

export const metadataTruncateLockRpcPromise = (request: MetadataTruncateLockRpcParam): Promise<MetadataTruncateLockResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.truncateLock', request, (error: RPCError, result: MetadataTruncateLockResult) => (error ? reject(error) : resolve(result))))

export const metadataTruncateUnlockRpcChannelMap = (configKeys: Array<string>, request: MetadataTruncateUnlockRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadata.truncateUnlock', request)

export const metadataTruncateUnlockRpcPromise = (request: MetadataTruncateUnlockRpcParam): Promise<MetadataTruncateUnlockResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadata.truncateUnlock', request, (error: RPCError, result: MetadataTruncateUnlockResult) => (error ? reject(error) : resolve(result))))

export const metadataUpdateFolderNeedsRekeyRpcChannelMap = (configKeys: Array<string>, request: MetadataUpdateFolderNeedsRekeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadataUpdate.folderNeedsRekey', request)

export const metadataUpdateFolderNeedsRekeyRpcPromise = (request: MetadataUpdateFolderNeedsRekeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadataUpdate.folderNeedsRekey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataUpdateFoldersNeedRekeyRpcChannelMap = (configKeys: Array<string>, request: MetadataUpdateFoldersNeedRekeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadataUpdate.foldersNeedRekey', request)

export const metadataUpdateFoldersNeedRekeyRpcPromise = (request: MetadataUpdateFoldersNeedRekeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadataUpdate.foldersNeedRekey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const metadataUpdateMetadataUpdateRpcChannelMap = (configKeys: Array<string>, request: MetadataUpdateMetadataUpdateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.metadataUpdate.metadataUpdate', request)

export const metadataUpdateMetadataUpdateRpcPromise = (request: MetadataUpdateMetadataUpdateRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.metadataUpdate.metadataUpdate', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const notifyCtlSetNotificationsRpcChannelMap = (configKeys: Array<string>, request: NotifyCtlSetNotificationsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.notifyCtl.setNotifications', request)

export const notifyCtlSetNotificationsRpcPromise = (request: NotifyCtlSetNotificationsRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.notifyCtl.setNotifications', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const paperprovisionPaperProvisionRpcChannelMap = (configKeys: Array<string>, request: PaperprovisionPaperProvisionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.paperprovision.paperProvision', request)

export const paperprovisionPaperProvisionRpcPromise = (request: PaperprovisionPaperProvisionRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.paperprovision.paperProvision', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const passphraseCommonPassphraseType = {
  none: 0,
  paperKey: 1,
  passPhrase: 2,
  verifyPassPhrase: 3,
}

export const pgpPgpDecryptRpcChannelMap = (configKeys: Array<string>, request: PgpPgpDecryptRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpDecrypt', request)

export const pgpPgpDecryptRpcPromise = (request: PgpPgpDecryptRpcParam): Promise<PgpPgpDecryptResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpDecrypt', request, (error: RPCError, result: PgpPgpDecryptResult) => (error ? reject(error) : resolve(result))))

export const pgpPgpDeletePrimaryRpcChannelMap = (configKeys: Array<string>, request: PgpPgpDeletePrimaryRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpDeletePrimary', request)

export const pgpPgpDeletePrimaryRpcPromise = (request: PgpPgpDeletePrimaryRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpDeletePrimary', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpEncryptRpcChannelMap = (configKeys: Array<string>, request: PgpPgpEncryptRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpEncrypt', request)

export const pgpPgpEncryptRpcPromise = (request: PgpPgpEncryptRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpEncrypt', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpExportByFingerprintRpcChannelMap = (configKeys: Array<string>, request: PgpPgpExportByFingerprintRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpExportByFingerprint', request)

export const pgpPgpExportByFingerprintRpcPromise = (request: PgpPgpExportByFingerprintRpcParam): Promise<PgpPgpExportByFingerprintResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpExportByFingerprint', request, (error: RPCError, result: PgpPgpExportByFingerprintResult) => (error ? reject(error) : resolve(result))))

export const pgpPgpExportByKIDRpcChannelMap = (configKeys: Array<string>, request: PgpPgpExportByKIDRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpExportByKID', request)

export const pgpPgpExportByKIDRpcPromise = (request: PgpPgpExportByKIDRpcParam): Promise<PgpPgpExportByKIDResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpExportByKID', request, (error: RPCError, result: PgpPgpExportByKIDResult) => (error ? reject(error) : resolve(result))))

export const pgpPgpExportRpcChannelMap = (configKeys: Array<string>, request: PgpPgpExportRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpExport', request)

export const pgpPgpExportRpcPromise = (request: PgpPgpExportRpcParam): Promise<PgpPgpExportResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpExport', request, (error: RPCError, result: PgpPgpExportResult) => (error ? reject(error) : resolve(result))))

export const pgpPgpImportRpcChannelMap = (configKeys: Array<string>, request: PgpPgpImportRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpImport', request)

export const pgpPgpImportRpcPromise = (request: PgpPgpImportRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpImport', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpKeyGenDefaultRpcChannelMap = (configKeys: Array<string>, request: PgpPgpKeyGenDefaultRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpKeyGenDefault', request)

export const pgpPgpKeyGenDefaultRpcPromise = (request: PgpPgpKeyGenDefaultRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpKeyGenDefault', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpKeyGenRpcChannelMap = (configKeys: Array<string>, request: PgpPgpKeyGenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpKeyGen', request)

export const pgpPgpKeyGenRpcPromise = (request: PgpPgpKeyGenRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpKeyGen', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpPullRpcChannelMap = (configKeys: Array<string>, request: PgpPgpPullRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpPull', request)

export const pgpPgpPullRpcPromise = (request: PgpPgpPullRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpPull', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpPurgeRpcChannelMap = (configKeys: Array<string>, request: PgpPgpPurgeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpPurge', request)

export const pgpPgpPurgeRpcPromise = (request: PgpPgpPurgeRpcParam): Promise<PgpPgpPurgeResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpPurge', request, (error: RPCError, result: PgpPgpPurgeResult) => (error ? reject(error) : resolve(result))))

export const pgpPgpSelectRpcChannelMap = (configKeys: Array<string>, request: PgpPgpSelectRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpSelect', request)

export const pgpPgpSelectRpcPromise = (request: PgpPgpSelectRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpSelect', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpSignRpcChannelMap = (configKeys: Array<string>, request: PgpPgpSignRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpSign', request)

export const pgpPgpSignRpcPromise = (request: PgpPgpSignRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpSign', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpStorageDismissRpcChannelMap = (configKeys: Array<string>, request: PgpPgpStorageDismissRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpStorageDismiss', request)

export const pgpPgpStorageDismissRpcPromise = (request: PgpPgpStorageDismissRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpStorageDismiss', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpUpdateRpcChannelMap = (configKeys: Array<string>, request: PgpPgpUpdateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpUpdate', request)

export const pgpPgpUpdateRpcPromise = (request: PgpPgpUpdateRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpUpdate', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pgpPgpVerifyRpcChannelMap = (configKeys: Array<string>, request: PgpPgpVerifyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpVerify', request)

export const pgpPgpVerifyRpcPromise = (request: PgpPgpVerifyRpcParam): Promise<PgpPgpVerifyResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pgp.pgpVerify', request, (error: RPCError, result: PgpPgpVerifyResult) => (error ? reject(error) : resolve(result))))

export const pgpSignMode = {
  attached: 0,
  detached: 1,
  clear: 2,
}

export const pprofLogProcessorProfileRpcChannelMap = (configKeys: Array<string>, request: PprofLogProcessorProfileRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pprof.logProcessorProfile', request)

export const pprofLogProcessorProfileRpcPromise = (request: PprofLogProcessorProfileRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pprof.logProcessorProfile', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pprofLogTraceRpcChannelMap = (configKeys: Array<string>, request: PprofLogTraceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pprof.logTrace', request)

export const pprofLogTraceRpcPromise = (request: PprofLogTraceRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pprof.logTrace', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pprofProcessorProfileRpcChannelMap = (configKeys: Array<string>, request: PprofProcessorProfileRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pprof.processorProfile', request)

export const pprofProcessorProfileRpcPromise = (request: PprofProcessorProfileRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pprof.processorProfile', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const pprofTraceRpcChannelMap = (configKeys: Array<string>, request: PprofTraceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pprof.trace', request)

export const pprofTraceRpcPromise = (request: PprofTraceRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.pprof.trace', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const processFileType = {
  unknown: 0,
  directory: 1,
  file: 2,
}

export const proveCheckProofRpcChannelMap = (configKeys: Array<string>, request: ProveCheckProofRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.prove.checkProof', request)

export const proveCheckProofRpcPromise = (request: ProveCheckProofRpcParam): Promise<ProveCheckProofResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.prove.checkProof', request, (error: RPCError, result: ProveCheckProofResult) => (error ? reject(error) : resolve(result))))

export const proveCommonProofState = {
  none: 0,
  ok: 1,
  tempFailure: 2,
  permFailure: 3,
  looking: 4,
  superseded: 5,
  posted: 6,
  revoked: 7,
  deleted: 8,
  unknownType: 9,
  sigHintMissing: 10,
  unchecked: 11,
}

export const proveCommonProofStatus = {
  none: 0,
  ok: 1,
  local: 2,
  found: 3,
  baseError: 100,
  hostUnreachable: 101,
  permissionDenied: 103,
  failedParse: 106,
  dnsError: 107,
  authFailed: 108,
  http429: 129,
  http500: 150,
  timeout: 160,
  internalError: 170,
  unchecked: 171,
  missingPvl: 172,
  baseHardError: 200,
  notFound: 201,
  contentFailure: 202,
  badUsername: 203,
  badRemoteId: 204,
  textNotFound: 205,
  badArgs: 206,
  contentMissing: 207,
  titleNotFound: 208,
  serviceError: 209,
  torSkipped: 210,
  torIncompatible: 211,
  http300: 230,
  http400: 240,
  httpOther: 260,
  emptyJson: 270,
  deleted: 301,
  serviceDead: 302,
  badSignature: 303,
  badApiUrl: 304,
  unknownType: 305,
  noHint: 306,
  badHintText: 307,
  invalidPvl: 308,
}

export const proveCommonProofType = {
  none: 0,
  keybase: 1,
  twitter: 2,
  github: 3,
  reddit: 4,
  coinbase: 5,
  hackernews: 6,
  facebook: 8,
  genericWebSite: 1000,
  dns: 1001,
  pgp: 1002,
  rooter: 100001,
}

export const proveStartProofRpcChannelMap = (configKeys: Array<string>, request: ProveStartProofRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.prove.startProof', request)

export const proveStartProofRpcPromise = (request: ProveStartProofRpcParam): Promise<ProveStartProofResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.prove.startProof', request, (error: RPCError, result: ProveStartProofResult) => (error ? reject(error) : resolve(result))))

export const proveUiPromptOverwriteType = {
  social: 0,
  site: 1,
}

export const provisionUiChooseType = {
  existingDevice: 0,
  newDevice: 1,
}

export const provisionUiGPGMethod = {
  gpgNone: 0,
  gpgImport: 1,
  gpgSign: 2,
}

export const provisionUiProvisionMethod = {
  device: 0,
  paperKey: 1,
  passphrase: 2,
  gpgImport: 3,
  gpgSign: 4,
}

export const quotaVerifySessionRpcChannelMap = (configKeys: Array<string>, request: QuotaVerifySessionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.quota.verifySession', request)

export const quotaVerifySessionRpcPromise = (request: QuotaVerifySessionRpcParam): Promise<QuotaVerifySessionResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.quota.verifySession', request, (error: RPCError, result: QuotaVerifySessionResult) => (error ? reject(error) : resolve(result))))

export const reachabilityCheckReachabilityRpcChannelMap = (configKeys: Array<string>, request: ReachabilityCheckReachabilityRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.reachability.checkReachability', request)

export const reachabilityCheckReachabilityRpcPromise = (request: ReachabilityCheckReachabilityRpcParam): Promise<ReachabilityCheckReachabilityResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.reachability.checkReachability', request, (error: RPCError, result: ReachabilityCheckReachabilityResult) => (error ? reject(error) : resolve(result))))

export const reachabilityReachabilityChangedRpcChannelMap = (configKeys: Array<string>, request: ReachabilityReachabilityChangedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.reachability.reachabilityChanged', request)

export const reachabilityReachabilityChangedRpcPromise = (request: ReachabilityReachabilityChangedRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.reachability.reachabilityChanged', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const reachabilityReachable = {
  unknown: 0,
  yes: 1,
  no: 2,
}

export const reachabilityStartReachabilityRpcChannelMap = (configKeys: Array<string>, request: ReachabilityStartReachabilityRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.reachability.startReachability', request)

export const reachabilityStartReachabilityRpcPromise = (request: ReachabilityStartReachabilityRpcParam): Promise<ReachabilityStartReachabilityResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.reachability.startReachability', request, (error: RPCError, result: ReachabilityStartReachabilityResult) => (error ? reject(error) : resolve(result))))

export const rekeyDebugShowRekeyStatusRpcChannelMap = (configKeys: Array<string>, request: RekeyDebugShowRekeyStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.rekey.debugShowRekeyStatus', request)

export const rekeyDebugShowRekeyStatusRpcPromise = (request: RekeyDebugShowRekeyStatusRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.rekey.debugShowRekeyStatus', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const rekeyGetPendingRekeyStatusRpcChannelMap = (configKeys: Array<string>, request: RekeyGetPendingRekeyStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.rekey.getPendingRekeyStatus', request)

export const rekeyGetPendingRekeyStatusRpcPromise = (request: RekeyGetPendingRekeyStatusRpcParam): Promise<RekeyGetPendingRekeyStatusResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.rekey.getPendingRekeyStatus', request, (error: RPCError, result: RekeyGetPendingRekeyStatusResult) => (error ? reject(error) : resolve(result))))

export const rekeyGetRevokeWarningRpcChannelMap = (configKeys: Array<string>, request: RekeyGetRevokeWarningRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.rekey.getRevokeWarning', request)

export const rekeyGetRevokeWarningRpcPromise = (request: RekeyGetRevokeWarningRpcParam): Promise<RekeyGetRevokeWarningResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.rekey.getRevokeWarning', request, (error: RPCError, result: RekeyGetRevokeWarningResult) => (error ? reject(error) : resolve(result))))

export const rekeyOutcome = {
  none: 0,
  fixed: 1,
  ignored: 2,
}

export const rekeyRekeyStatusFinishRpcChannelMap = (configKeys: Array<string>, request: RekeyRekeyStatusFinishRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.rekey.rekeyStatusFinish', request)

export const rekeyRekeyStatusFinishRpcPromise = (request: RekeyRekeyStatusFinishRpcParam): Promise<RekeyRekeyStatusFinishResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.rekey.rekeyStatusFinish', request, (error: RPCError, result: RekeyRekeyStatusFinishResult) => (error ? reject(error) : resolve(result))))

export const rekeyRekeySyncRpcChannelMap = (configKeys: Array<string>, request: RekeyRekeySyncRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.rekey.rekeySync', request)

export const rekeyRekeySyncRpcPromise = (request: RekeyRekeySyncRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.rekey.rekeySync', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const rekeyShowPendingRekeyStatusRpcChannelMap = (configKeys: Array<string>, request: RekeyShowPendingRekeyStatusRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.rekey.showPendingRekeyStatus', request)

export const rekeyShowPendingRekeyStatusRpcPromise = (request: RekeyShowPendingRekeyStatusRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.rekey.showPendingRekeyStatus', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const rekeyUIRekeyEventType = {
  none: 0,
  notLoggedIn: 1,
  apiError: 2,
  noProblems: 3,
  loadMeError: 4,
  currentDeviceCanRekey: 5,
  deviceLoadError: 6,
  harass: 7,
  noGregorMessages: 8,
}

export const resetResetType = {
  none: 0,
  reset: 1,
  delete: 2,
}

export const revokeRevokeDeviceRpcChannelMap = (configKeys: Array<string>, request: RevokeRevokeDeviceRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.revoke.revokeDevice', request)

export const revokeRevokeDeviceRpcPromise = (request: RevokeRevokeDeviceRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.revoke.revokeDevice', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const revokeRevokeKeyRpcChannelMap = (configKeys: Array<string>, request: RevokeRevokeKeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.revoke.revokeKey', request)

export const revokeRevokeKeyRpcPromise = (request: RevokeRevokeKeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.revoke.revokeKey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const revokeRevokeSigsRpcChannelMap = (configKeys: Array<string>, request: RevokeRevokeSigsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.revoke.revokeSigs', request)

export const revokeRevokeSigsRpcPromise = (request: RevokeRevokeSigsRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.revoke.revokeSigs', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const saltpackSaltpackDecryptRpcChannelMap = (configKeys: Array<string>, request: SaltpackSaltpackDecryptRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.saltpack.saltpackDecrypt', request)

export const saltpackSaltpackDecryptRpcPromise = (request: SaltpackSaltpackDecryptRpcParam): Promise<SaltpackSaltpackDecryptResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.saltpack.saltpackDecrypt', request, (error: RPCError, result: SaltpackSaltpackDecryptResult) => (error ? reject(error) : resolve(result))))

export const saltpackSaltpackEncryptRpcChannelMap = (configKeys: Array<string>, request: SaltpackSaltpackEncryptRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.saltpack.saltpackEncrypt', request)

export const saltpackSaltpackEncryptRpcPromise = (request: SaltpackSaltpackEncryptRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.saltpack.saltpackEncrypt', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const saltpackSaltpackSignRpcChannelMap = (configKeys: Array<string>, request: SaltpackSaltpackSignRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.saltpack.saltpackSign', request)

export const saltpackSaltpackSignRpcPromise = (request: SaltpackSaltpackSignRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.saltpack.saltpackSign', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const saltpackSaltpackVerifyRpcChannelMap = (configKeys: Array<string>, request: SaltpackSaltpackVerifyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.saltpack.saltpackVerify', request)

export const saltpackSaltpackVerifyRpcPromise = (request: SaltpackSaltpackVerifyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.saltpack.saltpackVerify', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const saltpackUiSaltpackSenderType = {
  notTracked: 0,
  unknown: 1,
  anonymous: 2,
  trackingBroke: 3,
  trackingOk: 4,
  self: 5,
  revoked: 6,
  expired: 7,
}

export const sessionCurrentSessionRpcChannelMap = (configKeys: Array<string>, request: SessionCurrentSessionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.session.currentSession', request)

export const sessionCurrentSessionRpcPromise = (request: SessionCurrentSessionRpcParam): Promise<SessionCurrentSessionResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.session.currentSession', request, (error: RPCError, result: SessionCurrentSessionResult) => (error ? reject(error) : resolve(result))))

export const sessionSessionPingRpcChannelMap = (configKeys: Array<string>, request: SessionSessionPingRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.session.sessionPing', request)

export const sessionSessionPingRpcPromise = (request: SessionSessionPingRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.session.sessionPing', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const signupCheckInvitationCodeRpcChannelMap = (configKeys: Array<string>, request: SignupCheckInvitationCodeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.signup.checkInvitationCode', request)

export const signupCheckInvitationCodeRpcPromise = (request: SignupCheckInvitationCodeRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.signup.checkInvitationCode', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const signupCheckUsernameAvailableRpcChannelMap = (configKeys: Array<string>, request: SignupCheckUsernameAvailableRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.signup.checkUsernameAvailable', request)

export const signupCheckUsernameAvailableRpcPromise = (request: SignupCheckUsernameAvailableRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.signup.checkUsernameAvailable', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const signupGetInvitationCodeRpcChannelMap = (configKeys: Array<string>, request: SignupGetInvitationCodeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.signup.getInvitationCode', request)

export const signupGetInvitationCodeRpcPromise = (request: SignupGetInvitationCodeRpcParam): Promise<SignupGetInvitationCodeResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.signup.getInvitationCode', request, (error: RPCError, result: SignupGetInvitationCodeResult) => (error ? reject(error) : resolve(result))))

export const signupInviteRequestRpcChannelMap = (configKeys: Array<string>, request: SignupInviteRequestRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.signup.inviteRequest', request)

export const signupInviteRequestRpcPromise = (request: SignupInviteRequestRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.signup.inviteRequest', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const signupSignupRpcChannelMap = (configKeys: Array<string>, request: SignupSignupRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.signup.signup', request)

export const signupSignupRpcPromise = (request: SignupSignupRpcParam): Promise<SignupSignupResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.signup.signup', request, (error: RPCError, result: SignupSignupResult) => (error ? reject(error) : resolve(result))))

export const sigsSigListJSONRpcChannelMap = (configKeys: Array<string>, request: SigsSigListJSONRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.sigs.sigListJSON', request)

export const sigsSigListJSONRpcPromise = (request: SigsSigListJSONRpcParam): Promise<SigsSigListJSONResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.sigs.sigListJSON', request, (error: RPCError, result: SigsSigListJSONResult) => (error ? reject(error) : resolve(result))))

export const sigsSigListRpcChannelMap = (configKeys: Array<string>, request: SigsSigListRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.sigs.sigList', request)

export const sigsSigListRpcPromise = (request: SigsSigListRpcParam): Promise<SigsSigListResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.sigs.sigList', request, (error: RPCError, result: SigsSigListResult) => (error ? reject(error) : resolve(result))))

export const simpleFSAsyncOps = {
  list: 0,
  listRecursive: 1,
  read: 2,
  write: 3,
  copy: 4,
  move: 5,
  remove: 6,
}

export const simpleFSDirentType = {
  file: 0,
  dir: 1,
  sym: 2,
  exec: 3,
}

export const simpleFSListFilter = {
  noFilter: 0,
  filterAllHidden: 1,
}

export const simpleFSOpenFlags = {
  read: 0,
  replace: 1,
  existing: 2,
  write: 4,
  append: 8,
  directory: 16,
}

export const simpleFSPathType = {
  local: 0,
  kbfs: 1,
}

export const stellarStellarAccountMode = {
  none: 0,
  user: 1,
}

export const stellarStellarBundleVersion = {
  v1: 1,
}

export const teamsCanUserPerformRpcChannelMap = (configKeys: Array<string>, request: TeamsCanUserPerformRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.canUserPerform', request)

export const teamsCanUserPerformRpcPromise = (request: TeamsCanUserPerformRpcParam): Promise<TeamsCanUserPerformResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.canUserPerform', request, (error: RPCError, result: TeamsCanUserPerformResult) => (error ? reject(error) : resolve(result))))

export const teamsGetTarsDisabledRpcChannelMap = (configKeys: Array<string>, request: TeamsGetTarsDisabledRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.getTarsDisabled', request)

export const teamsGetTarsDisabledRpcPromise = (request: TeamsGetTarsDisabledRpcParam): Promise<TeamsGetTarsDisabledResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.getTarsDisabled', request, (error: RPCError, result: TeamsGetTarsDisabledResult) => (error ? reject(error) : resolve(result))))

export const teamsGetTeamAndMemberShowcaseRpcChannelMap = (configKeys: Array<string>, request: TeamsGetTeamAndMemberShowcaseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.getTeamAndMemberShowcase', request)

export const teamsGetTeamAndMemberShowcaseRpcPromise = (request: TeamsGetTeamAndMemberShowcaseRpcParam): Promise<TeamsGetTeamAndMemberShowcaseResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.getTeamAndMemberShowcase', request, (error: RPCError, result: TeamsGetTeamAndMemberShowcaseResult) => (error ? reject(error) : resolve(result))))

export const teamsGetTeamRootIDRpcChannelMap = (configKeys: Array<string>, request: TeamsGetTeamRootIDRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.getTeamRootID', request)

export const teamsGetTeamRootIDRpcPromise = (request: TeamsGetTeamRootIDRpcParam): Promise<TeamsGetTeamRootIDResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.getTeamRootID', request, (error: RPCError, result: TeamsGetTeamRootIDResult) => (error ? reject(error) : resolve(result))))

export const teamsGetTeamShowcaseRpcChannelMap = (configKeys: Array<string>, request: TeamsGetTeamShowcaseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.getTeamShowcase', request)

export const teamsGetTeamShowcaseRpcPromise = (request: TeamsGetTeamShowcaseRpcParam): Promise<TeamsGetTeamShowcaseResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.getTeamShowcase', request, (error: RPCError, result: TeamsGetTeamShowcaseResult) => (error ? reject(error) : resolve(result))))

export const teamsLoadTeamPlusApplicationKeysRpcChannelMap = (configKeys: Array<string>, request: TeamsLoadTeamPlusApplicationKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.loadTeamPlusApplicationKeys', request)

export const teamsLoadTeamPlusApplicationKeysRpcPromise = (request: TeamsLoadTeamPlusApplicationKeysRpcParam): Promise<TeamsLoadTeamPlusApplicationKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.loadTeamPlusApplicationKeys', request, (error: RPCError, result: TeamsLoadTeamPlusApplicationKeysResult) => (error ? reject(error) : resolve(result))))

export const teamsLookupImplicitTeamRpcChannelMap = (configKeys: Array<string>, request: TeamsLookupImplicitTeamRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.lookupImplicitTeam', request)

export const teamsLookupImplicitTeamRpcPromise = (request: TeamsLookupImplicitTeamRpcParam): Promise<TeamsLookupImplicitTeamResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.lookupImplicitTeam', request, (error: RPCError, result: TeamsLookupImplicitTeamResult) => (error ? reject(error) : resolve(result))))

export const teamsLookupOrCreateImplicitTeamRpcChannelMap = (configKeys: Array<string>, request: TeamsLookupOrCreateImplicitTeamRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.lookupOrCreateImplicitTeam', request)

export const teamsLookupOrCreateImplicitTeamRpcPromise = (request: TeamsLookupOrCreateImplicitTeamRpcParam): Promise<TeamsLookupOrCreateImplicitTeamResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.lookupOrCreateImplicitTeam', request, (error: RPCError, result: TeamsLookupOrCreateImplicitTeamResult) => (error ? reject(error) : resolve(result))))

export const teamsSeitanKeyAndLabelVersion = {
  v1: 1,
  v2: 2,
}

export const teamsSeitanKeyLabelType = {
  sms: 1,
}

export const teamsSetTarsDisabledRpcChannelMap = (configKeys: Array<string>, request: TeamsSetTarsDisabledRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.setTarsDisabled', request)

export const teamsSetTarsDisabledRpcPromise = (request: TeamsSetTarsDisabledRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.setTarsDisabled', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsSetTeamMemberShowcaseRpcChannelMap = (configKeys: Array<string>, request: TeamsSetTeamMemberShowcaseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.setTeamMemberShowcase', request)

export const teamsSetTeamMemberShowcaseRpcPromise = (request: TeamsSetTeamMemberShowcaseRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.setTeamMemberShowcase', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsSetTeamShowcaseRpcChannelMap = (configKeys: Array<string>, request: TeamsSetTeamShowcaseRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.setTeamShowcase', request)

export const teamsSetTeamShowcaseRpcPromise = (request: TeamsSetTeamShowcaseRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.setTeamShowcase', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamAcceptInviteOrRequestAccessRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamAcceptInviteOrRequestAccessRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamAcceptInviteOrRequestAccess', request)

export const teamsTeamAcceptInviteOrRequestAccessRpcPromise = (request: TeamsTeamAcceptInviteOrRequestAccessRpcParam): Promise<TeamsTeamAcceptInviteOrRequestAccessResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamAcceptInviteOrRequestAccess', request, (error: RPCError, result: TeamsTeamAcceptInviteOrRequestAccessResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamAcceptInviteRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamAcceptInviteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamAcceptInvite', request)

export const teamsTeamAcceptInviteRpcPromise = (request: TeamsTeamAcceptInviteRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamAcceptInvite', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamAddEmailsBulkRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamAddEmailsBulkRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamAddEmailsBulk', request)

export const teamsTeamAddEmailsBulkRpcPromise = (request: TeamsTeamAddEmailsBulkRpcParam): Promise<TeamsTeamAddEmailsBulkResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamAddEmailsBulk', request, (error: RPCError, result: TeamsTeamAddEmailsBulkResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamAddMemberRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamAddMemberRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamAddMember', request)

export const teamsTeamAddMemberRpcPromise = (request: TeamsTeamAddMemberRpcParam): Promise<TeamsTeamAddMemberResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamAddMember', request, (error: RPCError, result: TeamsTeamAddMemberResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamApplication = {
  kbfs: 1,
  chat: 2,
  saltpack: 3,
  gitMetadata: 4,
  seitanInviteToken: 5,
}

export const teamsTeamChangeMembershipRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamChangeMembershipRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamChangeMembership', request)

export const teamsTeamChangeMembershipRpcPromise = (request: TeamsTeamChangeMembershipRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamChangeMembership', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamCreateRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamCreateRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamCreate', request)

export const teamsTeamCreateRpcPromise = (request: TeamsTeamCreateRpcParam): Promise<TeamsTeamCreateResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamCreate', request, (error: RPCError, result: TeamsTeamCreateResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamCreateSeitanTokenRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamCreateSeitanTokenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamCreateSeitanToken', request)

export const teamsTeamCreateSeitanTokenRpcPromise = (request: TeamsTeamCreateSeitanTokenRpcParam): Promise<TeamsTeamCreateSeitanTokenResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamCreateSeitanToken', request, (error: RPCError, result: TeamsTeamCreateSeitanTokenResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamCreateSeitanTokenV2RpcChannelMap = (configKeys: Array<string>, request: TeamsTeamCreateSeitanTokenV2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamCreateSeitanTokenV2', request)

export const teamsTeamCreateSeitanTokenV2RpcPromise = (request: TeamsTeamCreateSeitanTokenV2RpcParam): Promise<TeamsTeamCreateSeitanTokenV2Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamCreateSeitanTokenV2', request, (error: RPCError, result: TeamsTeamCreateSeitanTokenV2Result) => (error ? reject(error) : resolve(result))))

export const teamsTeamCreateWithSettingsRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamCreateWithSettingsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamCreateWithSettings', request)

export const teamsTeamCreateWithSettingsRpcPromise = (request: TeamsTeamCreateWithSettingsRpcParam): Promise<TeamsTeamCreateWithSettingsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamCreateWithSettings', request, (error: RPCError, result: TeamsTeamCreateWithSettingsResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamDebugRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamDebugRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamDebug', request)

export const teamsTeamDebugRpcPromise = (request: TeamsTeamDebugRpcParam): Promise<TeamsTeamDebugResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamDebug', request, (error: RPCError, result: TeamsTeamDebugResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamDeleteRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamDeleteRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamDelete', request)

export const teamsTeamDeleteRpcPromise = (request: TeamsTeamDeleteRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamDelete', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamEditMemberRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamEditMemberRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamEditMember', request)

export const teamsTeamEditMemberRpcPromise = (request: TeamsTeamEditMemberRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamEditMember', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamGetRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamGetRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamGet', request)

export const teamsTeamGetRpcPromise = (request: TeamsTeamGetRpcParam): Promise<TeamsTeamGetResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamGet', request, (error: RPCError, result: TeamsTeamGetResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamIgnoreRequestRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamIgnoreRequestRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamIgnoreRequest', request)

export const teamsTeamIgnoreRequestRpcPromise = (request: TeamsTeamIgnoreRequestRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamIgnoreRequest', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamImplicitAdminsRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamImplicitAdminsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamImplicitAdmins', request)

export const teamsTeamImplicitAdminsRpcPromise = (request: TeamsTeamImplicitAdminsRpcParam): Promise<TeamsTeamImplicitAdminsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamImplicitAdmins', request, (error: RPCError, result: TeamsTeamImplicitAdminsResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamInviteCategory = {
  none: 0,
  unknown: 1,
  keybase: 2,
  email: 3,
  sbs: 4,
  seitan: 5,
}

export const teamsTeamLeaveRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamLeaveRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamLeave', request)

export const teamsTeamLeaveRpcPromise = (request: TeamsTeamLeaveRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamLeave', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamListMyAccessRequestsRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamListMyAccessRequestsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamListMyAccessRequests', request)

export const teamsTeamListMyAccessRequestsRpcPromise = (request: TeamsTeamListMyAccessRequestsRpcParam): Promise<TeamsTeamListMyAccessRequestsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamListMyAccessRequests', request, (error: RPCError, result: TeamsTeamListMyAccessRequestsResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamListRequestsRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamListRequestsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamListRequests', request)

export const teamsTeamListRequestsRpcPromise = (request: TeamsTeamListRequestsRpcParam): Promise<TeamsTeamListRequestsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamListRequests', request, (error: RPCError, result: TeamsTeamListRequestsResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamListSubteamsRecursiveRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamListSubteamsRecursiveRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamListSubteamsRecursive', request)

export const teamsTeamListSubteamsRecursiveRpcPromise = (request: TeamsTeamListSubteamsRecursiveRpcParam): Promise<TeamsTeamListSubteamsRecursiveResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamListSubteamsRecursive', request, (error: RPCError, result: TeamsTeamListSubteamsRecursiveResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamListTeammatesRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamListTeammatesRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamListTeammates', request)

export const teamsTeamListTeammatesRpcPromise = (request: TeamsTeamListTeammatesRpcParam): Promise<TeamsTeamListTeammatesResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamListTeammates', request, (error: RPCError, result: TeamsTeamListTeammatesResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamListUnverifiedRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamListUnverifiedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamListUnverified', request)

export const teamsTeamListUnverifiedRpcPromise = (request: TeamsTeamListUnverifiedRpcParam): Promise<TeamsTeamListUnverifiedResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamListUnverified', request, (error: RPCError, result: TeamsTeamListUnverifiedResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamListVerifiedRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamListVerifiedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamListVerified', request)

export const teamsTeamListVerifiedRpcPromise = (request: TeamsTeamListVerifiedRpcParam): Promise<TeamsTeamListVerifiedResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamListVerified', request, (error: RPCError, result: TeamsTeamListVerifiedResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamReAddMemberAfterResetRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamReAddMemberAfterResetRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamReAddMemberAfterReset', request)

export const teamsTeamReAddMemberAfterResetRpcPromise = (request: TeamsTeamReAddMemberAfterResetRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamReAddMemberAfterReset', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamRemoveMemberRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamRemoveMemberRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamRemoveMember', request)

export const teamsTeamRemoveMemberRpcPromise = (request: TeamsTeamRemoveMemberRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamRemoveMember', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamRenameRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamRenameRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamRename', request)

export const teamsTeamRenameRpcPromise = (request: TeamsTeamRenameRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamRename', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamRequestAccessRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamRequestAccessRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamRequestAccess', request)

export const teamsTeamRequestAccessRpcPromise = (request: TeamsTeamRequestAccessRpcParam): Promise<TeamsTeamRequestAccessResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamRequestAccess', request, (error: RPCError, result: TeamsTeamRequestAccessResult) => (error ? reject(error) : resolve(result))))

export const teamsTeamRole = {
  none: 0,
  reader: 1,
  writer: 2,
  admin: 3,
  owner: 4,
}

export const teamsTeamRotateKeyRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamRotateKeyRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamRotateKey', request)

export const teamsTeamRotateKeyRpcPromise = (request: TeamsTeamRotateKeyRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamRotateKey', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamSetSettingsRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamSetSettingsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamSetSettings', request)

export const teamsTeamSetSettingsRpcPromise = (request: TeamsTeamSetSettingsRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamSetSettings', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const teamsTeamTreeRpcChannelMap = (configKeys: Array<string>, request: TeamsTeamTreeRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.teams.teamTree', request)

export const teamsTeamTreeRpcPromise = (request: TeamsTeamTreeRpcParam): Promise<TeamsTeamTreeResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.teams.teamTree', request, (error: RPCError, result: TeamsTeamTreeResult) => (error ? reject(error) : resolve(result))))

export const testPanicRpcChannelMap = (configKeys: Array<string>, request: TestPanicRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.test.panic', request)

export const testPanicRpcPromise = (request: TestPanicRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.test.panic', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const testTestCallbackRpcChannelMap = (configKeys: Array<string>, request: TestTestCallbackRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.test.testCallback', request)

export const testTestCallbackRpcPromise = (request: TestTestCallbackRpcParam): Promise<TestTestCallbackResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.test.testCallback', request, (error: RPCError, result: TestTestCallbackResult) => (error ? reject(error) : resolve(result))))

export const testTestRpcChannelMap = (configKeys: Array<string>, request: TestTestRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.test.test', request)

export const testTestRpcPromise = (request: TestTestRpcParam): Promise<TestTestResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.test.test', request, (error: RPCError, result: TestTestResult) => (error ? reject(error) : resolve(result))))

export const tlfCompleteAndCanonicalizePrivateTlfNameRpcChannelMap = (configKeys: Array<string>, request: TlfCompleteAndCanonicalizePrivateTlfNameRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.tlf.completeAndCanonicalizePrivateTlfName', request)

export const tlfCompleteAndCanonicalizePrivateTlfNameRpcPromise = (request: TlfCompleteAndCanonicalizePrivateTlfNameRpcParam): Promise<TlfCompleteAndCanonicalizePrivateTlfNameResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.tlf.completeAndCanonicalizePrivateTlfName', request, (error: RPCError, result: TlfCompleteAndCanonicalizePrivateTlfNameResult) => (error ? reject(error) : resolve(result))))

export const tlfCryptKeysRpcChannelMap = (configKeys: Array<string>, request: TlfCryptKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.tlf.CryptKeys', request)

export const tlfCryptKeysRpcPromise = (request: TlfCryptKeysRpcParam): Promise<TlfCryptKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.tlf.CryptKeys', request, (error: RPCError, result: TlfCryptKeysResult) => (error ? reject(error) : resolve(result))))

export const tlfKeysGetPublicCanonicalTLFNameAndIDRpcChannelMap = (configKeys: Array<string>, request: TlfKeysGetPublicCanonicalTLFNameAndIDRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.tlfKeys.getPublicCanonicalTLFNameAndID', request)

export const tlfKeysGetPublicCanonicalTLFNameAndIDRpcPromise = (request: TlfKeysGetPublicCanonicalTLFNameAndIDRpcParam): Promise<TlfKeysGetPublicCanonicalTLFNameAndIDResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.tlfKeys.getPublicCanonicalTLFNameAndID', request, (error: RPCError, result: TlfKeysGetPublicCanonicalTLFNameAndIDResult) => (error ? reject(error) : resolve(result))))

export const tlfKeysGetTLFCryptKeysRpcChannelMap = (configKeys: Array<string>, request: TlfKeysGetTLFCryptKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.tlfKeys.getTLFCryptKeys', request)

export const tlfKeysGetTLFCryptKeysRpcPromise = (request: TlfKeysGetTLFCryptKeysRpcParam): Promise<TlfKeysGetTLFCryptKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.tlfKeys.getTLFCryptKeys', request, (error: RPCError, result: TlfKeysGetTLFCryptKeysResult) => (error ? reject(error) : resolve(result))))

export const tlfKeysTLFIdentifyBehavior = {
  unset: 0,
  chatCli: 1,
  chatGui: 2,
  chatGuiStrict: 3,
  kbfsRekey: 4,
  kbfsQr: 5,
  chatSkip: 6,
  saltpack: 7,
  cli: 8,
  gui: 9,
  defaultKbfs: 10,
}

export const tlfPublicCanonicalTLFNameAndIDRpcChannelMap = (configKeys: Array<string>, request: TlfPublicCanonicalTLFNameAndIDRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.tlf.publicCanonicalTLFNameAndID', request)

export const tlfPublicCanonicalTLFNameAndIDRpcPromise = (request: TlfPublicCanonicalTLFNameAndIDRpcParam): Promise<TlfPublicCanonicalTLFNameAndIDResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.tlf.publicCanonicalTLFNameAndID', request, (error: RPCError, result: TlfPublicCanonicalTLFNameAndIDResult) => (error ? reject(error) : resolve(result))))

export const trackCheckTrackingRpcChannelMap = (configKeys: Array<string>, request: TrackCheckTrackingRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.track.checkTracking', request)

export const trackCheckTrackingRpcPromise = (request: TrackCheckTrackingRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.track.checkTracking', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const trackDismissWithTokenRpcChannelMap = (configKeys: Array<string>, request: TrackDismissWithTokenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.track.dismissWithToken', request)

export const trackDismissWithTokenRpcPromise = (request: TrackDismissWithTokenRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.track.dismissWithToken', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const trackFakeTrackingChangedRpcChannelMap = (configKeys: Array<string>, request: TrackFakeTrackingChangedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.track.fakeTrackingChanged', request)

export const trackFakeTrackingChangedRpcPromise = (request: TrackFakeTrackingChangedRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.track.fakeTrackingChanged', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const trackTrackRpcChannelMap = (configKeys: Array<string>, request: TrackTrackRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.track.track', request)

export const trackTrackRpcPromise = (request: TrackTrackRpcParam): Promise<TrackTrackResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.track.track', request, (error: RPCError, result: TrackTrackResult) => (error ? reject(error) : resolve(result))))

export const trackTrackWithTokenRpcChannelMap = (configKeys: Array<string>, request: TrackTrackWithTokenRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.track.trackWithToken', request)

export const trackTrackWithTokenRpcPromise = (request: TrackTrackWithTokenRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.track.trackWithToken', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const trackUntrackRpcChannelMap = (configKeys: Array<string>, request: TrackUntrackRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.track.untrack', request)

export const trackUntrackRpcPromise = (request: TrackUntrackRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.track.untrack', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const uPKKeyType = {
  none: 0,
  nacl: 1,
  pgp: 2,
}

export const uPKUPAKVersion = {
  v1: 1,
  v2: 2,
}

export const uPKUPK2MinorVersion = {
  v0: 0,
  v1: 1,
  v2: 2,
  v3: 3,
  v4: 4,
  v5: 5,
  v6: 6,
}

export const uiPromptDefault = {
  none: 0,
  yes: 1,
  no: 2,
}

export const userGetUPAKRpcChannelMap = (configKeys: Array<string>, request: UserGetUPAKRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.getUPAK', request)

export const userGetUPAKRpcPromise = (request: UserGetUPAKRpcParam): Promise<UserGetUPAKResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.getUPAK', request, (error: RPCError, result: UserGetUPAKResult) => (error ? reject(error) : resolve(result))))

export const userInterestingPeopleRpcChannelMap = (configKeys: Array<string>, request: UserInterestingPeopleRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.interestingPeople', request)

export const userInterestingPeopleRpcPromise = (request: UserInterestingPeopleRpcParam): Promise<UserInterestingPeopleResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.interestingPeople', request, (error: RPCError, result: UserInterestingPeopleResult) => (error ? reject(error) : resolve(result))))

export const userListTrackers2RpcChannelMap = (configKeys: Array<string>, request: UserListTrackers2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.listTrackers2', request)

export const userListTrackers2RpcPromise = (request: UserListTrackers2RpcParam): Promise<UserListTrackers2Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.listTrackers2', request, (error: RPCError, result: UserListTrackers2Result) => (error ? reject(error) : resolve(result))))

export const userListTrackersByNameRpcChannelMap = (configKeys: Array<string>, request: UserListTrackersByNameRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.listTrackersByName', request)

export const userListTrackersByNameRpcPromise = (request: UserListTrackersByNameRpcParam): Promise<UserListTrackersByNameResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.listTrackersByName', request, (error: RPCError, result: UserListTrackersByNameResult) => (error ? reject(error) : resolve(result))))

export const userListTrackersRpcChannelMap = (configKeys: Array<string>, request: UserListTrackersRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.listTrackers', request)

export const userListTrackersRpcPromise = (request: UserListTrackersRpcParam): Promise<UserListTrackersResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.listTrackers', request, (error: RPCError, result: UserListTrackersResult) => (error ? reject(error) : resolve(result))))

export const userListTrackersSelfRpcChannelMap = (configKeys: Array<string>, request: UserListTrackersSelfRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.listTrackersSelf', request)

export const userListTrackersSelfRpcPromise = (request: UserListTrackersSelfRpcParam): Promise<UserListTrackersSelfResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.listTrackersSelf', request, (error: RPCError, result: UserListTrackersSelfResult) => (error ? reject(error) : resolve(result))))

export const userListTrackingJSONRpcChannelMap = (configKeys: Array<string>, request: UserListTrackingJSONRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.listTrackingJSON', request)

export const userListTrackingJSONRpcPromise = (request: UserListTrackingJSONRpcParam): Promise<UserListTrackingJSONResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.listTrackingJSON', request, (error: RPCError, result: UserListTrackingJSONResult) => (error ? reject(error) : resolve(result))))

export const userListTrackingRpcChannelMap = (configKeys: Array<string>, request: UserListTrackingRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.listTracking', request)

export const userListTrackingRpcPromise = (request: UserListTrackingRpcParam): Promise<UserListTrackingResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.listTracking', request, (error: RPCError, result: UserListTrackingResult) => (error ? reject(error) : resolve(result))))

export const userLoadAllPublicKeysUnverifiedRpcChannelMap = (configKeys: Array<string>, request: UserLoadAllPublicKeysUnverifiedRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadAllPublicKeysUnverified', request)

export const userLoadAllPublicKeysUnverifiedRpcPromise = (request: UserLoadAllPublicKeysUnverifiedRpcParam): Promise<UserLoadAllPublicKeysUnverifiedResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadAllPublicKeysUnverified', request, (error: RPCError, result: UserLoadAllPublicKeysUnverifiedResult) => (error ? reject(error) : resolve(result))))

export const userLoadMyPublicKeysRpcChannelMap = (configKeys: Array<string>, request: UserLoadMyPublicKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadMyPublicKeys', request)

export const userLoadMyPublicKeysRpcPromise = (request: UserLoadMyPublicKeysRpcParam): Promise<UserLoadMyPublicKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadMyPublicKeys', request, (error: RPCError, result: UserLoadMyPublicKeysResult) => (error ? reject(error) : resolve(result))))

export const userLoadMySettingsRpcChannelMap = (configKeys: Array<string>, request: UserLoadMySettingsRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadMySettings', request)

export const userLoadMySettingsRpcPromise = (request: UserLoadMySettingsRpcParam): Promise<UserLoadMySettingsResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadMySettings', request, (error: RPCError, result: UserLoadMySettingsResult) => (error ? reject(error) : resolve(result))))

export const userLoadPublicKeysRpcChannelMap = (configKeys: Array<string>, request: UserLoadPublicKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadPublicKeys', request)

export const userLoadPublicKeysRpcPromise = (request: UserLoadPublicKeysRpcParam): Promise<UserLoadPublicKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadPublicKeys', request, (error: RPCError, result: UserLoadPublicKeysResult) => (error ? reject(error) : resolve(result))))

export const userLoadUncheckedUserSummariesRpcChannelMap = (configKeys: Array<string>, request: UserLoadUncheckedUserSummariesRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadUncheckedUserSummaries', request)

export const userLoadUncheckedUserSummariesRpcPromise = (request: UserLoadUncheckedUserSummariesRpcParam): Promise<UserLoadUncheckedUserSummariesResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadUncheckedUserSummaries', request, (error: RPCError, result: UserLoadUncheckedUserSummariesResult) => (error ? reject(error) : resolve(result))))

export const userLoadUserByNameRpcChannelMap = (configKeys: Array<string>, request: UserLoadUserByNameRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadUserByName', request)

export const userLoadUserByNameRpcPromise = (request: UserLoadUserByNameRpcParam): Promise<UserLoadUserByNameResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadUserByName', request, (error: RPCError, result: UserLoadUserByNameResult) => (error ? reject(error) : resolve(result))))

export const userLoadUserPlusKeysRpcChannelMap = (configKeys: Array<string>, request: UserLoadUserPlusKeysRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadUserPlusKeys', request)

export const userLoadUserPlusKeysRpcPromise = (request: UserLoadUserPlusKeysRpcParam): Promise<UserLoadUserPlusKeysResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadUserPlusKeys', request, (error: RPCError, result: UserLoadUserPlusKeysResult) => (error ? reject(error) : resolve(result))))

export const userLoadUserPlusKeysV2RpcChannelMap = (configKeys: Array<string>, request: UserLoadUserPlusKeysV2RpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadUserPlusKeysV2', request)

export const userLoadUserPlusKeysV2RpcPromise = (request: UserLoadUserPlusKeysV2RpcParam): Promise<UserLoadUserPlusKeysV2Result> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadUserPlusKeysV2', request, (error: RPCError, result: UserLoadUserPlusKeysV2Result) => (error ? reject(error) : resolve(result))))

export const userLoadUserRpcChannelMap = (configKeys: Array<string>, request: UserLoadUserRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.loadUser', request)

export const userLoadUserRpcPromise = (request: UserLoadUserRpcParam): Promise<UserLoadUserResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.loadUser', request, (error: RPCError, result: UserLoadUserResult) => (error ? reject(error) : resolve(result))))

export const userMeUserVersionRpcChannelMap = (configKeys: Array<string>, request: UserMeUserVersionRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.meUserVersion', request)

export const userMeUserVersionRpcPromise = (request: UserMeUserVersionRpcParam): Promise<UserMeUserVersionResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.meUserVersion', request, (error: RPCError, result: UserMeUserVersionResult) => (error ? reject(error) : resolve(result))))

export const userProfileEditRpcChannelMap = (configKeys: Array<string>, request: UserProfileEditRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.profileEdit', request)

export const userProfileEditRpcPromise = (request: UserProfileEditRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.profileEdit', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const userResetUserRpcChannelMap = (configKeys: Array<string>, request: UserResetUserRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.resetUser', request)

export const userResetUserRpcPromise = (request: UserResetUserRpcParam): Promise<void> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.resetUser', request, (error: RPCError, result: void) => (error ? reject(error) : resolve())))

export const userSearchRpcChannelMap = (configKeys: Array<string>, request: UserSearchRpcParam): EngineChannel => engine()._channelMapRpcHelper(configKeys, 'keybase.1.user.search', request)

export const userSearchRpcPromise = (request: UserSearchRpcParam): Promise<UserSearchResult> => new Promise((resolve, reject) => engine()._rpcOutgoing('keybase.1.user.search', request, (error: RPCError, result: UserSearchResult) => (error ? reject(error) : resolve(result))))

export type APIRes = $ReadOnly<{status: String, body: String, httpStatus: Int, appStatus: String}>

export type AccountEmailChangeRpcParam = $ReadOnly<{newEmail: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AccountHasServerKeysRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AccountPassphraseChangeRpcParam = $ReadOnly<{oldPassphrase: String, passphrase: String, force: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AccountPassphrasePromptRpcParam = $ReadOnly<{guiArg: GUIEntryArg, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AccountResetAccountRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AnnotatedMemberInfo = $ReadOnly<{userID: UID, teamID: TeamID, username: String, fullName: String, fqName: String, isImplicitTeam: Boolean, isOpenTeam: Boolean, role: TeamRole, implicit?: ?ImplicitRole, needsPUK: Boolean, memberCount: Int, eldestSeqno: Seqno, active: Boolean}>

export type AnnotatedTeamInvite = $ReadOnly<{role: TeamRole, id: TeamInviteID, type: TeamInviteType, name: TeamInviteName, uv: UserVersion, inviter: UserVersion, inviterUsername: String, teamName: String, userActive: Boolean}>

export type AnnotatedTeamList = $ReadOnly<{teams?: ?Array<AnnotatedMemberInfo>, annotatedActiveInvites: {[key: string]: AnnotatedTeamInvite}}>

export type ApiserverDeleteRpcParam = $ReadOnly<{endpoint: String, args?: ?Array<StringKVPair>, httpStatus?: ?Array<Int>, appStatusCode?: ?Array<Int>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ApiserverGetRpcParam = $ReadOnly<{endpoint: String, args?: ?Array<StringKVPair>, httpStatus?: ?Array<Int>, appStatusCode?: ?Array<Int>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ApiserverGetWithSessionRpcParam = $ReadOnly<{endpoint: String, args?: ?Array<StringKVPair>, httpStatus?: ?Array<Int>, appStatusCode?: ?Array<Int>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ApiserverPostJSONRpcParam = $ReadOnly<{endpoint: String, args?: ?Array<StringKVPair>, JSONPayload?: ?Array<StringKVPair>, httpStatus?: ?Array<Int>, appStatusCode?: ?Array<Int>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ApiserverPostRpcParam = $ReadOnly<{endpoint: String, args?: ?Array<StringKVPair>, httpStatus?: ?Array<Int>, appStatusCode?: ?Array<Int>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AppState =
  | 0 // FOREGROUND_0
  | 1 // BACKGROUND_1
  | 2 // INACTIVE_2
  | 3 // BACKGROUNDACTIVE_3

export type AppStateUpdateAppStateRpcParam = $ReadOnly<{state: AppState, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AsyncOps =
  | 0 // LIST_0
  | 1 // LIST_RECURSIVE_1
  | 2 // READ_2
  | 3 // WRITE_3
  | 4 // COPY_4
  | 5 // MOVE_5
  | 6 // REMOVE_6

export type AvatarFormat = String

export type AvatarUrl = String

export type AvatarsLoadTeamAvatarsRpcParam = $ReadOnly<{names?: ?Array<String>, formats?: ?Array<AvatarFormat>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type AvatarsLoadUserAvatarsRpcParam = $ReadOnly<{names?: ?Array<String>, formats?: ?Array<AvatarFormat>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BTCRegisterBTCRpcParam = $ReadOnly<{address: String, force: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BadgeConversationInfo = $ReadOnly<{convID: ChatConversationID, badgeCounts: {[key: string]: Int}, unreadMessages: Int}>

export type BadgeState = $ReadOnly<{newTlfs: Int, rekeysNeeded: Int, newFollowers: Int, inboxVers: Int, homeTodoItems: Int, conversations?: ?Array<BadgeConversationInfo>, newGitRepoGlobalUniqueIDs?: ?Array<String>, newTeamNames?: ?Array<String>, newTeamAccessRequests?: ?Array<String>, teamsWithResetUsers?: ?Array<TeamMemberOutReset>}>

export type BadgerGetBadgeStateRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BinaryKID = Bytes

export type BlockAddReferenceRpcParam = $ReadOnly<{folder: String, ref: BlockReference, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockArchiveReferenceRpcParam = $ReadOnly<{folder: String, refs?: ?Array<BlockReference>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockArchiveReferenceWithCountRpcParam = $ReadOnly<{folder: String, refs?: ?Array<BlockReference>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockAuthenticateSessionRpcParam = $ReadOnly<{signature: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockBlockPingRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockDelReferenceRpcParam = $ReadOnly<{folder: String, ref: BlockReference, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockDelReferenceWithCountRpcParam = $ReadOnly<{folder: String, refs?: ?Array<BlockReference>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockGetBlockRpcParam = $ReadOnly<{bid: BlockIdCombo, folder: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockGetSessionChallengeRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockGetTeamQuotaInfoRpcParam = $ReadOnly<{tid: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockGetUserQuotaInfoRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockIdCombo = $ReadOnly<{blockHash: String, chargedTo: UserOrTeamID, blockType: BlockType}>

export type BlockPingResponse = $ReadOnly<{}>

export type BlockPutBlockAgainRpcParam = $ReadOnly<{folder: String, ref: BlockReference, blockKey: String, buf: Bytes, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockPutBlockRpcParam = $ReadOnly<{bid: BlockIdCombo, folder: String, blockKey: String, buf: Bytes, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type BlockRefNonce = any

export type BlockReference = $ReadOnly<{bid: BlockIdCombo, nonce: BlockRefNonce, chargedTo: UserOrTeamID}>

export type BlockReferenceCount = $ReadOnly<{ref: BlockReference, liveCount: Int}>

export type BlockType =
  | 0 // DATA_0
  | 1 // MD_1
  | 2 // GIT_2

export type BootstrapStatus = $ReadOnly<{registered: Boolean, loggedIn: Boolean, uid: UID, username: String, deviceID: DeviceID, deviceName: String, following?: ?Array<String>, followers?: ?Array<String>}>

export type BoxNonce = any

export type BoxPublicKey = any

export type BulkRes = $ReadOnly<{invited?: ?Array<String>, alreadyInvited?: ?Array<String>, malformed?: ?Array<String>}>

export type Bytes32 = any

export type CanonicalTLFNameAndIDWithBreaks = $ReadOnly<{tlfID: TLFID, CanonicalName: CanonicalTlfName, breaks: TLFBreak}>

export type CanonicalTlfName = String

export type ChallengeInfo = $ReadOnly<{now: Long, challenge: String}>

export type ChatConversationID = Bytes

export type CheckProofStatus = $ReadOnly<{found: Boolean, status: ProofStatus, proofText: String, state: ProofState}>

export type CheckResult = $ReadOnly<{proofResult: ProofResult, time: Time, freshness: CheckResultFreshness}>

export type CheckResultFreshness =
  | 0 // FRESH_0
  | 1 // AGED_1
  | 2 // RANCID_2

export type ChooseType =
  | 0 // EXISTING_DEVICE_0
  | 1 // NEW_DEVICE_1

export type CiphertextBundle = $ReadOnly<{kid: KID, ciphertext: EncryptedBytes32, nonce: BoxNonce, publicKey: BoxPublicKey}>

export type ClientDetails = $ReadOnly<{pid: Int, clientType: ClientType, argv?: ?Array<String>, desc: String, version: String}>

export type ClientType =
  | 0 // NONE_0
  | 1 // CLI_1
  | 2 // GUI_MAIN_2
  | 3 // KBFS_3
  | 4 // GUI_HELPER_4

export type CompatibilityTeamID = {typ: 1, legacy: ?TLFID} | {typ: 2, modern: ?TeamID}

export type ComponentResult = $ReadOnly<{name: String, status: Status, exitCode: Int}>

export type Config = $ReadOnly<{serverURI: String, socketFile: String, label: String, runMode: String, gpgExists: Boolean, gpgPath: String, version: String, path: String, binaryRealpath: String, configPath: String, versionShort: String, versionFull: String, isAutoForked: Boolean, forkType: ForkType}>

export type ConfigCheckAPIServerOutOfDateWarningRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigClearValueRpcParam = $ReadOnly<{path: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigGetBootstrapStatusRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigGetConfigRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigGetCurrentStatusRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigGetExtendedStatusRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigGetRememberPassphraseRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigGetValueRpcParam = $ReadOnly<{path: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigHelloIAmRpcParam = $ReadOnly<{details: ClientDetails, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigSetPathRpcParam = $ReadOnly<{path: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigSetRememberPassphraseRpcParam = $ReadOnly<{remember: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigSetUserConfigRpcParam = $ReadOnly<{username: String, key: String, value: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigSetValueRpcParam = $ReadOnly<{path: String, value: ConfigValue, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfigValue = $ReadOnly<{isNull: Boolean, b?: ?Boolean, i?: ?Int, s?: ?String, o?: ?String}>

export type ConfigWaitForClientRpcParam = $ReadOnly<{clientType: ClientType, timeout: DurationSec, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ConfiguredAccount = $ReadOnly<{username: String, hasStoredSecret: Boolean}>

export type ConfirmResult = $ReadOnly<{identityConfirmed: Boolean, remoteConfirmed: Boolean, expiringLocal: Boolean, autoConfirmed: Boolean}>

export type ConflictGeneration = Int

export type CopyArgs = $ReadOnly<{opID: OpID, src: Path, dest: Path}>

export type CryptKey = $ReadOnly<{KeyGeneration: Int, Key: Bytes32}>

export type CryptoSignED25519ForKBFSRpcParam = $ReadOnly<{msg: Bytes, reason: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CryptoSignED25519RpcParam = $ReadOnly<{msg: Bytes, reason: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CryptoSignToStringRpcParam = $ReadOnly<{msg: Bytes, reason: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CryptoUnboxBytes32AnyRpcParam = $ReadOnly<{bundles?: ?Array<CiphertextBundle>, reason: String, promptPaper: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CryptoUnboxBytes32RpcParam = $ReadOnly<{encryptedBytes32: EncryptedBytes32, nonce: BoxNonce, peersPublicKey: BoxPublicKey, reason: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Cryptocurrency = $ReadOnly<{rowId: Int, pkhash: Bytes, address: String, sigID: SigID, type: String, family: String}>

export type CryptocurrencyRegisterAddressRpcParam = $ReadOnly<{address: String, force: Boolean, wantedFamily: String, sigVersion?: ?SigVersion, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CsrfToken = String

export type CtlAppExitRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlDbDeleteRpcParam = $ReadOnly<{key: DbKey, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlDbGetRpcParam = $ReadOnly<{key: DbKey, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlDbNukeRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlDbPutRpcParam = $ReadOnly<{key: DbKey, value: DbValue, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlLogRotateRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlReloadRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type CtlStopRpcParam = $ReadOnly<{exitCode: ExitCode, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DbKey = $ReadOnly<{dbType: DbType, objType: Int, key: String}>

export type DbType =
  | 0 // MAIN_0
  | 1 // CHAT_1

export type DbValue = Bytes

export type DebuggingFirstStepRpcParam = $ReadOnly<{val: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DebuggingIncrementRpcParam = $ReadOnly<{val: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DebuggingSecondStepRpcParam = $ReadOnly<{val: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DelegateUiCtlRegisterGregorFirehoseRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DelegateUiCtlRegisterHomeUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DelegateUiCtlRegisterIdentifyUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DelegateUiCtlRegisterRekeyUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DelegateUiCtlRegisterSecretUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DelegateUiCtlRegisterUpdateUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Device = $ReadOnly<{type: String, name: String, deviceID: DeviceID, cTime: Time, mTime: Time, lastUsedTime: Time, encryptKey: KID, verifyKey: KID, status: Int}>

export type DeviceCheckDeviceNameForUserRpcParam = $ReadOnly<{username: String, devicename: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DeviceCheckDeviceNameFormatRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DeviceDetail = $ReadOnly<{device: Device, eldest: Boolean, provisioner?: ?Device, provisionedAt?: ?Time, revokedAt?: ?Time, revokedBy: KID, revokedByDevice?: ?Device, currentDevice: Boolean}>

export type DeviceDeviceAddRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DeviceDeviceHistoryListRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DeviceDeviceListRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type DeviceEk = $ReadOnly<{seed: Bytes32, metadata: DeviceEkMetadata}>

export type DeviceEkMetadata = $ReadOnly<{kid: KID, hashMeta: HashMeta, generation: EkGeneration, ctime: Time}>

export type DeviceEkStatement = $ReadOnly<{currentDeviceEkMetadata: DeviceEkMetadata, existingDeviceEkMetadata?: ?Array<DeviceEkMetadata>}>

export type DeviceID = String

export type DeviceType =
  | 0 // DESKTOP_0
  | 1 // MOBILE_1

export type Dirent = $ReadOnly<{time: Time, size: Int, name: String, direntType: DirentType, lastWriterUnverified: User}>

export type DirentType =
  | 0 // FILE_0
  | 1 // DIR_1
  | 2 // SYM_2
  | 3 // EXEC_3

export type DismissReason = $ReadOnly<{type: DismissReasonType, reason: String, resource: String}>

export type DismissReasonType =
  | 0 // NONE_0
  | 1 // HANDLED_ELSEWHERE_1

export type DowngradeReferenceRes = $ReadOnly<{completed?: ?Array<BlockReferenceCount>, failed: BlockReference}>

export type DurationSec = Double

export type ED25519PublicKey = any

export type ED25519Signature = any

export type ED25519SignatureInfo = $ReadOnly<{sig: ED25519Signature, publicKey: ED25519PublicKey}>

export type EkGeneration = Int64

export type Email = $ReadOnly<{email: String, isVerified: Boolean}>

export type EncryptedBytes32 = any

export type EncryptedGitMetadata = $ReadOnly<{v: Int, e: Bytes, n: BoxNonce, gen: PerTeamKeyGeneration}>

export type EncryptedStellarBundle = $ReadOnly<{v: Int, e: Bytes, n: BoxNonce, gen: PerUserKeyGeneration}>

export type ErrorNum = Int

export type ExitCode =
  | 0 // OK_0
  | 2 // NOTOK_2
  | 4 // RESTART_4

export type ExtendedStatus = $ReadOnly<{standalone: Boolean, passphraseStreamCached: Boolean, tsecCached: Boolean, deviceSigKeyCached: Boolean, deviceEncKeyCached: Boolean, paperSigKeyCached: Boolean, paperEncKeyCached: Boolean, storedSecret: Boolean, secretPromptSkip: Boolean, rememberPassphrase: Boolean, device?: ?Device, deviceErr?: ?LoadDeviceErr, logDir: String, session?: ?SessionStatus, defaultUsername: String, provisionedUsernames?: ?Array<String>, Clients?: ?Array<ClientDetails>, platformInfo: PlatformInfo, defaultDeviceID: DeviceID}>

export type FSEditListRequest = $ReadOnly<{folder: Folder, requestID: Int}>

export type FSErrorType =
  | 0 // ACCESS_DENIED_0
  | 1 // USER_NOT_FOUND_1
  | 2 // REVOKED_DATA_DETECTED_2
  | 3 // NOT_LOGGED_IN_3
  | 4 // TIMEOUT_4
  | 5 // REKEY_NEEDED_5
  | 6 // BAD_FOLDER_6
  | 7 // NOT_IMPLEMENTED_7
  | 8 // OLD_VERSION_8
  | 9 // OVER_QUOTA_9
  | 10 // NO_SIG_CHAIN_10
  | 11 // TOO_MANY_FOLDERS_11
  | 12 // EXDEV_NOT_SUPPORTED_12
  | 13 // DISK_LIMIT_REACHED_13
  | 14 // DISK_CACHE_ERROR_LOG_SEND_14

export type FSNotification = $ReadOnly<{filename: String, status: String, statusCode: FSStatusCode, notificationType: FSNotificationType, errorType: FSErrorType, params: {[key: string]: String}, writerUid: UID, localTime: Time, folderType: FolderType}>

export type FSNotificationType =
  | 0 // ENCRYPTING_0
  | 1 // DECRYPTING_1
  | 2 // SIGNING_2
  | 3 // VERIFYING_3
  | 4 // REKEYING_4
  | 5 // CONNECTION_5
  | 6 // MD_READ_SUCCESS_6
  | 7 // FILE_CREATED_7
  | 8 // FILE_MODIFIED_8
  | 9 // FILE_DELETED_9
  | 10 // FILE_RENAMED_10
  | 11 // INITIALIZED_11

export type FSPathSyncStatus = $ReadOnly<{folderType: FolderType, path: String, syncingBytes: Int64, syncingOps: Int64, syncedBytes: Int64}>

export type FSStatusCode =
  | 0 // START_0
  | 1 // FINISH_1
  | 2 // ERROR_2

export type FSSyncStatus = $ReadOnly<{totalSyncingBytes: Int64, totalSyncingOps: Int64, pathStatuses?: ?Array<FSPathSyncStatus>}>

export type FSSyncStatusRequest = $ReadOnly<{requestID: Int}>

export type FavoriteFavoriteAddRpcParam = $ReadOnly<{folder: Folder, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type FavoriteFavoriteIgnoreRpcParam = $ReadOnly<{folder: Folder, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type FavoriteGetFavoritesRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type FavoritesResult = $ReadOnly<{favoriteFolders?: ?Array<Folder>, ignoredFolders?: ?Array<Folder>, newFolders?: ?Array<Folder>}>

export type Feature = $ReadOnly<{allow: Boolean, defaultValue: Boolean, readonly: Boolean, label: String}>

export type File = $ReadOnly<{path: String}>

export type FileContent = $ReadOnly<{data: Bytes, progress: Progress}>

export type FileDescriptor = $ReadOnly<{name: String, type: FileType}>

export type FileType =
  | 0 // UNKNOWN_0
  | 1 // DIRECTORY_1
  | 2 // FILE_2

export type FirstStepResult = $ReadOnly<{valPlusTwo: Int}>

export type Folder = $ReadOnly<{name: String, private: Boolean, notificationsOn: Boolean, created: Boolean, folderType: FolderType}>

export type FolderType =
  | 0 // UNKNOWN_0
  | 1 // PRIVATE_1
  | 2 // PUBLIC_2
  | 3 // TEAM_3

export type ForkType =
  | 0 // NONE_0
  | 1 // AUTO_1
  | 2 // WATCHDOG_2
  | 3 // LAUNCHD_3
  | 4 // SYSTEMD_4

export type FsListRpcParam = $ReadOnly<{path: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type FullName = String

export type FullNamePackage = $ReadOnly<{version: FullNamePackageVersion, fullName: FullName, eldestSeqno: Seqno, cachedAt: Time}>

export type FullNamePackageVersion =
  | 0 // V0_0
  | 1 // V1_1

export type FuseMountInfo = $ReadOnly<{path: String, fstype: String, output: String}>

export type FuseStatus = $ReadOnly<{version: String, bundleVersion: String, kextID: String, path: String, kextStarted: Boolean, installStatus: InstallStatus, installAction: InstallAction, mountInfos?: ?Array<FuseMountInfo>, status: Status}>

export type GPGKey = $ReadOnly<{algorithm: String, keyID: String, creation: String, expiration: String, identities?: ?Array<PGPIdentity>}>

export type GPGMethod =
  | 0 // GPG_NONE_0
  | 1 // GPG_IMPORT_1
  | 2 // GPG_SIGN_2

export type GUIEntryArg = $ReadOnly<{windowTitle: String, prompt: String, username: String, submitLabel: String, cancelLabel: String, retryLabel: String, type: PassphraseType, features: GUIEntryFeatures}>

export type GUIEntryFeatures = $ReadOnly<{showTyping: Feature}>

export type GcOptions = $ReadOnly<{maxLooseRefs: Int, pruneMinLooseObjects: Int, pruneExpireTime: Time}>

export type GetBlockRes = $ReadOnly<{blockKey: String, buf: Bytes}>

export type GetCurrentStatusRes = $ReadOnly<{configured: Boolean, registered: Boolean, loggedIn: Boolean, sessionIsValid: Boolean, user?: ?User}>

export type GetPassphraseRes = $ReadOnly<{passphrase: String, storeSecret: Boolean}>

export type GetTLFCryptKeysRes = $ReadOnly<{nameIDBreaks: CanonicalTLFNameAndIDWithBreaks, CryptKeys?: ?Array<CryptKey>}>

export type GitCommit = $ReadOnly<{commitHash: String, message: String, authorName: String, authorEmail: String, ctime: Time}>

export type GitCreatePersonalRepoRpcParam = $ReadOnly<{repoName: GitRepoName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitCreateTeamRepoRpcParam = $ReadOnly<{repoName: GitRepoName, teamName: TeamName, notifyTeam: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitDeleteGitMetadataRpcParam = $ReadOnly<{folder: Folder, repoName: GitRepoName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitDeletePersonalRepoRpcParam = $ReadOnly<{repoName: GitRepoName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitDeleteTeamRepoRpcParam = $ReadOnly<{repoName: GitRepoName, teamName: TeamName, notifyTeam: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitGcPersonalRepoRpcParam = $ReadOnly<{repoName: GitRepoName, force: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitGcTeamRepoRpcParam = $ReadOnly<{repoName: GitRepoName, teamName: TeamName, force: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitGetAllGitMetadataRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitGetGitMetadataRpcParam = $ReadOnly<{folder: Folder, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitGetTeamRepoSettingsRpcParam = $ReadOnly<{folder: Folder, repoID: RepoID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitLocalMetadata = $ReadOnly<{repoName: GitRepoName, refs?: ?Array<GitRefMetadata>, pushType: GitPushType, previousRepoName: GitRepoName}>

export type GitLocalMetadataV1 = $ReadOnly<{repoName: GitRepoName}>

export type GitLocalMetadataVersion = 1 // V1_1

export type GitLocalMetadataVersioned = {version: 1, v1: ?GitLocalMetadataV1}

export type GitPushType =
  | 0 // DEFAULT_0
  | 1 // CREATEREPO_1
  | 3 // RENAMEREPO_3

export type GitPutGitMetadataRpcParam = $ReadOnly<{folder: Folder, repoID: RepoID, metadata: GitLocalMetadata, notifyTeam: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitRefMetadata = $ReadOnly<{refName: String, commits?: ?Array<GitCommit>, moreCommitsAvailable: Boolean, isDelete: Boolean}>

export type GitRepoInfo = $ReadOnly<{folder: Folder, repoID: RepoID, localMetadata: GitLocalMetadata, serverMetadata: GitServerMetadata, repoUrl: String, globalUniqueID: String, canDelete: Boolean, teamRepoSettings?: ?GitTeamRepoSettings}>

export type GitRepoName = String

export type GitRepoResult = {state: 0, err: ?String} | {state: 1, ok: ?GitRepoInfo}

export type GitRepoResultState =
  | 0 // ERR_0
  | 1 // OK_1

export type GitServerMetadata = $ReadOnly<{ctime: Time, mtime: Time, lastModifyingUsername: String, lastModifyingDeviceID: DeviceID, lastModifyingDeviceName: String}>

export type GitSetTeamRepoSettingsRpcParam = $ReadOnly<{folder: Folder, repoID: RepoID, channelName?: ?String, chatDisabled: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GitTeamRepoSettings = $ReadOnly<{channelName?: ?String, chatDisabled: Boolean}>

export type GpgUiConfirmDuplicateKeyChosenRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GpgUiGetTTYRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GpgUiSelectKeyAndPushOptionRpcParam = $ReadOnly<{keys?: ?Array<GPGKey>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GpgUiSelectKeyRpcParam = $ReadOnly<{keys?: ?Array<GPGKey>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GpgUiSignRpcParam = $ReadOnly<{msg: Bytes, fingerprint: Bytes, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GpgUiWantToAddGPGKeyRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GregorDismissCategoryRpcParam = $ReadOnly<{category: Gregor1.Category, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GregorDismissItemRpcParam = $ReadOnly<{id: Gregor1.MsgID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GregorGetStateRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GregorInjectItemRpcParam = $ReadOnly<{cat: String, body: String, dtime: Gregor1.TimeOrOffset, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GregorUIPushOutOfBandMessagesRpcParam = $ReadOnly<{oobm?: ?Array<Gregor1.OutOfBandMessage>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type GregorUIPushStateRpcParam = $ReadOnly<{state: Gregor1.State, reason: PushReason, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type HasServerKeysRes = $ReadOnly<{hasServerKeys: Boolean}>

export type Hash = Bytes

export type HashMeta = Bytes

export type Hello2Res = $ReadOnly<{encryptionKey: KID, sigPayload: HelloRes}>

export type HelloRes = String

export type HomeHomeActionTakenRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type HomeHomeGetScreenRpcParam = $ReadOnly<{markViewed: Boolean, numFollowSuggestionsWanted: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type HomeHomeMarkViewedRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type HomeHomeSkipTodoTypeRpcParam = $ReadOnly<{t: HomeScreenTodoType, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type HomeScreen = $ReadOnly<{lastViewed: Time, version: Int, visits: Int, items?: ?Array<HomeScreenItem>, followSuggestions?: ?Array<HomeUserSummary>}>

export type HomeScreenItem = $ReadOnly<{badged: Boolean, data: HomeScreenItemData}>

export type HomeScreenItemData = {t: 1, todo: ?HomeScreenTodo} | {t: 2, people: ?HomeScreenPeopleNotification}

export type HomeScreenItemID = String

export type HomeScreenItemType =
  | 1 // TODO_1
  | 2 // PEOPLE_2

export type HomeScreenPeopleNotification = {t: 1, followed: ?HomeScreenPeopleNotificationFollowed} | {t: 2, followedMulti: ?HomeScreenPeopleNotificationFollowedMulti}

export type HomeScreenPeopleNotificationFollowed = $ReadOnly<{followTime: Time, followedBack: Boolean, user: UserSummary}>

export type HomeScreenPeopleNotificationFollowedMulti = $ReadOnly<{followers?: ?Array<HomeScreenPeopleNotificationFollowed>, numOthers: Int}>

export type HomeScreenPeopleNotificationType =
  | 1 // FOLLOWED_1
  | 2 // FOLLOWED_MULTI_2

export type HomeScreenTodo = {t: any}

export type HomeScreenTodoType =
  | 0 // NONE_0
  | 1 // BIO_1
  | 2 // PROOF_2
  | 3 // DEVICE_3
  | 4 // FOLLOW_4
  | 5 // CHAT_5
  | 6 // PAPERKEY_6
  | 7 // TEAM_7
  | 8 // FOLDER_8
  | 9 // GIT_REPO_9
  | 10 // TEAM_SHOWCASE_10

export type HomeUIHomeUIRefreshRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type HomeUserSummary = $ReadOnly<{uid: UID, username: String, bio: String, fullName: String, pics?: ?Pics}>

export type Identify2Res = $ReadOnly<{upk: UserPlusKeys, identifiedAt: Time, trackBreaks?: ?IdentifyTrackBreaks}>

export type IdentifyIdentify2RpcParam = $ReadOnly<{uid: UID, userAssertion: String, reason: IdentifyReason, useDelegateUI?: Boolean, alwaysBlock?: Boolean, noErrorOnTrackFailure?: Boolean, forceRemoteCheck?: Boolean, needProofSet?: Boolean, allowEmptySelfID?: Boolean, noSkipSelf?: Boolean, canSuppressUI?: Boolean, identifyBehavior?: TLFIdentifyBehavior, forceDisplay?: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyIdentifyLiteRpcParam = $ReadOnly<{id: UserOrTeamID, assertion: String, reason: IdentifyReason, useDelegateUI?: Boolean, alwaysBlock?: Boolean, noErrorOnTrackFailure?: Boolean, forceRemoteCheck?: Boolean, needProofSet?: Boolean, allowEmptySelfID?: Boolean, noSkipSelf?: Boolean, canSuppressUI?: Boolean, identifyBehavior?: TLFIdentifyBehavior, forceDisplay?: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyKey = $ReadOnly<{pgpFingerprint: Bytes, KID: KID, trackDiff?: ?TrackDiff, breaksTracking: Boolean}>

export type IdentifyLiteRes = $ReadOnly<{ul: UserOrTeamLite, trackBreaks?: ?IdentifyTrackBreaks}>

export type IdentifyOutcome = $ReadOnly<{username: String, status?: ?Status, warnings?: ?Array<String>, trackUsed?: ?TrackSummary, trackStatus: TrackStatus, numTrackFailures: Int, numTrackChanges: Int, numProofFailures: Int, numRevoked: Int, numProofSuccesses: Int, revoked?: ?Array<TrackDiff>, trackOptions: TrackOptions, forPGPPull: Boolean, reason: IdentifyReason}>

export type IdentifyProofBreak = $ReadOnly<{remoteProof: RemoteProof, lcr: LinkCheckResult}>

export type IdentifyReason = $ReadOnly<{type: IdentifyReasonType, reason: String, resource: String}>

export type IdentifyReasonType =
  | 0 // NONE_0
  | 1 // ID_1
  | 2 // TRACK_2
  | 3 // ENCRYPT_3
  | 4 // DECRYPT_4
  | 5 // VERIFY_5
  | 6 // RESOURCE_6
  | 7 // BACKGROUND_7

export type IdentifyResolve3RpcParam = $ReadOnly<{assertion: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyResolveIdentifyImplicitTeamRpcParam = $ReadOnly<{assertions: String, suffix: String, isPublic: Boolean, doIdentifies: Boolean, create: Boolean, reason: IdentifyReason, identifyBehavior: TLFIdentifyBehavior, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyResolveImplicitTeamRpcParam = $ReadOnly<{id: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyRow = $ReadOnly<{rowId: Int, proof: RemoteProof, trackDiff?: ?TrackDiff}>

export type IdentifyTrackBreaks = $ReadOnly<{keys?: ?Array<IdentifyKey>, proofs?: ?Array<IdentifyProofBreak>}>

export type IdentifyUiCancelRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiConfirmRpcParam = $ReadOnly<{outcome: IdentifyOutcome, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDelegateIdentifyUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDismissRpcParam = $ReadOnly<{username: String, reason: DismissReason, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDisplayCryptocurrencyRpcParam = $ReadOnly<{c: Cryptocurrency, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDisplayKeyRpcParam = $ReadOnly<{key: IdentifyKey, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDisplayTLFCreateWithInviteRpcParam = $ReadOnly<{folderName: String, isPrivate: Boolean, assertion: String, socialAssertion: SocialAssertion, inviteLink: String, throttled: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDisplayTrackStatementRpcParam = $ReadOnly<{stmt: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiDisplayUserCardRpcParam = $ReadOnly<{card: UserCard, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiFinishRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiFinishSocialProofCheckRpcParam = $ReadOnly<{rp: RemoteProof, lcr: LinkCheckResult, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiFinishWebProofCheckRpcParam = $ReadOnly<{rp: RemoteProof, lcr: LinkCheckResult, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiLaunchNetworkChecksRpcParam = $ReadOnly<{identity: Identity, user: User, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiReportLastTrackRpcParam = $ReadOnly<{track?: ?TrackSummary, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiReportTrackTokenRpcParam = $ReadOnly<{trackToken: TrackToken, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type IdentifyUiStartRpcParam = $ReadOnly<{username: String, reason: IdentifyReason, forceDisplay?: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Identity = $ReadOnly<{status?: ?Status, whenLastTracked: Time, proofs?: ?Array<IdentifyRow>, cryptocurrency?: ?Array<Cryptocurrency>, revoked?: ?Array<TrackDiff>, revokedDetails?: ?Array<RevokedProof>, breaksTracking: Boolean}>

export type ImplicitRole = $ReadOnly<{role: TeamRole, ancestor: TeamID}>

export type ImplicitTeamConflictInfo = $ReadOnly<{generation: ConflictGeneration, time: Time}>

export type ImplicitTeamDisplayName = $ReadOnly<{isPublic: Boolean, writers: ImplicitTeamUserSet, readers: ImplicitTeamUserSet, conflictInfo?: ?ImplicitTeamConflictInfo}>

export type ImplicitTeamMigrationStartMigrationRpcParam = $ReadOnly<{folder: Folder, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ImplicitTeamUserSet = $ReadOnly<{keybaseUsers?: ?Array<String>, unresolvedUsers?: ?Array<SocialAssertion>}>

export type InstallAction =
  | 0 // UNKNOWN_0
  | 1 // NONE_1
  | 2 // UPGRADE_2
  | 3 // REINSTALL_3
  | 4 // INSTALL_4

export type InstallFuseStatusRpcParam = $ReadOnly<{bundleVersion: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type InstallInstallCommandLinePrivilegedRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type InstallInstallFuseRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type InstallInstallKBFSRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type InstallResult = $ReadOnly<{componentResults?: ?Array<ComponentResult>, status: Status, fatal: Boolean}>

export type InstallStatus =
  | 0 // UNKNOWN_0
  | 1 // ERROR_1
  | 2 // NOT_INSTALLED_2
  | 4 // INSTALLED_4

export type InstallUninstallKBFSRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type InterestingPerson = $ReadOnly<{uid: UID, username: String}>

export type KBFSGitCreateRepoRpcParam = $ReadOnly<{folder: Folder, name: GitRepoName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KBFSGitDeleteRepoRpcParam = $ReadOnly<{folder: Folder, name: GitRepoName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KBFSGitGcRpcParam = $ReadOnly<{folder: Folder, name: GitRepoName, options: GcOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KBFSTeamSettings = $ReadOnly<{tlfID: TLFID}>

export type KID = String

export type KbfsCreateTLFRpcParam = $ReadOnly<{teamID: TeamID, tlfID: TLFID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsFSEditListRpcParam = $ReadOnly<{edits?: ?Array<FSNotification>, requestID: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsFSEventRpcParam = $ReadOnly<{event: FSNotification, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsFSSyncEventRpcParam = $ReadOnly<{event: FSPathSyncStatus, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsFSSyncStatusRpcParam = $ReadOnly<{status: FSSyncStatus, requestID: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsGetKBFSTeamSettingsRpcParam = $ReadOnly<{teamID: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsMountGetAllAvailableMountDirsRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsMountGetCurrentMountDirRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KbfsMountSetCurrentMountDirRpcParam = $ReadOnly<{dir: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Kex2Provisionee2DidCounterSign2RpcParam = $ReadOnly<{sig: Bytes, ppsEncrypted: String, pukBox?: ?PerUserKeyBox, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Kex2Provisionee2Hello2RpcParam = $ReadOnly<{uid: UID, token: SessionToken, csrf: CsrfToken, sigBody: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Kex2ProvisioneeDidCounterSignRpcParam = $ReadOnly<{sig: Bytes, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Kex2ProvisioneeHelloRpcParam = $ReadOnly<{uid: UID, token: SessionToken, csrf: CsrfToken, pps: PassphraseStream, sigBody: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Kex2ProvisionerKexStartRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type KeyBundle = $ReadOnly<{version: Int, bundle: Bytes}>

export type KeyBundleResponse = $ReadOnly<{WriterBundle: KeyBundle, ReaderBundle: KeyBundle}>

export type KeyHalf = $ReadOnly<{user: UID, deviceKID: KID, key: Bytes}>

export type KeyInfo = $ReadOnly<{fingerprint: String, key: String, desc: String}>

export type KeyType =
  | 0 // NONE_0
  | 1 // NACL_1
  | 2 // PGP_2

export type KeybaseTime = $ReadOnly<{unix: Time, chain: Seqno}>

export type LeaseID = String

export type LinkCheckResult = $ReadOnly<{proofId: Int, proofResult: ProofResult, snoozedResult: ProofResult, torWarning: Boolean, tmpTrackExpireTime: Time, cached?: ?CheckResult, diff?: ?TrackDiff, remoteDiff?: ?TrackDiff, hint?: ?SigHint, breaksTracking: Boolean}>

export type LinkID = String

export type ListArgs = $ReadOnly<{opID: OpID, path: Path, filter: ListFilter}>

export type ListFilter =
  | 0 // NO_FILTER_0
  | 1 // FILTER_ALL_HIDDEN_1

export type ListResult = $ReadOnly<{files?: ?Array<File>}>

export type LoadAvatarsRes = $ReadOnly<{picmap: {[key: string]: {[key: string]: AvatarUrl}}}>

export type LoadDeviceErr = $ReadOnly<{where: String, desc: String}>

export type LoadTeamArg = $ReadOnly<{ID: TeamID, name: String, public: Boolean, needAdmin: Boolean, refreshUIDMapper: Boolean, refreshers: TeamRefreshers, forceFullReload: Boolean, forceRepoll: Boolean, staleOK: Boolean}>

export type LockContext = $ReadOnly<{requireLockID: LockID, releaseAfterSuccess: Boolean}>

export type LockID = Long

export type LogLevel =
  | 0 // NONE_0
  | 1 // DEBUG_1
  | 2 // INFO_2
  | 3 // NOTICE_3
  | 4 // WARN_4
  | 5 // ERROR_5
  | 6 // CRITICAL_6
  | 7 // FATAL_7

export type LogRegisterLoggerRpcParam = $ReadOnly<{name: String, level: LogLevel, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LogUiLogRpcParam = $ReadOnly<{level: LogLevel, text: Text, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginAccountDeleteRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginClearStoredSecretRpcParam = $ReadOnly<{username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginDeprovisionRpcParam = $ReadOnly<{username: String, doRevoke: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginGetConfiguredAccountsRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginLoginProvisionedDeviceRpcParam = $ReadOnly<{username: String, noPassphrasePrompt: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginLoginRpcParam = $ReadOnly<{deviceType: String, usernameOrEmail: String, clientType: ClientType, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginLoginWithPaperKeyRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginLogoutRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginPaperKeyRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginPaperKeySubmitRpcParam = $ReadOnly<{paperPhrase: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginPgpProvisionRpcParam = $ReadOnly<{username: String, passphrase: String, deviceName: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginRecoverAccountFromEmailAddressRpcParam = $ReadOnly<{email: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginUiDisplayPaperKeyPhraseRpcParam = $ReadOnly<{phrase: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginUiDisplayPrimaryPaperKeyRpcParam = $ReadOnly<{phrase: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginUiGetEmailOrUsernameRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginUiPromptRevokePaperKeysRpcParam = $ReadOnly<{device: Device, index: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginUnlockRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LoginUnlockWithPassphraseRpcParam = $ReadOnly<{passphrase: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LogsendPrepareLogsendRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type LookupImplicitTeamRes = $ReadOnly<{teamID: TeamID, name: TeamName, displayName: ImplicitTeamDisplayName, tlfID: TLFID}>

export type MDBlock = $ReadOnly<{version: Int, timestamp: Time, block: Bytes}>

export type MDPriority = Int

export type MaskB64 = Bytes

export type MemberInfo = $ReadOnly<{userID: UID, teamID: TeamID, fqName: String, isImplicitTeam: Boolean, isOpenTeam: Boolean, role: TeamRole, implicit?: ?ImplicitRole, memberCount: Int}>

export type MerkleGetCurrentMerkleRootRpcParam = $ReadOnly<{freshnessMsec: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MerkleRoot = $ReadOnly<{version: Int, root: Bytes}>

export type MerkleRootAndTime = $ReadOnly<{root: MerkleRootV2, updateTime: Time, fetchTime: Time}>

export type MerkleRootV2 = $ReadOnly<{seqno: Seqno, hashMeta: HashMeta}>

export type MerkleTreeID =
  | 0 // MASTER_0
  | 1 // KBFS_PUBLIC_1
  | 2 // KBFS_PRIVATE_2
  | 3 // KBFS_PRIVATETEAM_3

export type MerkleTreeLocation = $ReadOnly<{leaf: UserOrTeamID, loc: SigChainLocation}>

export type MetadataAuthenticateRpcParam = $ReadOnly<{signature: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataDeleteKeyRpcParam = $ReadOnly<{uid: UID, deviceKID: KID, keyHalfID: Bytes, logTags: {[key: string]: String}, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetChallengeRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetFolderHandleRpcParam = $ReadOnly<{folderID: String, signature: String, challenge: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetFoldersForRekeyRpcParam = $ReadOnly<{deviceKID: KID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetKeyBundlesRpcParam = $ReadOnly<{folderID: String, writerBundleID: String, readerBundleID: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetKeyRpcParam = $ReadOnly<{keyHalfID: Bytes, deviceKID: String, logTags: {[key: string]: String}, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetLatestFolderHandleRpcParam = $ReadOnly<{folderID: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetMerkleNodeRpcParam = $ReadOnly<{hash: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetMerkleRootLatestRpcParam = $ReadOnly<{treeID: MerkleTreeID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetMerkleRootRpcParam = $ReadOnly<{treeID: MerkleTreeID, seqNo: Long, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetMerkleRootSinceRpcParam = $ReadOnly<{treeID: MerkleTreeID, when: Time, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataGetMetadataRpcParam = $ReadOnly<{folderID: String, folderHandle: Bytes, branchID: String, unmerged: Boolean, startRevision: Long, stopRevision: Long, logTags: {[key: string]: String}, lockBeforeGet?: ?LockID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataLockRpcParam = $ReadOnly<{folderID: String, lockID: LockID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataPing2RpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataPingRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataPruneBranchRpcParam = $ReadOnly<{folderID: String, branchID: String, logTags: {[key: string]: String}, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataPutKeysRpcParam = $ReadOnly<{keyHalves?: ?Array<KeyHalf>, logTags: {[key: string]: String}, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataPutMetadataRpcParam = $ReadOnly<{mdBlock: MDBlock, readerKeyBundle: KeyBundle, writerKeyBundle: KeyBundle, logTags: {[key: string]: String}, lockContext?: ?LockContext, priority: MDPriority, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataRegisterForUpdatesRpcParam = $ReadOnly<{folderID: String, currRevision: Long, logTags: {[key: string]: String}, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataReleaseLockRpcParam = $ReadOnly<{folderID: String, lockID: LockID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataResponse = $ReadOnly<{folderID: String, mdBlocks?: ?Array<MDBlock>}>

export type MetadataStartImplicitTeamMigrationRpcParam = $ReadOnly<{folderID: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataTruncateLockRpcParam = $ReadOnly<{folderID: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataTruncateUnlockRpcParam = $ReadOnly<{folderID: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataUpdateFolderNeedsRekeyRpcParam = $ReadOnly<{folderID: String, revision: Long, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataUpdateFoldersNeedRekeyRpcParam = $ReadOnly<{requests?: ?Array<RekeyRequest>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MetadataUpdateMetadataUpdateRpcParam = $ReadOnly<{folderID: String, revision: Long, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type MoveArgs = $ReadOnly<{opID: OpID, src: Path, dest: Path}>

export type NaclDHKeyPrivate = any

export type NaclDHKeyPublic = any

export type NaclSigningKeyPrivate = any

export type NaclSigningKeyPublic = any

export type NotificationChannels = $ReadOnly<{session: Boolean, users: Boolean, kbfs: Boolean, tracking: Boolean, favorites: Boolean, paperkeys: Boolean, keyfamily: Boolean, service: Boolean, app: Boolean, chat: Boolean, pgp: Boolean, kbfsrequest: Boolean, badges: Boolean, reachability: Boolean, team: Boolean}>

export type NotifyAppExitRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyBadgesBadgeStateRpcParam = $ReadOnly<{badgeState: BadgeState, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyCtlSetNotificationsRpcParam = $ReadOnly<{channels: NotificationChannels, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFSFSActivityRpcParam = $ReadOnly<{notification: FSNotification, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFSFSEditListResponseRpcParam = $ReadOnly<{edits?: ?Array<FSNotification>, requestID: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFSFSSyncActivityRpcParam = $ReadOnly<{status: FSPathSyncStatus, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFSFSSyncStatusResponseRpcParam = $ReadOnly<{status: FSSyncStatus, requestID: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFSRequestFSEditListRequestRpcParam = $ReadOnly<{req: FSEditListRequest, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFSRequestFSSyncStatusRequestRpcParam = $ReadOnly<{req: FSSyncStatusRequest, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyFavoritesFavoritesChangedRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyKeyfamilyKeyfamilyChangedRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyPGPPgpKeyInSecretStoreFileRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyPaperKeyPaperKeyCachedRpcParam = $ReadOnly<{uid: UID, encKID: KID, sigKID: KID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyServiceShutdownRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifySessionClientOutOfDateRpcParam = $ReadOnly<{upgradeTo: String, upgradeURI: String, upgradeMsg: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifySessionLoggedInRpcParam = $ReadOnly<{username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifySessionLoggedOutRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyTeamTeamAbandonedRpcParam = $ReadOnly<{teamID: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyTeamTeamChangedByIDRpcParam = $ReadOnly<{teamID: TeamID, latestSeqno: Seqno, implicitTeam: Boolean, changes: TeamChangeSet, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyTeamTeamChangedByNameRpcParam = $ReadOnly<{teamName: String, latestSeqno: Seqno, implicitTeam: Boolean, changes: TeamChangeSet, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyTeamTeamDeletedRpcParam = $ReadOnly<{teamID: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyTeamTeamExitRpcParam = $ReadOnly<{teamID: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyTrackingTrackingChangedRpcParam = $ReadOnly<{uid: UID, username: String, isTracking: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type NotifyUsersUserChangedRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type OpDescription = {asyncOp: 0, list: ?ListArgs} | {asyncOp: 1, listRecursive: ?ListArgs} | {asyncOp: 2, read: ?ReadArgs} | {asyncOp: 3, write: ?WriteArgs} | {asyncOp: 4, copy: ?CopyArgs} | {asyncOp: 5, move: ?MoveArgs} | {asyncOp: 6, remove: ?RemoveArgs}

export type OpID = any

export type OpProgress = $ReadOnly<{start: Time, endEstimate: Time, opType: AsyncOps, bytesTotal: Int64, bytesRead: Int64, bytesWritten: Int64, filesTotal: Int64, filesRead: Int64, filesWritten: Int64}>

export type OpenFlags =
  | 0 // READ_0
  | 1 // REPLACE_1
  | 2 // EXISTING_2
  | 4 // WRITE_4
  | 8 // APPEND_8
  | 16 // DIRECTORY_16

export type OutOfDateInfo = $ReadOnly<{upgradeTo: String, upgradeURI: String, customMessage: String, criticalClockSkew: Long}>

export type Outcome =
  | 0 // NONE_0
  | 1 // FIXED_1
  | 2 // IGNORED_2

export type PGPCreateUids = $ReadOnly<{useDefault: Boolean, ids?: ?Array<PGPIdentity>}>

export type PGPDecryptOptions = $ReadOnly<{assertSigned: Boolean, signedBy: String}>

export type PGPEncryptOptions = $ReadOnly<{recipients?: ?Array<String>, noSign: Boolean, noSelf: Boolean, binaryOut: Boolean, keyQuery: String}>

export type PGPFingerprint = any

export type PGPIdentity = $ReadOnly<{username: String, comment: String, email: String}>

export type PGPPurgeRes = $ReadOnly<{filenames?: ?Array<String>}>

export type PGPQuery = $ReadOnly<{secret: Boolean, query: String, exactMatch: Boolean}>

export type PGPSigVerification = $ReadOnly<{isSigned: Boolean, verified: Boolean, signer: User, signKey: PublicKey}>

export type PGPSignOptions = $ReadOnly<{keyQuery: String, mode: SignMode, binaryIn: Boolean, binaryOut: Boolean}>

export type PGPVerifyOptions = $ReadOnly<{signedBy: String, signature: Bytes}>

export type PaperprovisionPaperProvisionRpcParam = $ReadOnly<{username: String, deviceName: String, paperKey: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PassphraseStream = $ReadOnly<{passphraseStream: Bytes, generation: Int}>

export type PassphraseType =
  | 0 // NONE_0
  | 1 // PAPER_KEY_1
  | 2 // PASS_PHRASE_2
  | 3 // VERIFY_PASS_PHRASE_3

export type Path = {PathType: 0, local: ?String} | {PathType: 1, kbfs: ?String}

export type PathType =
  | 0 // LOCAL_0
  | 1 // KBFS_1

export type PerTeamKey = $ReadOnly<{gen: PerTeamKeyGeneration, seqno: Seqno, sigKID: KID, encKID: KID}>

export type PerTeamKeyGeneration = Int

export type PerTeamKeySeed = any

export type PerTeamKeySeedItem = $ReadOnly<{seed: PerTeamKeySeed, generation: PerTeamKeyGeneration, seqno: Seqno}>

export type PerUserKey = $ReadOnly<{gen: Int, seqno: Seqno, sigKID: KID, encKID: KID, signedByKID: KID}>

export type PerUserKeyBox = $ReadOnly<{generation: PerUserKeyGeneration, box: String, receiverKID: KID}>

export type PerUserKeyGeneration = Int

export type PgpPgpDecryptRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: PGPDecryptOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpDeletePrimaryRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpEncryptRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: PGPEncryptOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpExportByFingerprintRpcParam = $ReadOnly<{options: PGPQuery, encrypted: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpExportByKIDRpcParam = $ReadOnly<{options: PGPQuery, encrypted: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpExportRpcParam = $ReadOnly<{options: PGPQuery, encrypted: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpImportRpcParam = $ReadOnly<{key: Bytes, pushSecret: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpKeyGenDefaultRpcParam = $ReadOnly<{createUids: PGPCreateUids, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpKeyGenRpcParam = $ReadOnly<{primaryBits: Int, subkeyBits: Int, createUids: PGPCreateUids, allowMulti: Boolean, doExport: Boolean, exportEncrypted: Boolean, pushSecret: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpPullRpcParam = $ReadOnly<{userAsserts?: ?Array<String>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpPurgeRpcParam = $ReadOnly<{doPurge: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpSelectRpcParam = $ReadOnly<{fingerprintQuery: String, allowMulti: Boolean, skipImport: Boolean, onlyImport: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpSignRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: PGPSignOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpStorageDismissRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpUpdateRpcParam = $ReadOnly<{all: Boolean, fingerprints?: ?Array<String>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpPgpVerifyRpcParam = $ReadOnly<{source: Stream, opts: PGPVerifyOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpUiFinishedRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpUiKeyGeneratedRpcParam = $ReadOnly<{kid: KID, key: KeyInfo, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpUiOutputSignatureSuccessNonKeybaseRpcParam = $ReadOnly<{keyID: String, signedAt: Time, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpUiOutputSignatureSuccessRpcParam = $ReadOnly<{fingerprint: String, username: String, signedAt: Time, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PgpUiShouldPushPrivateRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Pics = $ReadOnly<{square40: String, square200: String, square360: String}>

export type PingResponse = $ReadOnly<{timestamp: Time}>

export type PlatformInfo = $ReadOnly<{os: String, osVersion: String, arch: String, goVersion: String}>

export type PprofLogProcessorProfileRpcParam = $ReadOnly<{logDirForMobile: String, profileDurationSeconds: DurationSec, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PprofLogTraceRpcParam = $ReadOnly<{logDirForMobile: String, traceDurationSeconds: DurationSec, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PprofProcessorProfileRpcParam = $ReadOnly<{profileFile: String, profileDurationSeconds: DurationSec, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PprofTraceRpcParam = $ReadOnly<{traceFile: String, traceDurationSeconds: DurationSec, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProblemSet = $ReadOnly<{user: User, kid: KID, tlfs?: ?Array<ProblemTLF>}>

export type ProblemSetDevices = $ReadOnly<{problemSet: ProblemSet, devices?: ?Array<Device>}>

export type ProblemTLF = $ReadOnly<{tlf: TLF, score: Int, solution_kids?: ?Array<KID>}>

export type Process = $ReadOnly<{pid: String, command: String, fileDescriptors?: ?Array<FileDescriptor>}>

export type Progress = Int

export type PromptDefault =
  | 0 // NONE_0
  | 1 // YES_1
  | 2 // NO_2

export type PromptOverwriteType =
  | 0 // SOCIAL_0
  | 1 // SITE_1

export type ProofResult = $ReadOnly<{state: ProofState, status: ProofStatus, desc: String}>

export type ProofState =
  | 0 // NONE_0
  | 1 // OK_1
  | 2 // TEMP_FAILURE_2
  | 3 // PERM_FAILURE_3
  | 4 // LOOKING_4
  | 5 // SUPERSEDED_5
  | 6 // POSTED_6
  | 7 // REVOKED_7
  | 8 // DELETED_8
  | 9 // UNKNOWN_TYPE_9
  | 10 // SIG_HINT_MISSING_10
  | 11 // UNCHECKED_11

export type ProofStatus =
  | 0 // NONE_0
  | 1 // OK_1
  | 2 // LOCAL_2
  | 3 // FOUND_3
  | 100 // BASE_ERROR_100
  | 101 // HOST_UNREACHABLE_101
  | 103 // PERMISSION_DENIED_103
  | 106 // FAILED_PARSE_106
  | 107 // DNS_ERROR_107
  | 108 // AUTH_FAILED_108
  | 129 // HTTP_429_129
  | 150 // HTTP_500_150
  | 160 // TIMEOUT_160
  | 170 // INTERNAL_ERROR_170
  | 171 // UNCHECKED_171
  | 172 // MISSING_PVL_172
  | 200 // BASE_HARD_ERROR_200
  | 201 // NOT_FOUND_201
  | 202 // CONTENT_FAILURE_202
  | 203 // BAD_USERNAME_203
  | 204 // BAD_REMOTE_ID_204
  | 205 // TEXT_NOT_FOUND_205
  | 206 // BAD_ARGS_206
  | 207 // CONTENT_MISSING_207
  | 208 // TITLE_NOT_FOUND_208
  | 209 // SERVICE_ERROR_209
  | 210 // TOR_SKIPPED_210
  | 211 // TOR_INCOMPATIBLE_211
  | 230 // HTTP_300_230
  | 240 // HTTP_400_240
  | 260 // HTTP_OTHER_260
  | 270 // EMPTY_JSON_270
  | 301 // DELETED_301
  | 302 // SERVICE_DEAD_302
  | 303 // BAD_SIGNATURE_303
  | 304 // BAD_API_URL_304
  | 305 // UNKNOWN_TYPE_305
  | 306 // NO_HINT_306
  | 307 // BAD_HINT_TEXT_307
  | 308 // INVALID_PVL_308

export type ProofType =
  | 0 // NONE_0
  | 1 // KEYBASE_1
  | 2 // TWITTER_2
  | 3 // GITHUB_3
  | 4 // REDDIT_4
  | 5 // COINBASE_5
  | 6 // HACKERNEWS_6
  | 8 // FACEBOOK_8
  | 1000 // GENERIC_WEB_SITE_1000
  | 1001 // DNS_1001
  | 1002 // PGP_1002
  | 100001 // ROOTER_100001

export type Proofs = $ReadOnly<{social?: ?Array<TrackProof>, web?: ?Array<WebProof>, publicKeys?: ?Array<PublicKey>}>

export type ProveCheckProofRpcParam = $ReadOnly<{sigID: SigID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveStartProofRpcParam = $ReadOnly<{service: String, username: String, force: Boolean, promptPosted: Boolean, auto: Boolean, sigVersion?: ?SigVersion, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiDisplayRecheckWarningRpcParam = $ReadOnly<{text: Text, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiOkToCheckRpcParam = $ReadOnly<{name: String, attempt: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiOutputInstructionsRpcParam = $ReadOnly<{instructions: Text, proof: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiOutputPrechecksRpcParam = $ReadOnly<{text: Text, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiPreProofWarningRpcParam = $ReadOnly<{text: Text, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiPromptOverwriteRpcParam = $ReadOnly<{account: String, typ: PromptOverwriteType, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProveUiPromptUsernameRpcParam = $ReadOnly<{prompt: String, prevError?: ?Status, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionMethod =
  | 0 // DEVICE_0
  | 1 // PAPER_KEY_1
  | 2 // PASSPHRASE_2
  | 3 // GPG_IMPORT_3
  | 4 // GPG_SIGN_4

export type ProvisionUiChooseDeviceRpcParam = $ReadOnly<{devices?: ?Array<Device>, canSelectNoDevice: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiChooseDeviceTypeRpcParam = $ReadOnly<{kind: ChooseType, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiChooseGPGMethodRpcParam = $ReadOnly<{keys?: ?Array<GPGKey>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiChooseProvisioningMethodRpcParam = $ReadOnly<{gpgOption: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiDisplayAndPromptSecretRpcParam = $ReadOnly<{secret: Bytes, phrase: String, otherDeviceType: DeviceType, previousErr: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiDisplaySecretExchangedRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiPromptNewDeviceNameRpcParam = $ReadOnly<{existingDevices?: ?Array<String>, errorMessage: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiProvisioneeSuccessRpcParam = $ReadOnly<{username: String, deviceName: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiProvisionerSuccessRpcParam = $ReadOnly<{deviceName: String, deviceType: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ProvisionUiSwitchToGPGSignOKRpcParam = $ReadOnly<{key: GPGKey, importError: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type PublicKey = $ReadOnly<{KID: KID, PGPFingerprint: String, PGPIdentities?: ?Array<PGPIdentity>, isSibkey: Boolean, isEldest: Boolean, parentID: String, deviceID: DeviceID, deviceDescription: String, deviceType: String, cTime: Time, eTime: Time, isRevoked: Boolean}>

export type PublicKeyV2 = {keyType: 1, nacl: ?PublicKeyV2NaCl} | {keyType: 2, pgp: ?PublicKeyV2PGPSummary} | {keyType: any}

export type PublicKeyV2Base = $ReadOnly<{kid: KID, isSibkey: Boolean, isEldest: Boolean, cTime: Time, eTime: Time, provisioning: SignatureMetadata, revocation?: ?SignatureMetadata}>

export type PublicKeyV2NaCl = $ReadOnly<{base: PublicKeyV2Base, parent?: ?KID, deviceID: DeviceID, deviceDescription: String, deviceType: String}>

export type PublicKeyV2PGPSummary = $ReadOnly<{base: PublicKeyV2Base, fingerprint: PGPFingerprint, identities?: ?Array<PGPIdentity>}>

export type PushReason =
  | 0 // NONE_0
  | 1 // RECONNECTED_1
  | 2 // NEW_DATA_2

export type QuotaVerifySessionRpcParam = $ReadOnly<{session: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Reachability = $ReadOnly<{reachable: Reachable}>

export type ReachabilityCheckReachabilityRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ReachabilityReachabilityChangedRpcParam = $ReadOnly<{reachability: Reachability, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type ReachabilityStartReachabilityRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Reachable =
  | 0 // UNKNOWN_0
  | 1 // YES_1
  | 2 // NO_2

export type ReadArgs = $ReadOnly<{opID: OpID, path: Path, offset: Long, size: Int}>

export type ReaderKeyMask = $ReadOnly<{application: TeamApplication, generation: PerTeamKeyGeneration, mask: MaskB64}>

export type RegisterAddressRes = $ReadOnly<{type: String, family: String}>

export type RekeyDebugShowRekeyStatusRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyEvent = $ReadOnly<{eventType: RekeyEventType, interruptType: Int}>

export type RekeyEventType =
  | 0 // NONE_0
  | 1 // NOT_LOGGED_IN_1
  | 2 // API_ERROR_2
  | 3 // NO_PROBLEMS_3
  | 4 // LOAD_ME_ERROR_4
  | 5 // CURRENT_DEVICE_CAN_REKEY_5
  | 6 // DEVICE_LOAD_ERROR_6
  | 7 // HARASS_7
  | 8 // NO_GREGOR_MESSAGES_8

export type RekeyGetPendingRekeyStatusRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyGetRevokeWarningRpcParam = $ReadOnly<{actingDevice: DeviceID, targetDevice: DeviceID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyRekeyStatusFinishRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyRekeySyncRpcParam = $ReadOnly<{force: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyRequest = $ReadOnly<{folderID: String, revision: Long}>

export type RekeyShowPendingRekeyStatusRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyUIDelegateRekeyUIRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyUIRefreshRpcParam = $ReadOnly<{problemSetDevices: ProblemSetDevices, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RekeyUIRekeySendEventRpcParam = $ReadOnly<{event: RekeyEvent, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RemoteProof = $ReadOnly<{proofType: ProofType, key: String, value: String, displayMarkup: String, sigID: SigID, mTime: Time}>

export type RemoteTrack = $ReadOnly<{username: String, uid: UID, linkID: LinkID}>

export type RemoveArgs = $ReadOnly<{opID: OpID, path: Path}>

export type RepoID = String

export type ResetLink = $ReadOnly<{ctime: UnixTime, merkleRoot: ResetMerkleRoot, prev: ResetPrev, resetSeqno: Seqno, type: ResetType, uid: UID}>

export type ResetMerkleRoot = $ReadOnly<{hashMeta: HashMeta, seqno: Seqno}>

export type ResetPrev = $ReadOnly<{eldestKID?: ?KID, lastSeqno: Seqno, reset: SHA512}>

export type ResetSummary = $ReadOnly<{ctime: UnixTime, merkleRoot: ResetMerkleRoot, resetSeqno: Seqno, eldestSeqno: Seqno, type: ResetType}>

export type ResetType =
  | 0 // NONE_0
  | 1 // RESET_1
  | 2 // DELETE_2

export type ResolveIdentifyImplicitTeamRes = $ReadOnly<{displayName: String, teamID: TeamID, writers?: ?Array<UserVersion>, trackBreaks: {[key: string]: IdentifyTrackBreaks}, folderID: TLFID}>

export type RevokeRevokeDeviceRpcParam = $ReadOnly<{deviceID: DeviceID, forceSelf: Boolean, forceLast: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RevokeRevokeKeyRpcParam = $ReadOnly<{keyID: KID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RevokeRevokeSigsRpcParam = $ReadOnly<{sigIDQueries?: ?Array<String>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type RevokeWarning = $ReadOnly<{endangeredTLFs?: ?Array<TLF>}>

export type RevokedKey = $ReadOnly<{key: PublicKey, time: KeybaseTime, by: KID}>

export type RevokedProof = $ReadOnly<{proof: RemoteProof, diff: TrackDiff}>

export type SHA512 = Bytes

export type SaltpackDecryptOptions = $ReadOnly<{interactive: Boolean, forceRemoteCheck: Boolean, usePaperKey: Boolean}>

export type SaltpackEncryptOptions = $ReadOnly<{recipients?: ?Array<String>, anonymousSender: Boolean, encryptionOnlyMode: Boolean, noSelfEncrypt: Boolean, binary: Boolean, saltpackVersion: Int}>

export type SaltpackEncryptedMessageInfo = $ReadOnly<{devices?: ?Array<Device>, numAnonReceivers: Int, receiverIsAnon: Boolean, sender: SaltpackSender}>

export type SaltpackSaltpackDecryptRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: SaltpackDecryptOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackSaltpackEncryptRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: SaltpackEncryptOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackSaltpackSignRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: SaltpackSignOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackSaltpackVerifyRpcParam = $ReadOnly<{source: Stream, sink: Stream, opts: SaltpackVerifyOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackSender = $ReadOnly<{uid: UID, username: String, senderType: SaltpackSenderType}>

export type SaltpackSenderType =
  | 0 // NOT_TRACKED_0
  | 1 // UNKNOWN_1
  | 2 // ANONYMOUS_2
  | 3 // TRACKING_BROKE_3
  | 4 // TRACKING_OK_4
  | 5 // SELF_5
  | 6 // REVOKED_6
  | 7 // EXPIRED_7

export type SaltpackSignOptions = $ReadOnly<{detached: Boolean, binary: Boolean, saltpackVersion: Int}>

export type SaltpackUiSaltpackPromptForDecryptRpcParam = $ReadOnly<{sender: SaltpackSender, usedDelegateUI: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackUiSaltpackVerifyBadSenderRpcParam = $ReadOnly<{signingKID: KID, sender: SaltpackSender, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackUiSaltpackVerifySuccessRpcParam = $ReadOnly<{signingKID: KID, sender: SaltpackSender, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SaltpackVerifyOptions = $ReadOnly<{signedBy: String, signature: Bytes}>

export type ScanProofsScanProofsRpcParam = $ReadOnly<{infile: String, indices: String, sigid: String, ratelimit: Int, cachefile: String, ignorefile: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SearchComponent = $ReadOnly<{key: String, value: String, score: Double}>

export type SearchResult = $ReadOnly<{uid: UID, username: String, components?: ?Array<SearchComponent>, score: Double}>

export type SecretEntryArg = $ReadOnly<{desc: String, prompt: String, err: String, cancel: String, ok: String, reason: String, showTyping: Boolean}>

export type SecretEntryRes = $ReadOnly<{text: String, canceled: Boolean, storeSecret: Boolean}>

export type SecretKeys = $ReadOnly<{signing: NaclSigningKeyPrivate, encryption: NaclDHKeyPrivate}>

export type SecretKeysGetSecretKeysRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SecretResponse = $ReadOnly<{secret: Bytes, phrase: String}>

export type SecretUiGetPassphraseRpcParam = $ReadOnly<{pinentry: GUIEntryArg, terminal?: ?SecretEntryArg, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SeitanAKey = String

export type SeitanIKey = String

export type SeitanIKeyV2 = String

export type SeitanKeyAndLabel = {v: 1, v1: ?SeitanKeyAndLabelVersion1} | {v: 2, v2: ?SeitanKeyAndLabelVersion2} | {v: any}

export type SeitanKeyAndLabelVersion =
  | 1 // V1_1
  | 2 // V2_2

export type SeitanKeyAndLabelVersion1 = $ReadOnly<{i: SeitanIKey, l: SeitanKeyLabel}>

export type SeitanKeyAndLabelVersion2 = $ReadOnly<{k: SeitanPubKey, l: SeitanKeyLabel}>

export type SeitanKeyLabel = {t: 1, sms: ?SeitanKeyLabelSms} | {t: any}

export type SeitanKeyLabelSms = $ReadOnly<{f: String, n: String}>

export type SeitanKeyLabelType = 1 // SMS_1

export type SeitanPubKey = KID

export type SelectKeyRes = $ReadOnly<{keyID: String, doSecretPush: Boolean}>

export type SeqType =
  | 1 // PUBLIC_1
  | 2 // PRIVATE_2
  | 3 // SEMIPRIVATE_3

export type Seqno = Int64

export type ServiceStatus = $ReadOnly<{version: String, label: String, pid: String, lastExitStatus: String, bundleVersion: String, installStatus: InstallStatus, installAction: InstallAction, status: Status}>

export type ServicesStatus = $ReadOnly<{service?: ?Array<ServiceStatus>, kbfs?: ?Array<ServiceStatus>, updater?: ?Array<ServiceStatus>}>

export type Session = $ReadOnly<{uid: UID, username: String, token: String, deviceSubkeyKid: KID, deviceSibkeyKid: KID}>

export type SessionCurrentSessionRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SessionSessionPingRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SessionStatus = $ReadOnly<{SessionFor: String, Loaded: Boolean, Cleared: Boolean, SaltOnly: Boolean, Expired: Boolean}>

export type SessionToken = String

export type Sig = $ReadOnly<{seqno: Seqno, sigID: SigID, sigIDDisplay: String, type: String, cTime: Time, revoked: Boolean, active: Boolean, key: String, body: String}>

export type SigChainLocation = $ReadOnly<{seqno: Seqno, seqType: SeqType}>

export type SigHint = $ReadOnly<{remoteId: String, humanUrl: String, apiUrl: String, checkText: String}>

export type SigID = String

export type SigListArgs = $ReadOnly<{sessionID: Int, username: String, allKeys: Boolean, types?: ?SigTypes, filterx: String, verbose: Boolean, revoked: Boolean}>

export type SigTypes = $ReadOnly<{track: Boolean, proof: Boolean, cryptocurrency: Boolean, isSelf: Boolean}>

export type SigVersion = Int

export type SignMode =
  | 0 // ATTACHED_0
  | 1 // DETACHED_1
  | 2 // CLEAR_2

export type SignatureMetadata = $ReadOnly<{signingKID: KID, prevMerkleRootSigned: MerkleRootV2, firstAppearedUnverified: Seqno, time: Time, sigChainLocation: SigChainLocation}>

export type SignupCheckInvitationCodeRpcParam = $ReadOnly<{invitationCode: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SignupCheckUsernameAvailableRpcParam = $ReadOnly<{username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SignupGetInvitationCodeRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SignupInviteRequestRpcParam = $ReadOnly<{email: String, fullname: String, notes: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SignupRes = $ReadOnly<{passphraseOk: Boolean, postOk: Boolean, writeOk: Boolean}>

export type SignupSignupRpcParam = $ReadOnly<{email: String, inviteCode: String, passphrase: String, username: String, deviceName: String, deviceType: DeviceType, storeSecret: Boolean, skipMail: Boolean, genPGPBatch: Boolean, genPaper: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SigsSigListJSONRpcParam = $ReadOnly<{arg: SigListArgs, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SigsSigListRpcParam = $ReadOnly<{arg: SigListArgs, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSListResult = $ReadOnly<{entries?: ?Array<Dirent>, progress: Progress}>

export type SimpleFSSimpleFSCancelRpcParam = $ReadOnly<{opID: OpID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSCheckRpcParam = $ReadOnly<{opID: OpID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSCloseRpcParam = $ReadOnly<{opID: OpID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSCopyRecursiveRpcParam = $ReadOnly<{opID: OpID, src: Path, dest: Path, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSCopyRpcParam = $ReadOnly<{opID: OpID, src: Path, dest: Path, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSDumpDebuggingInfoRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSGetOpsRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSListRecursiveRpcParam = $ReadOnly<{opID: OpID, path: Path, filter: ListFilter, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSListRpcParam = $ReadOnly<{opID: OpID, path: Path, filter: ListFilter, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSMakeOpidRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSMoveRpcParam = $ReadOnly<{opID: OpID, src: Path, dest: Path, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSOpenRpcParam = $ReadOnly<{opID: OpID, dest: Path, flags: OpenFlags, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSReadListRpcParam = $ReadOnly<{opID: OpID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSReadRpcParam = $ReadOnly<{opID: OpID, offset: Long, size: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSRemoveRpcParam = $ReadOnly<{opID: OpID, path: Path, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSRenameRpcParam = $ReadOnly<{src: Path, dest: Path, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSSetStatRpcParam = $ReadOnly<{dest: Path, flag: DirentType, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSStatRpcParam = $ReadOnly<{path: Path, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSWaitRpcParam = $ReadOnly<{opID: OpID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SimpleFSSimpleFSWriteRpcParam = $ReadOnly<{opID: OpID, offset: Long, content: Bytes, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type SocialAssertion = $ReadOnly<{user: String, service: SocialAssertionService}>

export type SocialAssertionService = String

export type StartProofResult = $ReadOnly<{sigID: SigID}>

export type Status = $ReadOnly<{code: Int, name: String, desc: String, fields?: ?Array<StringKVPair>}>

export type StatusCode =
  | 0 // SCOk_0
  | 100 // SCInputError_100
  | 201 // SCLoginRequired_201
  | 202 // SCBadSession_202
  | 203 // SCBadLoginUserNotFound_203
  | 204 // SCBadLoginPassword_204
  | 205 // SCNotFound_205
  | 210 // SCThrottleControl_210
  | 216 // SCDeleted_216
  | 218 // SCGeneric_218
  | 235 // SCAlreadyLoggedIn_235
  | 230 // SCExists_230
  | 237 // SCCanceled_237
  | 239 // SCInputCanceled_239
  | 274 // SCReloginRequired_274
  | 275 // SCResolutionFailed_275
  | 276 // SCProfileNotPublic_276
  | 277 // SCIdentifyFailed_277
  | 278 // SCTrackingBroke_278
  | 279 // SCWrongCryptoFormat_279
  | 280 // SCDecryptionError_280
  | 281 // SCInvalidAddress_281
  | 283 // SCNoSession_283
  | 290 // SCAccountReset_290
  | 295 // SCIdentifiesFailed_295
  | 297 // SCNoSpaceOnDevice_297
  | 472 // SCBadEmail_472
  | 701 // SCBadSignupUsernameTaken_701
  | 707 // SCBadInvitationCode_707
  | 801 // SCMissingResult_801
  | 901 // SCKeyNotFound_901
  | 905 // SCKeyCorrupted_905
  | 907 // SCKeyInUse_907
  | 913 // SCKeyBadGen_913
  | 914 // SCKeyNoSecret_914
  | 915 // SCKeyBadUIDs_915
  | 916 // SCKeyNoActive_916
  | 917 // SCKeyNoSig_917
  | 918 // SCKeyBadSig_918
  | 919 // SCKeyBadEldest_919
  | 920 // SCKeyNoEldest_920
  | 921 // SCKeyDuplicateUpdate_921
  | 922 // SCSibkeyAlreadyExists_922
  | 924 // SCDecryptionKeyNotFound_924
  | 927 // SCKeyNoPGPEncryption_927
  | 928 // SCKeyNoNaClEncryption_928
  | 929 // SCKeySyncedPGPNotFound_929
  | 930 // SCKeyNoMatchingGPG_930
  | 931 // SCKeyRevoked_931
  | 1010 // SCSigOldSeqno_1010
  | 1301 // SCBadTrackSession_1301
  | 1404 // SCDeviceBadName_1404
  | 1408 // SCDeviceNameInUse_1408
  | 1409 // SCDeviceNotFound_1409
  | 1410 // SCDeviceMismatch_1410
  | 1411 // SCDeviceRequired_1411
  | 1413 // SCDevicePrevProvisioned_1413
  | 1414 // SCDeviceNoProvision_1414
  | 1415 // SCDeviceProvisionViaDevice_1415
  | 1416 // SCRevokeCurrentDevice_1416
  | 1417 // SCRevokeLastDevice_1417
  | 1418 // SCDeviceProvisionOffline_1418
  | 1419 // SCRevokeLastDevicePGP_1419
  | 1501 // SCStreamExists_1501
  | 1502 // SCStreamNotFound_1502
  | 1503 // SCStreamWrongKind_1503
  | 1504 // SCStreamEOF_1504
  | 1600 // SCGenericAPIError_1600
  | 1601 // SCAPINetworkError_1601
  | 1602 // SCTimeout_1602
  | 1701 // SCProofError_1701
  | 1702 // SCIdentificationExpired_1702
  | 1703 // SCSelfNotFound_1703
  | 1704 // SCBadKexPhrase_1704
  | 1705 // SCNoUIDelegation_1705
  | 1706 // SCNoUI_1706
  | 1707 // SCGPGUnavailable_1707
  | 1800 // SCInvalidVersionError_1800
  | 1801 // SCOldVersionError_1801
  | 1802 // SCInvalidLocationError_1802
  | 1803 // SCServiceStatusError_1803
  | 1804 // SCInstallError_1804
  | 1810 // SCLoadKextError_1810
  | 1811 // SCLoadKextPermError_1811
  | 2300 // SCGitInternal_2300
  | 2301 // SCGitRepoAlreadyExists_2301
  | 2302 // SCGitInvalidRepoName_2302
  | 2303 // SCGitCannotDelete_2303
  | 2304 // SCGitRepoDoesntExist_2304
  | 2400 // SCLoginStateTimeout_2400
  | 2500 // SCChatInternal_2500
  | 2501 // SCChatRateLimit_2501
  | 2502 // SCChatConvExists_2502
  | 2503 // SCChatUnknownTLFID_2503
  | 2504 // SCChatNotInConv_2504
  | 2505 // SCChatBadMsg_2505
  | 2506 // SCChatBroadcast_2506
  | 2507 // SCChatAlreadySuperseded_2507
  | 2508 // SCChatAlreadyDeleted_2508
  | 2509 // SCChatTLFFinalized_2509
  | 2510 // SCChatCollision_2510
  | 2511 // SCIdentifySummaryError_2511
  | 2512 // SCNeedSelfRekey_2512
  | 2513 // SCNeedOtherRekey_2513
  | 2514 // SCChatMessageCollision_2514
  | 2515 // SCChatDuplicateMessage_2515
  | 2516 // SCChatClientError_2516
  | 2517 // SCChatNotInTeam_2517
  | 2518 // SCChatStalePreviousState_2518
  | 2604 // SCTeamBadMembership_2604
  | 2607 // SCTeamSelfNotOwner_2607
  | 2614 // SCTeamNotFound_2614
  | 2619 // SCTeamExists_2619
  | 2623 // SCTeamReadError_2623
  | 2638 // SCNoOp_2638
  | 2646 // SCTeamInviteBadToken_2646
  | 2663 // SCTeamTarDuplicate_2663
  | 2664 // SCTeamTarNotFound_2664
  | 2665 // SCTeamMemberExists_2665
  | 2666 // SCTeamNotReleased_2666
  | 2667 // SCTeamPermanentlyLeft_2667
  | 2668 // SCTeamNeedRootId_2668
  | 2669 // SCTeamHasLiveChildren_2669
  | 2670 // SCTeamDeleteError_2670
  | 2671 // SCTeamBadRootTeam_2671
  | 2672 // SCTeamNameConflictsWithUser_2672
  | 2673 // SCTeamDeleteNoUpPointer_2673
  | 2674 // SCTeamNeedOwner_2674
  | 2675 // SCTeamNoOwnerAllowed_2675
  | 2676 // SCTeamImplicitNoNonSbs_2676
  | 2677 // SCTeamImplicitBadHash_2677
  | 2678 // SCTeamImplicitBadName_2678
  | 2679 // SCTeamImplicitClash_2679
  | 2680 // SCTeamImplicitDuplicate_2680
  | 2681 // SCTeamImplicitBadOp_2681
  | 2682 // SCTeamImplicitBadRole_2682
  | 2683 // SCTeamImplicitNotFound_2683
  | 2684 // SCTeamBadAdminSeqnoType_2684
  | 2685 // SCTeamImplicitBadAdd_2685
  | 2686 // SCTeamImplicitBadRemove_2686
  | 2696 // SCTeamInviteTokenReused_2696
  | 2697 // SCTeamKeyMaskNotFound_2697
  | 2702 // SCTeamBanned_2702
  | 2703 // SCTeamInvalidBan_2703
  | 2711 // SCTeamShowcasePermDenied_2711
  | 2721 // SCTeamProvisionalCanKey_2721
  | 2722 // SCTeamProvisionalCannotKey_2722
  | 3100 // SCStellarError_3100
  | 3101 // SCStellarBadInput_3101
  | 3102 // SCStellarWrongRevision_3102
  | 3103 // SCStellarMissingBundle_3103
  | 3104 // SCStellarBadPuk_3104
  | 3105 // SCStellarMissingAccount_3105
  | 3106 // SCStellarBadPrev_3106

export type StellarAccountID = String

export type StellarAccountMode =
  | 0 // NONE_0
  | 1 // USER_1

export type StellarBundle = $ReadOnly<{revision: StellarRevision, prev: Hash, ownHash: Hash, accounts?: ?Array<StellarEntry>}>

export type StellarBundleSecretV1 = $ReadOnly<{visibleHash: Hash, accounts?: ?Array<StellarSecretEntry>}>

export type StellarBundleSecretVersioned = {version: 1, v1: ?StellarBundleSecretV1}

export type StellarBundleVersion = 1 // V1_1

export type StellarBundleVisibleV1 = $ReadOnly<{revision: StellarRevision, prev: Hash, accounts?: ?Array<StellarVisibleEntry>}>

export type StellarEntry = $ReadOnly<{accountID: StellarAccountID, mode: StellarAccountMode, isPrimary: Boolean, signers?: ?Array<StellarSecretKey>, name: String}>

export type StellarRevision = Uint64

export type StellarSecretEntry = $ReadOnly<{accountID: StellarAccountID, signers?: ?Array<StellarSecretKey>, name: String}>

export type StellarSecretKey = String

export type StellarVisibleEntry = $ReadOnly<{accountID: StellarAccountID, mode: StellarAccountMode, isPrimary: Boolean}>

export type Stream = $ReadOnly<{fd: Int}>

export type StreamUiCloseRpcParam = $ReadOnly<{s: Stream, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type StreamUiReadRpcParam = $ReadOnly<{s: Stream, sz: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type StreamUiResetRpcParam = $ReadOnly<{s: Stream, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type StreamUiWriteRpcParam = $ReadOnly<{s: Stream, buf: Bytes, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type StringKVPair = $ReadOnly<{key: String, value: String}>

export type SubteamLogPoint = $ReadOnly<{name: TeamName, seqno: Seqno}>

export type TLF = $ReadOnly<{id: TLFID, name: String, writers?: ?Array<String>, readers?: ?Array<String>, isPrivate: Boolean}>

export type TLFBreak = $ReadOnly<{breaks?: ?Array<TLFIdentifyFailure>}>

export type TLFID = String

export type TLFIdentifyBehavior =
  | 0 // UNSET_0
  | 1 // CHAT_CLI_1
  | 2 // CHAT_GUI_2
  | 3 // CHAT_GUI_STRICT_3
  | 4 // KBFS_REKEY_4
  | 5 // KBFS_QR_5
  | 6 // CHAT_SKIP_6
  | 7 // SALTPACK_7
  | 8 // CLI_8
  | 9 // GUI_9
  | 10 // DEFAULT_KBFS_10

export type TLFIdentifyFailure = $ReadOnly<{user: User, breaks?: ?IdentifyTrackBreaks}>

export type TLFQuery = $ReadOnly<{tlfName: String, identifyBehavior: TLFIdentifyBehavior}>

export type TLFVisibility =
  | 0 // ANY_0
  | 1 // PUBLIC_1
  | 2 // PRIVATE_2

export type TeamAcceptOrRequestResult = $ReadOnly<{wasToken: Boolean, wasSeitan: Boolean, wasTeamName: Boolean, wasOpenTeam: Boolean}>

export type TeamAccessRequest = $ReadOnly<{uid: UID, eldestSeqno: Seqno}>

export type TeamAddMemberResult = $ReadOnly<{invited: Boolean, user?: ?User, emailSent: Boolean, chatSent: Boolean}>

export type TeamAndMemberShowcase = $ReadOnly<{teamShowcase: TeamShowcase, isMemberShowcased: Boolean}>

export type TeamApplication =
  | 1 // KBFS_1
  | 2 // CHAT_2
  | 3 // SALTPACK_3
  | 4 // GIT_METADATA_4
  | 5 // SEITAN_INVITE_TOKEN_5

export type TeamApplicationKey = $ReadOnly<{application: TeamApplication, keyGeneration: PerTeamKeyGeneration, key: Bytes32}>

export type TeamCLKRMsg = $ReadOnly<{teamID: TeamID, generation: PerTeamKeyGeneration, score: Int}>

export type TeamChangeReq = $ReadOnly<{owners?: ?Array<UserVersion>, admins?: ?Array<UserVersion>, writers?: ?Array<UserVersion>, readers?: ?Array<UserVersion>, none?: ?Array<UserVersion>, completedInvites: {[key: string]: UserVersionPercentForm}}>

export type TeamChangeRow = $ReadOnly<{id: TeamID, name: String, keyRotated: Boolean, membershipChanged: Boolean, latestSeqno: Seqno, implicitTeam: Boolean, misc: Boolean}>

export type TeamChangeSet = $ReadOnly<{membershipChanged: Boolean, keyRotated: Boolean, renamed: Boolean, misc: Boolean}>

export type TeamCreateResult = $ReadOnly<{teamID: TeamID, chatSent: Boolean, creatorAdded: Boolean}>

export type TeamData = $ReadOnly<{secretless: Boolean, name: TeamName, chain: TeamSigChainState, perTeamKeySeeds: {[key: string]: PerTeamKeySeedItem}, readerKeyMasks: {[key: string]: {[key: string]: MaskB64}}, latestSeqnoHint: Seqno, cachedAt: Time, tlfCryptKeys: {[key: string]: ?Array<CryptKey>}}>

export type TeamDebugRes = $ReadOnly<{chain: TeamSigChainState}>

export type TeamDetails = $ReadOnly<{members: TeamMembersDetails, keyGeneration: PerTeamKeyGeneration, annotatedActiveInvites: {[key: string]: AnnotatedTeamInvite}, settings: TeamSettings, showcase: TeamShowcase}>

export type TeamEk = $ReadOnly<{seed: Bytes32, metadata: TeamEkMetadata}>

export type TeamEkBoxed = $ReadOnly<{box: String, userEkGeneration: EkGeneration, metadata: TeamEkMetadata}>

export type TeamEkMetadata = $ReadOnly<{kid: KID, hashMeta: HashMeta, generation: EkGeneration, ctime: Time}>

export type TeamEkStatement = $ReadOnly<{currentTeamEkMetadata: TeamEkMetadata, existingTeamEkMetadata?: ?Array<TeamEkMetadata>}>

export type TeamEncryptedKBFSKeyset = $ReadOnly<{v: Int, e: Bytes, n: Bytes}>

export type TeamEncryptedKBFSKeysetHash = String

export type TeamExitRow = $ReadOnly<{id: TeamID}>

export type TeamGetLegacyTLFUpgrade = $ReadOnly<{encryptedKeyset: String, teamGeneration: PerTeamKeyGeneration, legacyGeneration: Int, appType: TeamApplication}>

export type TeamID = String

export type TeamIDAndName = $ReadOnly<{id: TeamID, name: TeamName}>

export type TeamIDWithVisibility = $ReadOnly<{teamID: TeamID, visibility: TLFVisibility}>

export type TeamInvite = $ReadOnly<{role: TeamRole, id: TeamInviteID, type: TeamInviteType, name: TeamInviteName, inviter: UserVersion}>

export type TeamInviteCategory =
  | 0 // NONE_0
  | 1 // UNKNOWN_1
  | 2 // KEYBASE_2
  | 3 // EMAIL_3
  | 4 // SBS_4
  | 5 // SEITAN_5

export type TeamInviteID = String

export type TeamInviteName = String

export type TeamInviteSocialNetwork = String

export type TeamInviteType = {c: 1, unknown: ?String} | {c: 4, sbs: ?TeamInviteSocialNetwork} | {c: any}

export type TeamInvitee = $ReadOnly<{inviteID: TeamInviteID, uid: UID, eldestSeqno: Seqno, role: TeamRole}>

export type TeamJoinRequest = $ReadOnly<{name: String, username: String}>

export type TeamKBFSKeyRefresher = $ReadOnly<{generation: Int, appType: TeamApplication}>

export type TeamLegacyTLFUpgradeChainInfo = $ReadOnly<{keysetHash: TeamEncryptedKBFSKeysetHash, teamGeneration: PerTeamKeyGeneration, legacyGeneration: Int, appType: TeamApplication}>

export type TeamList = $ReadOnly<{teams?: ?Array<MemberInfo>}>

export type TeamMember = $ReadOnly<{uid: UID, role: TeamRole, eldestSeqno: Seqno, userEldestSeqno: Seqno}>

export type TeamMemberDetails = $ReadOnly<{uv: UserVersion, username: String, fullName: FullName, active: Boolean, needsPUK: Boolean}>

export type TeamMemberOutFromReset = $ReadOnly<{teamName: String, resetUser: TeamResetUser}>

export type TeamMemberOutReset = $ReadOnly<{teamname: String, username: String, id: Gregor1.MsgID}>

export type TeamMembers = $ReadOnly<{owners?: ?Array<UserVersion>, admins?: ?Array<UserVersion>, writers?: ?Array<UserVersion>, readers?: ?Array<UserVersion>}>

export type TeamMembersDetails = $ReadOnly<{owners?: ?Array<TeamMemberDetails>, admins?: ?Array<TeamMemberDetails>, writers?: ?Array<TeamMemberDetails>, readers?: ?Array<TeamMemberDetails>}>

export type TeamName = $ReadOnly<{parts?: ?Array<TeamNamePart>}>

export type TeamNameLogPoint = $ReadOnly<{lastPart: TeamNamePart, seqno: Seqno}>

export type TeamNamePart = String

export type TeamOpenReqMsg = $ReadOnly<{teamID: TeamID, tars?: ?Array<TeamAccessRequest>}>

export type TeamOperation = $ReadOnly<{manageMembers: Boolean, manageSubteams: Boolean, createChannel: Boolean, deleteChannel: Boolean, renameChannel: Boolean, editChannelDescription: Boolean, setTeamShowcase: Boolean, setMemberShowcase: Boolean, changeOpenTeam: Boolean, leaveTeam: Boolean, joinTeam: Boolean, setPublicityAny: Boolean, listFirst: Boolean, changeTarsDisabled: Boolean, deleteChatHistory: Boolean}>

export type TeamPlusApplicationKeys = $ReadOnly<{id: TeamID, name: String, implicit: Boolean, public: Boolean, application: TeamApplication, writers?: ?Array<UserVersion>, onlyReaders?: ?Array<UserVersion>, applicationKeys?: ?Array<TeamApplicationKey>}>

export type TeamRefreshers = $ReadOnly<{needKeyGeneration: PerTeamKeyGeneration, wantMembers?: ?Array<UserVersion>, wantMembersRole: TeamRole, needKBFSKeyGeneration: TeamKBFSKeyRefresher}>

export type TeamRequestAccessResult = $ReadOnly<{open: Boolean}>

export type TeamResetUser = $ReadOnly<{username: String, uid: UID, eldestSeqno: Seqno}>

export type TeamRole =
  | 0 // NONE_0
  | 1 // READER_1
  | 2 // WRITER_2
  | 3 // ADMIN_3
  | 4 // OWNER_4

export type TeamSBSMsg = $ReadOnly<{teamID: TeamID, score: Int, invitees?: ?Array<TeamInvitee>}>

export type TeamSeitanMsg = $ReadOnly<{teamID: TeamID, seitans?: ?Array<TeamSeitanRequest>}>

export type TeamSeitanRequest = $ReadOnly<{inviteID: TeamInviteID, uid: UID, eldestSeqno: Seqno, akey: SeitanAKey, role: TeamRole, unixCTime: Int64}>

export type TeamSettings = $ReadOnly<{open: Boolean, joinAs: TeamRole}>

export type TeamShowcase = $ReadOnly<{isShowcased: Boolean, description?: ?String, setByUID?: ?UID, anyMemberShowcase: Boolean}>

export type TeamSigChainState = $ReadOnly<{reader: UserVersion, id: TeamID, implicit: Boolean, public: Boolean, rootAncestor: TeamName, nameDepth: Int, nameLog?: ?Array<TeamNameLogPoint>, lastSeqno: Seqno, lastLinkID: LinkID, parentID?: ?TeamID, userLog: {[key: string]: ?Array<UserLogPoint>}, subteamLog: {[key: string]: ?Array<SubteamLogPoint>}, perTeamKeys: {[key: string]: PerTeamKey}, linkIDs: {[key: string]: LinkID}, stubbedLinks: {[key: string]: Boolean}, activeInvites: {[key: string]: TeamInvite}, obsoleteInvites: {[key: string]: TeamInvite}, open: Boolean, openTeamJoinAs: TeamRole, tlfID: TLFID, tlfLegacyUpgrade: {[key: string]: TeamLegacyTLFUpgradeChainInfo}}>

export type TeamTreeEntry = $ReadOnly<{name: TeamName, admin: Boolean}>

export type TeamTreeResult = $ReadOnly<{entries?: ?Array<TeamTreeEntry>}>

export type TeamType =
  | 0 // NONE_0
  | 1 // LEGACY_1
  | 2 // MODERN_2

export type TeamsCanUserPerformRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsGetTarsDisabledRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsGetTeamAndMemberShowcaseRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsGetTeamRootIDRpcParam = $ReadOnly<{id: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsGetTeamShowcaseRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsLoadTeamPlusApplicationKeysRpcParam = $ReadOnly<{id: TeamID, application: TeamApplication, refreshers: TeamRefreshers, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsLookupImplicitTeamRpcParam = $ReadOnly<{name: String, public: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsLookupOrCreateImplicitTeamRpcParam = $ReadOnly<{name: String, public: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsSetTarsDisabledRpcParam = $ReadOnly<{name: String, disabled: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsSetTeamMemberShowcaseRpcParam = $ReadOnly<{name: String, isShowcased: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsSetTeamShowcaseRpcParam = $ReadOnly<{name: String, isShowcased?: ?Boolean, description?: ?String, anyMemberShowcase?: ?Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamAcceptInviteOrRequestAccessRpcParam = $ReadOnly<{tokenOrName: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamAcceptInviteRpcParam = $ReadOnly<{token: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamAddEmailsBulkRpcParam = $ReadOnly<{name: String, emails: String, role: TeamRole, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamAddMemberRpcParam = $ReadOnly<{name: String, email: String, username: String, role: TeamRole, sendChatNotification: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamChangeMembershipRpcParam = $ReadOnly<{name: String, req: TeamChangeReq, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamCreateRpcParam = $ReadOnly<{name: String, joinSubteam: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamCreateSeitanTokenRpcParam = $ReadOnly<{name: String, role: TeamRole, label: SeitanKeyLabel, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamCreateSeitanTokenV2RpcParam = $ReadOnly<{name: String, role: TeamRole, label: SeitanKeyLabel, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamCreateWithSettingsRpcParam = $ReadOnly<{name: String, joinSubteam: Boolean, settings: TeamSettings, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamDebugRpcParam = $ReadOnly<{teamID: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamDeleteRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamEditMemberRpcParam = $ReadOnly<{name: String, username: String, role: TeamRole, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamGetRpcParam = $ReadOnly<{name: String, forceRepoll: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamIgnoreRequestRpcParam = $ReadOnly<{name: String, username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamImplicitAdminsRpcParam = $ReadOnly<{teamName: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamLeaveRpcParam = $ReadOnly<{name: String, permanent: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamListMyAccessRequestsRpcParam = $ReadOnly<{teamName?: ?String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamListRequestsRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamListSubteamsRecursiveRpcParam = $ReadOnly<{parentTeamName: String, forceRepoll: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamListTeammatesRpcParam = $ReadOnly<{includeImplicitTeams: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamListUnverifiedRpcParam = $ReadOnly<{userAssertion: String, includeImplicitTeams: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamListVerifiedRpcParam = $ReadOnly<{userAssertion: String, includeImplicitTeams: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamReAddMemberAfterResetRpcParam = $ReadOnly<{id: TeamID, username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamRemoveMemberRpcParam = $ReadOnly<{name: String, username: String, email: String, inviteID: TeamInviteID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamRenameRpcParam = $ReadOnly<{prevName: TeamName, newName: TeamName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamRequestAccessRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamRotateKeyRpcParam = $ReadOnly<{teamID: TeamID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamSetSettingsRpcParam = $ReadOnly<{name: String, settings: TeamSettings, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsTeamTreeRpcParam = $ReadOnly<{name: TeamName, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsUiConfirmRootTeamDeleteRpcParam = $ReadOnly<{teamName: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TeamsUiConfirmSubteamDeleteRpcParam = $ReadOnly<{teamName: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Test = $ReadOnly<{reply: String}>

export type TestPanicRpcParam = $ReadOnly<{message: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TestTestCallbackRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TestTestRpcParam = $ReadOnly<{name: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Text = $ReadOnly<{data: String, markup: Boolean}>

export type Time = Long

export type TlfCompleteAndCanonicalizePrivateTlfNameRpcParam = $ReadOnly<{query: TLFQuery, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TlfCryptKeysRpcParam = $ReadOnly<{query: TLFQuery, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TlfKeysGetPublicCanonicalTLFNameAndIDRpcParam = $ReadOnly<{query: TLFQuery, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TlfKeysGetTLFCryptKeysRpcParam = $ReadOnly<{query: TLFQuery, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TlfPublicCanonicalTLFNameAndIDRpcParam = $ReadOnly<{query: TLFQuery, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TrackCheckTrackingRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TrackDiff = $ReadOnly<{type: TrackDiffType, displayMarkup: String}>

export type TrackDiffType =
  | 0 // NONE_0
  | 1 // ERROR_1
  | 2 // CLASH_2
  | 3 // REVOKED_3
  | 4 // UPGRADED_4
  | 5 // NEW_5
  | 6 // REMOTE_FAIL_6
  | 7 // REMOTE_WORKING_7
  | 8 // REMOTE_CHANGED_8
  | 9 // NEW_ELDEST_9
  | 10 // NONE_VIA_TEMPORARY_10

export type TrackDismissWithTokenRpcParam = $ReadOnly<{trackToken: TrackToken, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TrackFakeTrackingChangedRpcParam = $ReadOnly<{username: String, isTracking: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TrackOptions = $ReadOnly<{localOnly: Boolean, bypassConfirm: Boolean, forceRetrack: Boolean, expiringLocal: Boolean, forPGPPull: Boolean, sigVersion?: ?SigVersion}>

export type TrackProof = $ReadOnly<{proofType: String, proofName: String, idString: String}>

export type TrackStatus =
  | 1 // NEW_OK_1
  | 2 // NEW_ZERO_PROOFS_2
  | 3 // NEW_FAIL_PROOFS_3
  | 4 // UPDATE_BROKEN_FAILED_PROOFS_4
  | 5 // UPDATE_NEW_PROOFS_5
  | 6 // UPDATE_OK_6
  | 7 // UPDATE_BROKEN_REVOKED_7

export type TrackSummary = $ReadOnly<{username: String, time: Time, isRemote: Boolean}>

export type TrackToken = String

export type TrackTrackRpcParam = $ReadOnly<{userAssertion: String, options: TrackOptions, forceRemoteCheck: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TrackTrackWithTokenRpcParam = $ReadOnly<{trackToken: TrackToken, options: TrackOptions, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type TrackUntrackRpcParam = $ReadOnly<{username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type Tracker = $ReadOnly<{tracker: UID, status: Int, mTime: Time}>

export type UID = String

export type UPAKVersion =
  | 1 // V1_1
  | 2 // V2_2

export type UPAKVersioned = {v: 1, v1: ?UserPlusAllKeys} | {v: 2, v2: ?UserPlusKeysV2AllIncarnations}

export type UPK2MinorVersion =
  | 0 // V0_0
  | 1 // V1_1
  | 2 // V2_2
  | 3 // V3_3
  | 4 // V4_4
  | 5 // V5_5
  | 6 // V6_6

export type UiPromptYesNoRpcParam = $ReadOnly<{text: Text, promptDefault: PromptDefault, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UnboxAnyRes = $ReadOnly<{kid: KID, plaintext: Bytes32, index: Int}>

export type UninstallResult = $ReadOnly<{componentResults?: ?Array<ComponentResult>, status: Status}>

export type UnixTime = Long

export type User = $ReadOnly<{uid: UID, username: String}>

export type UserCard = $ReadOnly<{following: Int, followers: Int, uid: UID, fullName: String, location: String, bio: String, website: String, twitter: String, youFollowThem: Boolean, theyFollowYou: Boolean, teamShowcase?: ?Array<UserTeamShowcase>}>

export type UserEk = $ReadOnly<{seed: Bytes32, metadata: UserEkMetadata}>

export type UserEkBoxed = $ReadOnly<{box: String, deviceEkGeneration: EkGeneration, metadata: UserEkMetadata}>

export type UserEkMetadata = $ReadOnly<{kid: KID, hashMeta: HashMeta, generation: EkGeneration, ctime: Time}>

export type UserEkStatement = $ReadOnly<{currentUserEkMetadata: UserEkMetadata, existingUserEkMetadata?: ?Array<UserEkMetadata>}>

export type UserGetUPAKRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserInterestingPeopleRpcParam = $ReadOnly<{maxUsers: Int, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserListTrackers2RpcParam = $ReadOnly<{assertion: String, reverse: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserListTrackersByNameRpcParam = $ReadOnly<{username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserListTrackersRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserListTrackersSelfRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserListTrackingJSONRpcParam = $ReadOnly<{filter: String, verbose: Boolean, assertion: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserListTrackingRpcParam = $ReadOnly<{filter: String, assertion: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadAllPublicKeysUnverifiedRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadMyPublicKeysRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadMySettingsRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadPublicKeysRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadUncheckedUserSummariesRpcParam = $ReadOnly<{uids?: ?Array<UID>, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadUserByNameRpcParam = $ReadOnly<{username: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadUserPlusKeysRpcParam = $ReadOnly<{uid: UID, pollForKID: KID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadUserPlusKeysV2RpcParam = $ReadOnly<{uid: UID, pollForKID: KID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLoadUserRpcParam = $ReadOnly<{uid: UID, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserLogPoint = $ReadOnly<{role: TeamRole, sigMeta: SignatureMetadata}>

export type UserMeUserVersionRpcParam = $ReadOnly<{forcePoll: Boolean, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserOrTeamID = String

export type UserOrTeamLite = $ReadOnly<{id: UserOrTeamID, name: String}>

export type UserOrTeamResult =
  | 1 // USER_1
  | 2 // TEAM_2

export type UserPlusAllKeys = $ReadOnly<{base: UserPlusKeys, pgpKeys?: ?Array<PublicKey>, remoteTracks?: ?Array<RemoteTrack>}>

export type UserPlusKeys = $ReadOnly<{uid: UID, username: String, eldestSeqno: Seqno, status: StatusCode, deviceKeys?: ?Array<PublicKey>, revokedDeviceKeys?: ?Array<RevokedKey>, pgpKeyCount: Int, uvv: UserVersionVector, deletedDeviceKeys?: ?Array<PublicKey>, perUserKeys?: ?Array<PerUserKey>, resets?: ?Array<ResetSummary>}>

export type UserPlusKeysV2 = $ReadOnly<{uid: UID, username: String, eldestSeqno: Seqno, status: StatusCode, perUserKeys?: ?Array<PerUserKey>, deviceKeys: {[key: string]: PublicKeyV2NaCl}, pgpKeys: {[key: string]: PublicKeyV2PGPSummary}, remoteTracks: {[key: string]: RemoteTrack}, reset?: ?ResetSummary}>

export type UserPlusKeysV2AllIncarnations = $ReadOnly<{current: UserPlusKeysV2, pastIncarnations?: ?Array<UserPlusKeysV2>, uvv: UserVersionVector, seqnoLinkIDs: {[key: string]: LinkID}, minorVersion: UPK2MinorVersion}>

export type UserProfileEditRpcParam = $ReadOnly<{fullName: String, location: String, bio: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserResetUserRpcParam = ?$ReadOnly<{incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserResolution = $ReadOnly<{assertion: SocialAssertion, userID: UID}>

export type UserSearchRpcParam = $ReadOnly<{query: String, incomingCallMap?: IncomingCallMapType, waitingHandler?: WaitingHandlerType}>

export type UserSettings = $ReadOnly<{emails?: ?Array<Email>}>

export type UserSummary = $ReadOnly<{uid: UID, username: String, thumbnail: String, idVersion: Int, fullName: String, bio: String, proofs: Proofs, sigIDDisplay: String, trackTime: Time}>

export type UserSummary2 = $ReadOnly<{uid: UID, username: String, thumbnail: String, fullName: String, isFollower: Boolean, isFollowee: Boolean}>

export type UserSummary2Set = $ReadOnly<{users?: ?Array<UserSummary2>, time: Time, version: Int}>

export type UserTeamShowcase = $ReadOnly<{fqName: String, open: Boolean, teamIsShowcased: Boolean, description: String, role: TeamRole, publicAdmins?: ?Array<String>, numMembers: Int}>

export type UserVersion = $ReadOnly<{uid: UID, eldestSeqno: Seqno}>

export type UserVersionPercentForm = String

export type UserVersionVector = $ReadOnly<{id: Long, sigHints: Int, sigChain: Long, cachedAt: Time}>

export type VerifySessionRes = $ReadOnly<{uid: UID, sid: String, generated: Int, lifetime: Int}>

export type WebProof = $ReadOnly<{hostname: String, protocols?: ?Array<String>}>

export type WriteArgs = $ReadOnly<{opID: OpID, path: Path, offset: Long}>
type AccountHasServerKeysResult = HasServerKeysRes
type AccountPassphrasePromptResult = GetPassphraseRes
type ApiserverDeleteResult = APIRes
type ApiserverGetResult = APIRes
type ApiserverGetWithSessionResult = APIRes
type ApiserverPostJSONResult = APIRes
type ApiserverPostResult = APIRes
type AvatarsLoadTeamAvatarsResult = LoadAvatarsRes
type AvatarsLoadUserAvatarsResult = LoadAvatarsRes
type BadgerGetBadgeStateResult = BadgeState
type BlockArchiveReferenceResult = ?Array<BlockReference>
type BlockArchiveReferenceWithCountResult = DowngradeReferenceRes
type BlockBlockPingResult = BlockPingResponse
type BlockDelReferenceWithCountResult = DowngradeReferenceRes
type BlockGetBlockResult = GetBlockRes
type BlockGetSessionChallengeResult = ChallengeInfo
type BlockGetTeamQuotaInfoResult = Bytes
type BlockGetUserQuotaInfoResult = Bytes
type ConfigCheckAPIServerOutOfDateWarningResult = OutOfDateInfo
type ConfigGetBootstrapStatusResult = BootstrapStatus
type ConfigGetConfigResult = Config
type ConfigGetCurrentStatusResult = GetCurrentStatusRes
type ConfigGetExtendedStatusResult = ExtendedStatus
type ConfigGetRememberPassphraseResult = Boolean
type ConfigGetValueResult = ConfigValue
type ConfigWaitForClientResult = Boolean
type CryptoSignED25519ForKBFSResult = ED25519SignatureInfo
type CryptoSignED25519Result = ED25519SignatureInfo
type CryptoSignToStringResult = String
type CryptoUnboxBytes32AnyResult = UnboxAnyRes
type CryptoUnboxBytes32Result = Bytes32
type CryptocurrencyRegisterAddressResult = RegisterAddressRes
type CtlDbGetResult = ?DbValue
type DebuggingFirstStepResult = FirstStepResult
type DebuggingIncrementResult = Int
type DebuggingSecondStepResult = Int
type DeviceCheckDeviceNameFormatResult = Boolean
type DeviceDeviceHistoryListResult = ?Array<DeviceDetail>
type DeviceDeviceListResult = ?Array<Device>
type FavoriteGetFavoritesResult = FavoritesResult
type FsListResult = ListResult
type GitCreatePersonalRepoResult = RepoID
type GitCreateTeamRepoResult = RepoID
type GitGetAllGitMetadataResult = ?Array<GitRepoResult>
type GitGetGitMetadataResult = ?Array<GitRepoResult>
type GitGetTeamRepoSettingsResult = GitTeamRepoSettings
type GpgUiConfirmDuplicateKeyChosenResult = Boolean
type GpgUiGetTTYResult = String
type GpgUiSelectKeyAndPushOptionResult = SelectKeyRes
type GpgUiSelectKeyResult = String
type GpgUiSignResult = String
type GpgUiWantToAddGPGKeyResult = Boolean
type GregorGetStateResult = Gregor1.State
type GregorInjectItemResult = Gregor1.MsgID
type HomeHomeGetScreenResult = HomeScreen
type IdentifyIdentify2Result = Identify2Res
type IdentifyIdentifyLiteResult = IdentifyLiteRes
type IdentifyResolve3Result = UserOrTeamLite
type IdentifyResolveIdentifyImplicitTeamResult = ResolveIdentifyImplicitTeamRes
type IdentifyResolveImplicitTeamResult = Folder
type IdentifyUiConfirmResult = ConfirmResult
type IdentifyUiDelegateIdentifyUIResult = Int
type InstallFuseStatusResult = FuseStatus
type InstallInstallCommandLinePrivilegedResult = InstallResult
type InstallInstallFuseResult = InstallResult
type InstallInstallKBFSResult = InstallResult
type InstallUninstallKBFSResult = UninstallResult
type KBFSGitCreateRepoResult = RepoID
type KbfsGetKBFSTeamSettingsResult = KBFSTeamSettings
type KbfsMountGetAllAvailableMountDirsResult = ?Array<String>
type KbfsMountGetCurrentMountDirResult = String
type Kex2Provisionee2Hello2Result = Hello2Res
type Kex2ProvisioneeHelloResult = HelloRes
type LoginGetConfiguredAccountsResult = ?Array<ConfiguredAccount>
type LoginUiGetEmailOrUsernameResult = String
type LoginUiPromptRevokePaperKeysResult = Boolean
type MerkleGetCurrentMerkleRootResult = MerkleRootAndTime
type MetadataAuthenticateResult = Int
type MetadataGetChallengeResult = ChallengeInfo
type MetadataGetFolderHandleResult = Bytes
type MetadataGetKeyBundlesResult = KeyBundleResponse
type MetadataGetKeyResult = Bytes
type MetadataGetLatestFolderHandleResult = Bytes
type MetadataGetMerkleNodeResult = Bytes
type MetadataGetMerkleRootLatestResult = MerkleRoot
type MetadataGetMerkleRootResult = MerkleRoot
type MetadataGetMerkleRootSinceResult = MerkleRoot
type MetadataGetMetadataResult = MetadataResponse
type MetadataPing2Result = PingResponse
type MetadataTruncateLockResult = Boolean
type MetadataTruncateUnlockResult = Boolean
type PgpPgpDecryptResult = PGPSigVerification
type PgpPgpExportByFingerprintResult = ?Array<KeyInfo>
type PgpPgpExportByKIDResult = ?Array<KeyInfo>
type PgpPgpExportResult = ?Array<KeyInfo>
type PgpPgpPurgeResult = PGPPurgeRes
type PgpPgpVerifyResult = PGPSigVerification
type PgpUiShouldPushPrivateResult = Boolean
type ProveCheckProofResult = CheckProofStatus
type ProveStartProofResult = StartProofResult
type ProveUiOkToCheckResult = Boolean
type ProveUiPreProofWarningResult = Boolean
type ProveUiPromptOverwriteResult = Boolean
type ProveUiPromptUsernameResult = String
type ProvisionUiChooseDeviceResult = DeviceID
type ProvisionUiChooseDeviceTypeResult = DeviceType
type ProvisionUiChooseGPGMethodResult = GPGMethod
type ProvisionUiChooseProvisioningMethodResult = ProvisionMethod
type ProvisionUiDisplayAndPromptSecretResult = SecretResponse
type ProvisionUiPromptNewDeviceNameResult = String
type ProvisionUiSwitchToGPGSignOKResult = Boolean
type QuotaVerifySessionResult = VerifySessionRes
type ReachabilityCheckReachabilityResult = Reachability
type ReachabilityStartReachabilityResult = Reachability
type RekeyGetPendingRekeyStatusResult = ProblemSetDevices
type RekeyGetRevokeWarningResult = RevokeWarning
type RekeyRekeyStatusFinishResult = Outcome
type RekeyUIDelegateRekeyUIResult = Int
type SaltpackSaltpackDecryptResult = SaltpackEncryptedMessageInfo
type SecretKeysGetSecretKeysResult = SecretKeys
type SecretUiGetPassphraseResult = GetPassphraseRes
type SessionCurrentSessionResult = Session
type SignupGetInvitationCodeResult = String
type SignupSignupResult = SignupRes
type SigsSigListJSONResult = String
type SigsSigListResult = ?Array<Sig>
type SimpleFSSimpleFSCheckResult = OpProgress
type SimpleFSSimpleFSGetOpsResult = ?Array<OpDescription>
type SimpleFSSimpleFSMakeOpidResult = OpID
type SimpleFSSimpleFSReadListResult = SimpleFSListResult
type SimpleFSSimpleFSReadResult = FileContent
type SimpleFSSimpleFSStatResult = Dirent
type StreamUiReadResult = Bytes
type StreamUiWriteResult = Int
type TeamsCanUserPerformResult = TeamOperation
type TeamsGetTarsDisabledResult = Boolean
type TeamsGetTeamAndMemberShowcaseResult = TeamAndMemberShowcase
type TeamsGetTeamRootIDResult = TeamID
type TeamsGetTeamShowcaseResult = TeamShowcase
type TeamsLoadTeamPlusApplicationKeysResult = TeamPlusApplicationKeys
type TeamsLookupImplicitTeamResult = LookupImplicitTeamRes
type TeamsLookupOrCreateImplicitTeamResult = LookupImplicitTeamRes
type TeamsTeamAcceptInviteOrRequestAccessResult = TeamAcceptOrRequestResult
type TeamsTeamAddEmailsBulkResult = BulkRes
type TeamsTeamAddMemberResult = TeamAddMemberResult
type TeamsTeamCreateResult = TeamCreateResult
type TeamsTeamCreateSeitanTokenResult = SeitanIKey
type TeamsTeamCreateSeitanTokenV2Result = SeitanIKeyV2
type TeamsTeamCreateWithSettingsResult = TeamCreateResult
type TeamsTeamDebugResult = TeamDebugRes
type TeamsTeamGetResult = TeamDetails
type TeamsTeamImplicitAdminsResult = ?Array<TeamMemberDetails>
type TeamsTeamListMyAccessRequestsResult = ?Array<TeamName>
type TeamsTeamListRequestsResult = ?Array<TeamJoinRequest>
type TeamsTeamListSubteamsRecursiveResult = ?Array<TeamIDAndName>
type TeamsTeamListTeammatesResult = AnnotatedTeamList
type TeamsTeamListUnverifiedResult = AnnotatedTeamList
type TeamsTeamListVerifiedResult = AnnotatedTeamList
type TeamsTeamRequestAccessResult = TeamRequestAccessResult
type TeamsTeamTreeResult = TeamTreeResult
type TeamsUiConfirmRootTeamDeleteResult = Boolean
type TeamsUiConfirmSubteamDeleteResult = Boolean
type TestTestCallbackResult = String
type TestTestResult = Test
type TlfCompleteAndCanonicalizePrivateTlfNameResult = CanonicalTLFNameAndIDWithBreaks
type TlfCryptKeysResult = GetTLFCryptKeysRes
type TlfKeysGetPublicCanonicalTLFNameAndIDResult = CanonicalTLFNameAndIDWithBreaks
type TlfKeysGetTLFCryptKeysResult = GetTLFCryptKeysRes
type TlfPublicCanonicalTLFNameAndIDResult = CanonicalTLFNameAndIDWithBreaks
type TrackTrackResult = ConfirmResult
type UiPromptYesNoResult = Boolean
type UserGetUPAKResult = UPAKVersioned
type UserInterestingPeopleResult = ?Array<InterestingPerson>
type UserListTrackers2Result = UserSummary2Set
type UserListTrackersByNameResult = ?Array<Tracker>
type UserListTrackersResult = ?Array<Tracker>
type UserListTrackersSelfResult = ?Array<Tracker>
type UserListTrackingJSONResult = String
type UserListTrackingResult = ?Array<UserSummary>
type UserLoadAllPublicKeysUnverifiedResult = ?Array<PublicKey>
type UserLoadMyPublicKeysResult = ?Array<PublicKey>
type UserLoadMySettingsResult = UserSettings
type UserLoadPublicKeysResult = ?Array<PublicKey>
type UserLoadUncheckedUserSummariesResult = ?Array<UserSummary>
type UserLoadUserByNameResult = User
type UserLoadUserPlusKeysResult = UserPlusKeys
type UserLoadUserPlusKeysV2Result = UserPlusKeysV2AllIncarnations
type UserLoadUserResult = User
type UserMeUserVersionResult = UserVersion
type UserSearchResult = ?Array<SearchResult>

export type IncomingCallMapType = {
  'keybase.1.gpgUi.wantToAddGPGKey'?: (params: $ReadOnly<{sessionID: Int}>, response: {error: RPCErrorHandler, result: (result: GpgUiWantToAddGPGKeyResult) => void}) => void,
  'keybase.1.gpgUi.confirmDuplicateKeyChosen'?: (params: $ReadOnly<{sessionID: Int}>, response: {error: RPCErrorHandler, result: (result: GpgUiConfirmDuplicateKeyChosenResult) => void}) => void,
  'keybase.1.gpgUi.selectKeyAndPushOption'?: (params: $ReadOnly<{sessionID: Int, keys?: ?Array<GPGKey>}>, response: {error: RPCErrorHandler, result: (result: GpgUiSelectKeyAndPushOptionResult) => void}) => void,
  'keybase.1.gpgUi.selectKey'?: (params: $ReadOnly<{sessionID: Int, keys?: ?Array<GPGKey>}>, response: {error: RPCErrorHandler, result: (result: GpgUiSelectKeyResult) => void}) => void,
  'keybase.1.gpgUi.sign'?: (params: $ReadOnly<{msg: Bytes, fingerprint: Bytes}>, response: {error: RPCErrorHandler, result: (result: GpgUiSignResult) => void}) => void,
  'keybase.1.gpgUi.getTTY'?: (params: $ReadOnly<{}>, response: {error: RPCErrorHandler, result: (result: GpgUiGetTTYResult) => void}) => void,
  'keybase.1.gregorUI.pushState'?: (params: $ReadOnly<{state: Gregor1.State, reason: PushReason}>, response: CommonResponseHandler) => void,
  'keybase.1.gregorUI.pushOutOfBandMessages'?: (params: $ReadOnly<{oobm?: ?Array<Gregor1.OutOfBandMessage>}>, response: CommonResponseHandler) => void,
  'keybase.1.homeUI.homeUIRefresh'?: (params: $ReadOnly<{}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.displayTLFCreateWithInvite'?: (params: $ReadOnly<{sessionID: Int, folderName: String, isPrivate: Boolean, assertion: String, socialAssertion: SocialAssertion, inviteLink: String, throttled: Boolean}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.delegateIdentifyUI'?: (params: $ReadOnly<{}>, response: {error: RPCErrorHandler, result: (result: IdentifyUiDelegateIdentifyUIResult) => void}) => void,
  'keybase.1.identifyUi.start'?: (params: $ReadOnly<{sessionID: Int, username: String, reason: IdentifyReason, forceDisplay?: Boolean}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.displayKey'?: (params: $ReadOnly<{sessionID: Int, key: IdentifyKey}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.reportLastTrack'?: (params: $ReadOnly<{sessionID: Int, track?: ?TrackSummary}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.launchNetworkChecks'?: (params: $ReadOnly<{sessionID: Int, identity: Identity, user: User}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.displayTrackStatement'?: (params: $ReadOnly<{sessionID: Int, stmt: String}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.finishWebProofCheck'?: (params: $ReadOnly<{sessionID: Int, rp: RemoteProof, lcr: LinkCheckResult}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.finishSocialProofCheck'?: (params: $ReadOnly<{sessionID: Int, rp: RemoteProof, lcr: LinkCheckResult}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.displayCryptocurrency'?: (params: $ReadOnly<{sessionID: Int, c: Cryptocurrency}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.reportTrackToken'?: (params: $ReadOnly<{sessionID: Int, trackToken: TrackToken}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.displayUserCard'?: (params: $ReadOnly<{sessionID: Int, card: UserCard}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.confirm'?: (params: $ReadOnly<{sessionID: Int, outcome: IdentifyOutcome}>, response: {error: RPCErrorHandler, result: (result: IdentifyUiConfirmResult) => void}) => void,
  'keybase.1.identifyUi.cancel'?: (params: $ReadOnly<{sessionID: Int}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.finish'?: (params: $ReadOnly<{sessionID: Int}>, response: CommonResponseHandler) => void,
  'keybase.1.identifyUi.dismiss'?: (params: $ReadOnly<{sessionID: Int, username: String, reason: DismissReason}>, response: CommonResponseHandler) => void,
  'keybase.1.logUi.log'?: (params: $ReadOnly<{sessionID: Int, level: LogLevel, text: Text}>, response: CommonResponseHandler) => void,
  'keybase.1.loginUi.getEmailOrUsername'?: (params: $ReadOnly<{sessionID: Int}>, response: {error: RPCErrorHandler, result: (result: LoginUiGetEmailOrUsernameResult) => void}) => void,
  'keybase.1.loginUi.promptRevokePaperKeys'?: (params: $ReadOnly<{sessionID: Int, device: Device, index: Int}>, response: {error: RPCErrorHandler, result: (result: LoginUiPromptRevokePaperKeysResult) => void}) => void,
  'keybase.1.loginUi.displayPaperKeyPhrase'?: (params: $ReadOnly<{sessionID: Int, phrase: String}>, response: CommonResponseHandler) => void,
  'keybase.1.loginUi.displayPrimaryPaperKey'?: (params: $ReadOnly<{sessionID: Int, phrase: String}>, response: CommonResponseHandler) => void,
  'keybase.1.logsend.prepareLogsend'?: (params: $ReadOnly<{}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyApp.exit'?: (params: $ReadOnly<{}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyBadges.badgeState'?: (params: $ReadOnly<{badgeState: BadgeState}>) => void,
  'keybase.1.NotifyFavorites.favoritesChanged'?: (params: $ReadOnly<{uid: UID}>) => void,
  'keybase.1.NotifyFS.FSActivity'?: (params: $ReadOnly<{notification: FSNotification}>) => void,
  'keybase.1.NotifyFS.FSSyncActivity'?: (params: $ReadOnly<{status: FSPathSyncStatus}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyFS.FSEditListResponse'?: (params: $ReadOnly<{edits?: ?Array<FSNotification>, requestID: Int}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyFS.FSSyncStatusResponse'?: (params: $ReadOnly<{status: FSSyncStatus, requestID: Int}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyKeyfamily.keyfamilyChanged'?: (params: $ReadOnly<{uid: UID}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyPaperKey.paperKeyCached'?: (params: $ReadOnly<{uid: UID, encKID: KID, sigKID: KID}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyPGP.pgpKeyInSecretStoreFile'?: (params: $ReadOnly<{}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyService.shutdown'?: (params: $ReadOnly<{}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifySession.loggedOut'?: (params: $ReadOnly<{}>) => void,
  'keybase.1.NotifySession.loggedIn'?: (params: $ReadOnly<{username: String}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifySession.clientOutOfDate'?: (params: $ReadOnly<{upgradeTo: String, upgradeURI: String, upgradeMsg: String}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyTeam.teamChangedByID'?: (params: $ReadOnly<{teamID: TeamID, latestSeqno: Seqno, implicitTeam: Boolean, changes: TeamChangeSet}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyTeam.teamChangedByName'?: (params: $ReadOnly<{teamName: String, latestSeqno: Seqno, implicitTeam: Boolean, changes: TeamChangeSet}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyTeam.teamDeleted'?: (params: $ReadOnly<{teamID: TeamID}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyTeam.teamAbandoned'?: (params: $ReadOnly<{teamID: TeamID}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyTeam.teamExit'?: (params: $ReadOnly<{teamID: TeamID}>, response: CommonResponseHandler) => void,
  'keybase.1.NotifyTracking.trackingChanged'?: (params: $ReadOnly<{uid: UID, username: String, isTracking: Boolean}>) => void,
  'keybase.1.NotifyUsers.userChanged'?: (params: $ReadOnly<{uid: UID}>) => void,
  'keybase.1.pgpUi.outputSignatureSuccess'?: (params: $ReadOnly<{sessionID: Int, fingerprint: String, username: String, signedAt: Time}>, response: CommonResponseHandler) => void,
  'keybase.1.pgpUi.outputSignatureSuccessNonKeybase'?: (params: $ReadOnly<{sessionID: Int, keyID: String, signedAt: Time}>, response: CommonResponseHandler) => void,
  'keybase.1.pgpUi.keyGenerated'?: (params: $ReadOnly<{sessionID: Int, kid: KID, key: KeyInfo}>, response: CommonResponseHandler) => void,
  'keybase.1.pgpUi.shouldPushPrivate'?: (params: $ReadOnly<{sessionID: Int}>, response: {error: RPCErrorHandler, result: (result: PgpUiShouldPushPrivateResult) => void}) => void,
  'keybase.1.pgpUi.finished'?: (params: $ReadOnly<{sessionID: Int}>, response: CommonResponseHandler) => void,
  'keybase.1.proveUi.promptOverwrite'?: (params: $ReadOnly<{sessionID: Int, account: String, typ: PromptOverwriteType}>, response: {error: RPCErrorHandler, result: (result: ProveUiPromptOverwriteResult) => void}) => void,
  'keybase.1.proveUi.promptUsername'?: (params: $ReadOnly<{sessionID: Int, prompt: String, prevError?: ?Status}>, response: {error: RPCErrorHandler, result: (result: ProveUiPromptUsernameResult) => void}) => void,
  'keybase.1.proveUi.outputPrechecks'?: (params: $ReadOnly<{sessionID: Int, text: Text}>, response: CommonResponseHandler) => void,
  'keybase.1.proveUi.preProofWarning'?: (params: $ReadOnly<{sessionID: Int, text: Text}>, response: {error: RPCErrorHandler, result: (result: ProveUiPreProofWarningResult) => void}) => void,
  'keybase.1.proveUi.outputInstructions'?: (params: $ReadOnly<{sessionID: Int, instructions: Text, proof: String}>, response: CommonResponseHandler) => void,
  'keybase.1.proveUi.okToCheck'?: (params: $ReadOnly<{sessionID: Int, name: String, attempt: Int}>, response: {error: RPCErrorHandler, result: (result: ProveUiOkToCheckResult) => void}) => void,
  'keybase.1.proveUi.displayRecheckWarning'?: (params: $ReadOnly<{sessionID: Int, text: Text}>, response: CommonResponseHandler) => void,
  'keybase.1.provisionUi.chooseProvisioningMethod'?: (params: $ReadOnly<{sessionID: Int, gpgOption: Boolean}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiChooseProvisioningMethodResult) => void}) => void,
  'keybase.1.provisionUi.chooseGPGMethod'?: (params: $ReadOnly<{sessionID: Int, keys?: ?Array<GPGKey>}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiChooseGPGMethodResult) => void}) => void,
  'keybase.1.provisionUi.switchToGPGSignOK'?: (params: $ReadOnly<{sessionID: Int, key: GPGKey, importError: String}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiSwitchToGPGSignOKResult) => void}) => void,
  'keybase.1.provisionUi.chooseDevice'?: (params: $ReadOnly<{sessionID: Int, devices?: ?Array<Device>, canSelectNoDevice: Boolean}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiChooseDeviceResult) => void}) => void,
  'keybase.1.provisionUi.chooseDeviceType'?: (params: $ReadOnly<{sessionID: Int, kind: ChooseType}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiChooseDeviceTypeResult) => void}) => void,
  'keybase.1.provisionUi.DisplayAndPromptSecret'?: (params: $ReadOnly<{sessionID: Int, secret: Bytes, phrase: String, otherDeviceType: DeviceType, previousErr: String}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiDisplayAndPromptSecretResult) => void}) => void,
  'keybase.1.provisionUi.DisplaySecretExchanged'?: (params: $ReadOnly<{sessionID: Int}>, response: CommonResponseHandler) => void,
  'keybase.1.provisionUi.PromptNewDeviceName'?: (params: $ReadOnly<{sessionID: Int, existingDevices?: ?Array<String>, errorMessage: String}>, response: {error: RPCErrorHandler, result: (result: ProvisionUiPromptNewDeviceNameResult) => void}) => void,
  'keybase.1.provisionUi.ProvisioneeSuccess'?: (params: $ReadOnly<{sessionID: Int, username: String, deviceName: String}>, response: CommonResponseHandler) => void,
  'keybase.1.provisionUi.ProvisionerSuccess'?: (params: $ReadOnly<{sessionID: Int, deviceName: String, deviceType: String}>, response: CommonResponseHandler) => void,
  'keybase.1.rekeyUI.delegateRekeyUI'?: (params: $ReadOnly<{}>, response: {error: RPCErrorHandler, result: (result: RekeyUIDelegateRekeyUIResult) => void}) => void,
  'keybase.1.rekeyUI.refresh'?: (params: $ReadOnly<{sessionID: Int, problemSetDevices: ProblemSetDevices}>, response: CommonResponseHandler) => void,
  'keybase.1.rekeyUI.rekeySendEvent'?: (params: $ReadOnly<{sessionID: Int, event: RekeyEvent}>, response: CommonResponseHandler) => void,
  'keybase.1.saltpackUi.saltpackPromptForDecrypt'?: (params: $ReadOnly<{sessionID: Int, sender: SaltpackSender, usedDelegateUI: Boolean}>, response: CommonResponseHandler) => void,
  'keybase.1.saltpackUi.saltpackVerifySuccess'?: (params: $ReadOnly<{sessionID: Int, signingKID: KID, sender: SaltpackSender}>, response: CommonResponseHandler) => void,
  'keybase.1.saltpackUi.saltpackVerifyBadSender'?: (params: $ReadOnly<{sessionID: Int, signingKID: KID, sender: SaltpackSender}>, response: CommonResponseHandler) => void,
  'keybase.1.secretUi.getPassphrase'?: (params: $ReadOnly<{sessionID: Int, pinentry: GUIEntryArg, terminal?: ?SecretEntryArg}>, response: {error: RPCErrorHandler, result: (result: SecretUiGetPassphraseResult) => void}) => void,
  'keybase.1.streamUi.close'?: (params: $ReadOnly<{sessionID: Int, s: Stream}>, response: CommonResponseHandler) => void,
  'keybase.1.streamUi.read'?: (params: $ReadOnly<{sessionID: Int, s: Stream, sz: Int}>, response: {error: RPCErrorHandler, result: (result: StreamUiReadResult) => void}) => void,
  'keybase.1.streamUi.reset'?: (params: $ReadOnly<{sessionID: Int, s: Stream}>, response: CommonResponseHandler) => void,
  'keybase.1.streamUi.write'?: (params: $ReadOnly<{sessionID: Int, s: Stream, buf: Bytes}>, response: {error: RPCErrorHandler, result: (result: StreamUiWriteResult) => void}) => void,
  'keybase.1.teamsUi.confirmRootTeamDelete'?: (params: $ReadOnly<{sessionID: Int, teamName: String}>, response: {error: RPCErrorHandler, result: (result: TeamsUiConfirmRootTeamDeleteResult) => void}) => void,
  'keybase.1.teamsUi.confirmSubteamDelete'?: (params: $ReadOnly<{sessionID: Int, teamName: String}>, response: {error: RPCErrorHandler, result: (result: TeamsUiConfirmSubteamDeleteResult) => void}) => void,
  'keybase.1.ui.promptYesNo'?: (params: $ReadOnly<{sessionID: Int, text: Text, promptDefault: PromptDefault}>, response: {error: RPCErrorHandler, result: (result: UiPromptYesNoResult) => void}) => void,
}

// @noflow // not using flow at all
/* eslint-disable */

// This file is auto-generated by client/protocol/Makefile.
// Not enabled: calls need to be turned on in enabled-calls.json
import {call} from 'redux-saga/effects'
import {getEngine as engine, getEngineSaga} from '../../engine/require'

export const appStateAppState = {
  foreground: 0,
  background: 1,
  inactive: 2,
  backgroundactive: 3,
}

export const backendCommonBlockType = {
  data: 0,
  md: 1,
  git: 2,
}

export const blockBlockStatus = {
  unknown: 0,
  live: 1,
  archived: 2,
}

export const commonClientType = {
  none: 0,
  cli: 1,
  guiMain: 2,
  kbfs: 3,
  guiHelper: 4,
}

export const commonDeviceType = {
  desktop: 0,
  mobile: 1,
}

export const commonFullNamePackageVersion = {
  v0: 0,
  v1: 1,
  v2: 2,
}

export const commonLogLevel = {
  none: 0,
  debug: 1,
  info: 2,
  notice: 3,
  warn: 4,
  error: 5,
  critical: 6,
  fatal: 7,
}

export const commonMerkleTreeID = {
  master: 0,
  kbfsPublic: 1,
  kbfsPrivate: 2,
  kbfsPrivateteam: 3,
}

export const commonSeqType = {
  none: 0,
  public: 1,
  private: 2,
  semiprivate: 3,
}

export const commonTLFVisibility = {
  any: 0,
  public: 1,
  private: 2,
}

export const commonTeamType = {
  none: 0,
  legacy: 1,
  modern: 2,
}

export const commonUserOrTeamResult = {
  user: 1,
  team: 2,
}

export const configForkType = {
  none: 0,
  auto: 1,
  watchdog: 2,
  launchd: 3,
  systemd: 4,
}

export const constantsStatusCode = {
  scok: 0,
  scinputerror: 100,
  scloginrequired: 201,
  scbadsession: 202,
  scbadloginusernotfound: 203,
  scbadloginpassword: 204,
  scnotfound: 205,
  scthrottlecontrol: 210,
  scdeleted: 216,
  scgeneric: 218,
  scalreadyloggedin: 235,
  scexists: 230,
  sccanceled: 237,
  scinputcanceled: 239,
  screloginrequired: 274,
  scresolutionfailed: 275,
  scprofilenotpublic: 276,
  scidentifyfailed: 277,
  sctrackingbroke: 278,
  scwrongcryptoformat: 279,
  scdecryptionerror: 280,
  scinvalidaddress: 281,
  scnosession: 283,
  scaccountreset: 290,
  scidentifiesfailed: 295,
  scnospaceondevice: 297,
  scmerkleclienterror: 299,
  scbademail: 472,
  scbadsignupusernametaken: 701,
  scbadinvitationcode: 707,
  scmissingresult: 801,
  sckeynotfound: 901,
  sckeycorrupted: 905,
  sckeyinuse: 907,
  sckeybadgen: 913,
  sckeynosecret: 914,
  sckeybaduids: 915,
  sckeynoactive: 916,
  sckeynosig: 917,
  sckeybadsig: 918,
  sckeybadeldest: 919,
  sckeynoeldest: 920,
  sckeyduplicateupdate: 921,
  scsibkeyalreadyexists: 922,
  scdecryptionkeynotfound: 924,
  sckeynopgpencryption: 927,
  sckeynonaclencryption: 928,
  sckeysyncedpgpnotfound: 929,
  sckeynomatchinggpg: 930,
  sckeyrevoked: 931,
  scsigcannotverify: 1002,
  scsigwrongkey: 1008,
  scsigoldseqno: 1010,
  scbadtracksession: 1301,
  scdevicebadname: 1404,
  scdevicenameinuse: 1408,
  scdevicenotfound: 1409,
  scdevicemismatch: 1410,
  scdevicerequired: 1411,
  scdeviceprevprovisioned: 1413,
  scdevicenoprovision: 1414,
  scdeviceprovisionviadevice: 1415,
  screvokecurrentdevice: 1416,
  screvokelastdevice: 1417,
  scdeviceprovisionoffline: 1418,
  screvokelastdevicepgp: 1419,
  scstreamexists: 1501,
  scstreamnotfound: 1502,
  scstreamwrongkind: 1503,
  scstreameof: 1504,
  scgenericapierror: 1600,
  scapinetworkerror: 1601,
  sctimeout: 1602,
  scprooferror: 1701,
  scidentificationexpired: 1702,
  scselfnotfound: 1703,
  scbadkexphrase: 1704,
  scnouidelegation: 1705,
  scnoui: 1706,
  scgpgunavailable: 1707,
  scinvalidversionerror: 1800,
  scoldversionerror: 1801,
  scinvalidlocationerror: 1802,
  scservicestatuserror: 1803,
  scinstallerror: 1804,
  scloadkexterror: 1810,
  scloadkextpermerror: 1811,
  scgitinternal: 2300,
  scgitrepoalreadyexists: 2301,
  scgitinvalidreponame: 2302,
  scgitcannotdelete: 2303,
  scgitrepodoesntexist: 2304,
  scloginstatetimeout: 2400,
  scchatinternal: 2500,
  scchatratelimit: 2501,
  scchatconvexists: 2502,
  scchatunknowntlfid: 2503,
  scchatnotinconv: 2504,
  scchatbadmsg: 2505,
  scchatbroadcast: 2506,
  scchatalreadysuperseded: 2507,
  scchatalreadydeleted: 2508,
  scchattlffinalized: 2509,
  scchatcollision: 2510,
  scidentifysummaryerror: 2511,
  scneedselfrekey: 2512,
  scneedotherrekey: 2513,
  scchatmessagecollision: 2514,
  scchatduplicatemessage: 2515,
  scchatclienterror: 2516,
  scchatnotinteam: 2517,
  scchatstalepreviousstate: 2518,
  scteambadmembership: 2604,
  scteamselfnotowner: 2607,
  scteamnotfound: 2614,
  scteamexists: 2619,
  scteamreaderror: 2623,
  scteamwritepermdenied: 2625,
  scnoop: 2638,
  scteaminvitebadtoken: 2646,
  scteamtarduplicate: 2663,
  scteamtarnotfound: 2664,
  scteammemberexists: 2665,
  scteamnotreleased: 2666,
  scteampermanentlyleft: 2667,
  scteamneedrootid: 2668,
  scteamhaslivechildren: 2669,
  scteamdeleteerror: 2670,
  scteambadrootteam: 2671,
  scteamnameconflictswithuser: 2672,
  scteamdeletenouppointer: 2673,
  scteamneedowner: 2674,
  scteamnoownerallowed: 2675,
  scteamimplicitnononsbs: 2676,
  scteamimplicitbadhash: 2677,
  scteamimplicitbadname: 2678,
  scteamimplicitclash: 2679,
  scteamimplicitduplicate: 2680,
  scteamimplicitbadop: 2681,
  scteamimplicitbadrole: 2682,
  scteamimplicitnotfound: 2683,
  scteambadadminseqnotype: 2684,
  scteamimplicitbadadd: 2685,
  scteamimplicitbadremove: 2686,
  scteaminvitetokenreused: 2696,
  scteamkeymasknotfound: 2697,
  scteambanned: 2702,
  scteaminvalidban: 2703,
  scteamshowcasepermdenied: 2711,
  scteamprovisionalcankey: 2721,
  scteamprovisionalcannotkey: 2722,
  scteamftloutdated: 2736,
  scephemeralkeybadgeneration: 2900,
  scephemeralkeyunexpectedbox: 2901,
  scephemeralkeymissingbox: 2902,
  scephemeralkeywrongnumberofkeys: 2903,
  scephemeralkeymismatchedkey: 2904,
  scephemeralpairwisemacsmissinguids: 2905,
  scstellarerror: 3100,
  scstellarbadinput: 3101,
  scstellarwrongrevision: 3102,
  scstellarmissingbundle: 3103,
  scstellarbadpuk: 3104,
  scstellarmissingaccount: 3105,
  scstellarbadprev: 3106,
  scstellarwrongprimary: 3107,
  scstellarunsupportedcurrency: 3108,
  scnistwrongsize: 3201,
  scnistbadmode: 3202,
  scnisthashwrongsize: 3203,
  scnistsigwrongsize: 3204,
  scnistsigbadinput: 3205,
  scnistsigbaduid: 3206,
  scnistsigbaddeviceid: 3207,
  scnistsigbadnonce: 3208,
  scnistnosigorhash: 3209,
  scnistexpired: 3210,
  scnistsigrevoked: 3211,
  scnistkeyrevoked: 3212,
  scnistuserdeleted: 3213,
  scnistnodevice: 3214,
  scnistsigcannotVerify: 3215,
  scnistreplay: 3216,
  scnistsigbadlifetime: 3217,
  scnistnotfound: 3218,
  scnistbadclock: 3219,
  scnistsigbadctime: 3220,
  scbadsignupusernamedeleted: 3221,
}

export const ctlDbType = {
  main: 0,
  chat: 1,
}

export const ctlExitCode = {
  ok: 0,
  notok: 2,
  restart: 4,
}

export const favoriteFolderType = {
  unknown: 0,
  private: 1,
  public: 2,
  team: 3,
}

export const gitGitLocalMetadataVersion = {
  v1: 1,
}

export const gitGitPushType = {
  default: 0,
  createrepo: 1,
  renamerepo: 3,
}

export const gitGitRepoResultState = {
  err: 0,
  ok: 1,
}

export const gregorUIPushReason = {
  none: 0,
  reconnected: 1,
  newData: 2,
}

export const homeHomeScreenItemType = {
  todo: 1,
  people: 2,
}

export const homeHomeScreenPeopleNotificationType = {
  followed: 1,
  followedMulti: 2,
}

export const homeHomeScreenTodoType = {
  none: 0,
  bio: 1,
  proof: 2,
  device: 3,
  follow: 4,
  chat: 5,
  paperkey: 6,
  team: 7,
  folder: 8,
  gitRepo: 9,
  teamShowcase: 10,
  avatarUser: 11,
  avatarTeam: 12,
}

export const identifyCommonIdentifyReasonType = {
  none: 0,
  id: 1,
  track: 2,
  encrypt: 3,
  decrypt: 4,
  verify: 5,
  resource: 6,
  background: 7,
}

export const identifyCommonTrackDiffType = {
  none: 0,
  error: 1,
  clash: 2,
  revoked: 3,
  upgraded: 4,
  new: 5,
  remoteFail: 6,
  remoteWorking: 7,
  remoteChanged: 8,
  newEldest: 9,
  noneViaTemporary: 10,
}

export const identifyCommonTrackStatus = {
  newOk: 1,
  newZeroProofs: 2,
  newFailProofs: 3,
  updateBrokenFailedProofs: 4,
  updateNewProofs: 5,
  updateOk: 6,
  updateBrokenRevoked: 7,
}

export const identifyUiCheckResultFreshness = {
  fresh: 0,
  aged: 1,
  rancid: 2,
}

export const identifyUiDismissReasonType = {
  none: 0,
  handledElsewhere: 1,
}

export const installInstallAction = {
  unknown: 0,
  none: 1,
  upgrade: 2,
  reinstall: 3,
  install: 4,
}

export const installInstallStatus = {
  unknown: 0,
  error: 1,
  notInstalled: 2,
  installed: 4,
}

export const kbfsCommonFSErrorType = {
  accessDenied: 0,
  userNotFound: 1,
  revokedDataDetected: 2,
  notLoggedIn: 3,
  timeout: 4,
  rekeyNeeded: 5,
  badFolder: 6,
  notImplemented: 7,
  oldVersion: 8,
  overQuota: 9,
  noSigChain: 10,
  tooManyFolders: 11,
  exdevNotSupported: 12,
  diskLimitReached: 13,
  diskCacheErrorLogSend: 14,
}

export const kbfsCommonFSNotificationType = {
  encrypting: 0,
  decrypting: 1,
  signing: 2,
  verifying: 3,
  rekeying: 4,
  connection: 5,
  mdReadSuccess: 6,
  fileCreated: 7,
  fileModified: 8,
  fileDeleted: 9,
  fileRenamed: 10,
  initialized: 11,
}

export const kbfsCommonFSStatusCode = {
  start: 0,
  finish: 1,
  error: 2,
}

export const passphraseCommonPassphraseType = {
  none: 0,
  paperKey: 1,
  passPhrase: 2,
  verifyPassPhrase: 3,
}

export const pgpSignMode = {
  attached: 0,
  detached: 1,
  clear: 2,
}

export const processFileType = {
  unknown: 0,
  directory: 1,
  file: 2,
}

export const proveCommonProofState = {
  none: 0,
  ok: 1,
  tempFailure: 2,
  permFailure: 3,
  looking: 4,
  superseded: 5,
  posted: 6,
  revoked: 7,
  deleted: 8,
  unknownType: 9,
  sigHintMissing: 10,
  unchecked: 11,
}

export const proveCommonProofStatus = {
  none: 0,
  ok: 1,
  local: 2,
  found: 3,
  baseError: 100,
  hostUnreachable: 101,
  permissionDenied: 103,
  failedParse: 106,
  dnsError: 107,
  authFailed: 108,
  http429: 129,
  http500: 150,
  timeout: 160,
  internalError: 170,
  unchecked: 171,
  missingPvl: 172,
  baseHardError: 200,
  notFound: 201,
  contentFailure: 202,
  badUsername: 203,
  badRemoteId: 204,
  textNotFound: 205,
  badArgs: 206,
  contentMissing: 207,
  titleNotFound: 208,
  serviceError: 209,
  torSkipped: 210,
  torIncompatible: 211,
  http300: 230,
  http400: 240,
  httpOther: 260,
  emptyJson: 270,
  deleted: 301,
  serviceDead: 302,
  badSignature: 303,
  badApiUrl: 304,
  unknownType: 305,
  noHint: 306,
  badHintText: 307,
  invalidPvl: 308,
}

export const proveCommonProofType = {
  none: 0,
  keybase: 1,
  twitter: 2,
  github: 3,
  reddit: 4,
  coinbase: 5,
  hackernews: 6,
  facebook: 8,
  genericWebSite: 1000,
  dns: 1001,
  pgp: 1002,
  rooter: 100001,
}

export const proveUiPromptOverwriteType = {
  social: 0,
  site: 1,
}

export const provisionUiChooseType = {
  existingDevice: 0,
  newDevice: 1,
}

export const provisionUiGPGMethod = {
  gpgNone: 0,
  gpgImport: 1,
  gpgSign: 2,
}

export const provisionUiProvisionMethod = {
  device: 0,
  paperKey: 1,
  passphrase: 2,
  gpgImport: 3,
  gpgSign: 4,
}

export const reachabilityReachable = {
  unknown: 0,
  yes: 1,
  no: 2,
}

export const rekeyOutcome = {
  none: 0,
  fixed: 1,
  ignored: 2,
}

export const rekeyUIRekeyEventType = {
  none: 0,
  notLoggedIn: 1,
  apiError: 2,
  noProblems: 3,
  loadMeError: 4,
  currentDeviceCanRekey: 5,
  deviceLoadError: 6,
  harass: 7,
  noGregorMessages: 8,
}

export const resetResetType = {
  none: 0,
  reset: 1,
  delete: 2,
}

export const saltpackAuthenticityType = {
  signed: 0,
  repudiable: 1,
  anonymous: 2,
}

export const saltpackUiSaltpackSenderType = {
  notTracked: 0,
  unknown: 1,
  anonymous: 2,
  trackingBroke: 3,
  trackingOk: 4,
  self: 5,
  revoked: 6,
  expired: 7,
}

export const simpleFSAsyncOps = {
  list: 0,
  listRecursive: 1,
  read: 2,
  write: 3,
  copy: 4,
  move: 5,
  remove: 6,
  listRecursiveToDepth: 7,
  getRevisions: 8,
}

export const simpleFSDirentType = {
  file: 0,
  dir: 1,
  sym: 2,
  exec: 3,
}

export const simpleFSKBFSArchivedType = {
  revision: 0,
  time: 1,
  timeString: 2,
  relTimeString: 3,
}

export const simpleFSListFilter = {
  noFilter: 0,
  filterAllHidden: 1,
}

export const simpleFSOpenFlags = {
  read: 0,
  replace: 1,
  existing: 2,
  write: 4,
  append: 8,
  directory: 16,
}

export const simpleFSPathType = {
  local: 0,
  kbfs: 1,
  kbfsArchived: 2,
}

export const simpleFSRevisionSpanType = {
  default: 0,
  lastFive: 1,
}

export const teamsSeitanKeyAndLabelVersion = {
  v1: 1,
  v2: 2,
}

export const teamsSeitanKeyLabelType = {
  sms: 1,
}

export const teamsTeamApplication = {
  kbfs: 1,
  chat: 2,
  saltpack: 3,
  gitMetadata: 4,
  seitanInviteToken: 5,
  stellarRelay: 6,
}

export const teamsTeamInviteCategory = {
  none: 0,
  unknown: 1,
  keybase: 2,
  email: 3,
  sbs: 4,
  seitan: 5,
}

export const teamsTeamMemberStatus = {
  active: 0,
  reset: 1,
  deleted: 2,
}

export const teamsTeamRole = {
  none: 0,
  reader: 1,
  writer: 2,
  admin: 3,
  owner: 4,
}

export const teamsTeamStatus = {
  none: 0,
  live: 1,
  deleted: 2,
  abandoned: 3,
}

export const tlfKeysTLFIdentifyBehavior = {
  unset: 0,
  chatCli: 1,
  chatGui: 2,
  chatGuiStrict: 3,
  kbfsRekey: 4,
  kbfsQr: 5,
  chatSkip: 6,
  saltpack: 7,
  cli: 8,
  gui: 9,
  defaultKbfs: 10,
  kbfsChat: 11,
  resolveAndCheck: 12,
}

export const uPKKeyType = {
  none: 0,
  nacl: 1,
  pgp: 2,
}

export const uPKUPAKVersion = {
  v1: 1,
  v2: 2,
}

export const uPKUPK2MinorVersion = {
  v0: 0,
  v1: 1,
  v2: 2,
  v3: 3,
  v4: 4,
  v5: 5,
  v6: 6,
}

export const uiPromptDefault = {
  none: 0,
  yes: 1,
  no: 2,
}
export const SimpleFSSimpleFSCancelRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCancel', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const SimpleFSSimpleFSCheckRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCheck', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSCopyRecursiveRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCopyRecursive', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const SimpleFSSimpleFSGetHTTPAddressAndTokenRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.SimpleFSGetHTTPAddressAndToken', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSListRecursiveToDepthRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSListRecursiveToDepth', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const SimpleFSSimpleFSListRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSList', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const SimpleFSSimpleFSOpenRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSOpen', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const SimpleFSSimpleFSReadListRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSReadList', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSStatRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSStat', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSSyncStatusRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSSyncStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSWaitRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSWait', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const accountEmailChangeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.emailChange', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const accountGetLockdownModeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.getLockdownMode', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountHasServerKeysRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.hasServerKeys', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountPassphraseChangeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.passphraseChange', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const accountSetLockdownModeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.setLockdownMode', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const apiserverDeleteRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.Delete', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverGetRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.Get', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverGetWithSessionRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.GetWithSession', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverPostJSONRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.PostJSON', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverPostRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.Post', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const avatarsLoadTeamAvatarsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.avatars.loadTeamAvatars', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const avatarsLoadUserAvatarsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.avatars.loadUserAvatars', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetAllProvisionedUsernamesRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getAllProvisionedUsernames', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetBootstrapStatusRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getBootstrapStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetConfigRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getConfig', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetRememberPassphraseRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getRememberPassphrase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configHelloIAmRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.helloIAm', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const configSetRememberPassphraseRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.setRememberPassphrase', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const configWaitForClientRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.waitForClient', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const cryptocurrencyRegisterAddressRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.cryptocurrency.registerAddress', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const ctlDbNukeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.ctl.dbNuke', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const delegateUiCtlRegisterGregorFirehoseFilteredRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerGregorFirehoseFiltered', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const delegateUiCtlRegisterHomeUIRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerHomeUI', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const delegateUiCtlRegisterIdentifyUIRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerIdentifyUI', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const delegateUiCtlRegisterRekeyUIRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerRekeyUI', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const delegateUiCtlRegisterSecretUIRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerSecretUI', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const deviceCheckDeviceNameFormatRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.device.checkDeviceNameFormat', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const deviceDeviceAddRpcSaga = (p, incomingCallMap, waitingKey) => call(getEngineSaga(), {method: 'keybase.1.device.deviceAdd', params: p.params, incomingCallMap: p.incomingCallMap, waitingKey: p.waitingKey})
export const deviceDeviceHistoryListRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.device.deviceHistoryList', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const favoriteFavoriteAddRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.favorite.favoriteAdd', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const favoriteFavoriteIgnoreRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.favorite.favoriteIgnore', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const gitCreatePersonalRepoRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.createPersonalRepo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitCreateTeamRepoRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.createTeamRepo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitDeletePersonalRepoRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.deletePersonalRepo', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const gitDeleteTeamRepoRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.deleteTeamRepo', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const gitGetAllGitMetadataRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.getAllGitMetadata', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitGetGitMetadataRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.getGitMetadata', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitSetTeamRepoSettingsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.setTeamRepoSettings', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const gregorDismissCategoryRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.dismissCategory', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const gregorDismissItemRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.dismissItem', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const gregorGetStateRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.getState', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorInjectItemRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.injectItem', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorUpdateCategoryRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.updateCategory', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorUpdateItemRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.updateItem', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const homeHomeGetScreenRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeGetScreen', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const homeHomeMarkViewedRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeMarkViewed', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const homeHomeSkipTodoTypeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeSkipTodoType', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const identifyIdentify2RpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.identify.identify2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installFuseStatusRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.fuseStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installInstallFuseRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.installFuse', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installInstallKBFSRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.installKBFS', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installUninstallKBFSRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.uninstallKBFS', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const kbfsMountGetCurrentMountDirRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.kbfsMount.GetCurrentMountDir', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginAccountDeleteRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.accountDelete', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const loginDeprovisionRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.deprovision', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const loginGetConfiguredAccountsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.getConfiguredAccounts', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginLoginRpcSaga = (p, incomingCallMap, waitingKey) => call(getEngineSaga(), {method: 'keybase.1.login.login', params: p.params, incomingCallMap: p.incomingCallMap, waitingKey: p.waitingKey})
export const loginLogoutRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.logout', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const loginPaperKeyRpcSaga = (p, incomingCallMap, waitingKey) => call(getEngineSaga(), {method: 'keybase.1.login.paperKey', params: p.params, incomingCallMap: p.incomingCallMap, waitingKey: p.waitingKey})
export const loginPaperKeySubmitRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.paperKeySubmit', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const notifyCtlSetNotificationsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.notifyCtl.setNotifications', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const pgpPgpKeyGenDefaultRpcChannelMap = (configKeys, request) => engine()._channelMapRpcHelper(configKeys, 'keybase.1.pgp.pgpKeyGenDefault', request)
export const pgpPgpStorageDismissRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.pgp.pgpStorageDismiss', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const pprofLogProcessorProfileRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.pprof.logProcessorProfile', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const pprofLogTraceRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.pprof.logTrace', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const proveCheckProofRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.prove.checkProof', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const proveStartProofRpcChannelMap = (configKeys, request) => engine()._channelMapRpcHelper(configKeys, 'keybase.1.prove.startProof', request)
export const reachabilityCheckReachabilityRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.reachability.checkReachability', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const reachabilityStartReachabilityRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.reachability.startReachability', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const rekeyGetRevokeWarningRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.rekey.getRevokeWarning', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const rekeyRekeyStatusFinishRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.rekey.rekeyStatusFinish', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const rekeyShowPendingRekeyStatusRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.rekey.showPendingRekeyStatus', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const revokeRevokeDeviceRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.revoke.revokeDevice', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const revokeRevokeKeyRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.revoke.revokeKey', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const revokeRevokeSigsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.revoke.revokeSigs', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const signupCheckInvitationCodeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.checkInvitationCode', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const signupCheckUsernameAvailableRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.checkUsernameAvailable', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const signupGetInvitationCodeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.getInvitationCode', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const signupInviteRequestRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.inviteRequest', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const signupSignupRpcSaga = (p, incomingCallMap, waitingKey) => call(getEngineSaga(), {method: 'keybase.1.signup.signup', params: p.params, incomingCallMap: p.incomingCallMap, waitingKey: p.waitingKey})
export const teamsCanUserPerformRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.canUserPerform', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsGetTarsDisabledRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.getTarsDisabled', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsGetTeamAndMemberShowcaseRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.getTeamAndMemberShowcase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsSetTarsDisabledRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.setTarsDisabled', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsSetTeamMemberShowcaseRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.setTeamMemberShowcase', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsSetTeamShowcaseRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.setTeamShowcase', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamAcceptInviteOrRequestAccessRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAcceptInviteOrRequestAccess', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAddEmailsBulkRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAddEmailsBulk', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAddMemberRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAddMember', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAddMembersRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAddMembers', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamCreateRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamCreate', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamCreateSeitanTokenV2RpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamCreateSeitanTokenV2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamEditMemberRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamEditMember', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamGetRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamGet', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamIgnoreRequestRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamIgnoreRequest', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamLeaveRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamLeave', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamListMyAccessRequestsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamListMyAccessRequests', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamListRequestsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamListRequests', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamListUnverifiedRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamListUnverified', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamReAddMemberAfterResetRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamReAddMemberAfterReset', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamRemoveMemberRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamRemoveMember', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamSetSettingsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamSetSettings', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const teamsTeamTreeRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamTree', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsUploadTeamAvatarRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.uploadTeamAvatar', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const trackCheckTrackingRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.checkTracking', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const trackDismissWithTokenRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.dismissWithToken', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const trackTrackWithTokenRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.trackWithToken', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const trackUntrackRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.untrack', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const userInterestingPeopleRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.interestingPeople', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userListTrackers2RpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.listTrackers2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userLoadMySettingsRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.loadMySettings', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userProfileEditRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.profileEdit', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
export const userUploadUserAvatarRpcPromise = (params, waitingKey) => new Promise((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.uploadUserAvatar', params, callback: (error, result) => (error ? reject(error) : resolve()), waitingKey}))
